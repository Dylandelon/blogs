<!doctype html>
<html class="no-js" lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<title>kamidox.com</title>
		<meta name="description" content="">
		<meta name="author" content="Joey Huang">

		<link rel="stylesheet" href="../theme/css/foundation.css" />
		<link rel="stylesheet" href="../theme/css/pygment/monokai.css" />
		<link rel="stylesheet" href="../theme/css/custom.css" />


		<link rel="shortcut icon" href="../theme/img/favicon.ico">

		<script src="../theme/js/modernizr.js"></script>

		<!-- Feeds -->


		<!-- mathjax config similar to math.stackexchange -->
		<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
		<script>
		MathJax.Hub.Config({
		  config: ["MMLorHTML.js"],
		  extensions: ["tex2jax.js"],
		  jax: ["input/TeX"],
		  tex2jax: {
		    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
		    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
		    processEscapes: false
		  },
		  TeX: {
		    extensions: ["AMSmath.js", "AMSsymbols.js"],
		    TagSide: "right",
		    TagIndent: ".8em",
		    MultLineWidth: "85%",
		    equationNumbers: {
		      autoNumber: "AMS",
		    },
		    unicode: {
		      fonts: "STIXGeneral,'Arial Unicode MS'"
		    }
		  },
		  showProcessingMessages: false
		});
		</script>
	</head>
	<body>
		<div class="off-canvas-wrap">
			<div class="inner-wrap">
				<!-- mobile top bar to activate nav -->
				<nav class="tab-bar show-for-small">
					<section class="left-small">
						<a class="left-off-canvas-toggle menu-icon" ><span></span></a>
					</section>

					<section class="middle tab-bar-section">
						<h1 class="title">kamidox.com</h1>
					</section>
				</nav>

				<!-- mobile side bar nav -->
				<aside class="left-off-canvas-menu">
					<ul class="off-canvas-list">
							<li><a href="http://blog.kamidox.com">Home</a></li>
							<li><a href="http://blog.kamidox.com/about.html">About</a></li>

						<li><label>Categories</label></li>
							<li ><a href="../category/android.html">android</a></li>
							<li ><a href="../category/essay.html">essay</a></li>
							<li ><a href="../category/flask.html">flask</a></li>
							<li ><a href="../category/ml.html">ml</a></li>
							<li ><a href="../category/nlp.html">nlp</a></li>
							<li ><a href="../category/python.html">python</a></li>
							<li ><a href="../category/tools.html">tools</a></li>
							<li ><a href="../category/weapp.html">weapp</a></li>
							<li ><a href="../category/web.html">web</a></li>
							<li ><a href="../category/werkzeug.html">werkzeug</a></li>




						<li><label>Monthly Archives</label></li>
									<li><a href="/posts/2018/03/index.html">March 2018 (1)</a></li>
									<li><a href="/posts/2017/05/index.html">May 2017 (2)</a></li>
									<li><a href="/posts/2017/04/index.html">April 2017 (1)</a></li>
									<li><a href="/posts/2017/02/index.html">February 2017 (1)</a></li>
									<li><a href="/posts/2017/01/index.html">January 2017 (1)</a></li>
									<li><a href="/posts/2016/12/index.html">December 2016 (2)</a></li>
									<li><a href="/posts/2016/11/index.html">November 2016 (3)</a></li>
									<li><a href="/posts/2016/10/index.html">October 2016 (1)</a></li>
									<li><a href="/posts/2016/09/index.html">September 2016 (1)</a></li>
									<li><a href="/posts/2016/03/index.html">March 2016 (2)</a></li>
									<li><a href="/posts/2016/02/index.html">February 2016 (2)</a></li>
									<li><a href="/posts/2016/01/index.html">January 2016 (2)</a></li>
									<li><a href="/posts/2015/12/index.html">December 2015 (10)</a></li>
									<li><a href="/posts/2015/11/index.html">November 2015 (6)</a></li>
									<li><a href="/posts/2015/10/index.html">October 2015 (2)</a></li>
									<li><a href="/posts/2015/09/index.html">September 2015 (7)</a></li>
									<li><a href="/posts/2015/08/index.html">August 2015 (1)</a></li>
									<li><a href="/posts/2015/07/index.html">July 2015 (1)</a></li>
									<li><a href="/posts/2015/05/index.html">May 2015 (1)</a></li>
									<li><a href="/posts/2015/04/index.html">April 2015 (1)</a></li>
									<li><a href="/posts/2015/03/index.html">March 2015 (3)</a></li>
									<li><a href="/posts/2015/02/index.html">February 2015 (2)</a></li>
									<li><a href="/posts/2015/01/index.html">January 2015 (2)</a></li>
									<li><a href="/posts/2014/12/index.html">December 2014 (3)</a></li>
									<li><a href="/posts/2014/11/index.html">November 2014 (4)</a></li>
									<li><a href="/posts/2014/10/index.html">October 2014 (6)</a></li>
									<li><a href="/posts/2014/09/index.html">September 2014 (1)</a></li>
									<li><a href="/posts/2014/07/index.html">July 2014 (1)</a></li>


					</ul>
				</aside>

				<!-- top bar nav -->
				<nav class="top-bar hide-for-small-only" data-topbar>
					<ul class="title-area">
						<li class="name">
							<h1><a href="../">kamidox.com</a></h1>
						</li>
					</ul>

					<section class="top-bar-section">
						<ul class="left">
								<li><a href="http://blog.kamidox.com">Home</a></li>
								<li><a href="http://blog.kamidox.com/about.html">About</a></li>

						</ul>
					</section>
				</nav>

				<!-- Main Page Content and Sidebar -->
				<section class="main-section">
					<div class="row">
						<!-- Main Content -->
						<div class="medium-9 small-12 columns" role="content">
<article>
	<h2>日积月累</h2>
	<div class="toc">
<ul>
<li><a href="#20160406">20160406</a><ul>
<li><a href="#pelican">Pelican 代码阅读</a></li>
</ul>
</li>
<li><a href="#20150413">20150413</a><ul>
<li><a href="#alfred-stackoverflow-github">配置 Alfred 来搜索 StackOverflow 和 Github</a></li>
<li><a href="#unsplash-api">unsplash api</a></li>
<li><a href="#unsplash">壁纸应用，图片来自 unsplash</a></li>
</ul>
</li>
<li><a href="#20150416">20150416</a><ul>
<li><a href="#wallsplash-android-mainactivityjava">wallsplash-android MainActivity.java</a></li>
<li><a href="#wallsplash-android-imagesfragmentjava">wallsplash-android ImagesFragment.java</a></li>
<li><a href="#wallsplash-android-unsplashapijava">wallsplash-android UnsplashApi.java</a></li>
</ul>
</li>
<li><a href="#20150423">20150423</a><ul>
<li><a href="#_1">做成一件事情</a></li>
</ul>
</li>
<li><a href="#20150419">20150419</a><ul>
<li><a href="#android-performance-training">Android Performance Training</a></li>
</ul>
</li>
<li><a href="#20150607">20150607</a><ul>
<li><a href="#_2">《持续的幸福》阅读笔记</a></li>
</ul>
</li>
<li><a href="#20160614">20160614</a><ul>
<li><a href="#the-nodejs-philosophy">The Node.js philosophy</a></li>
</ul>
</li>
<li><a href="#20160615">20160615</a><ul>
<li><a href="#the-reactor-pattern">The reactor pattern</a></li>
</ul>
</li>
<li><a href="#20160616">20160616</a><ul>
<li><a href="#the-callback-pattern">The callback pattern</a></li>
</ul>
</li>
<li><a href="#20160620">20160620</a><ul>
<li><a href="#the-module-system-and-its-patterns">The module system and its patterns</a></li>
</ul>
</li>
<li><a href="#20160621">20160621</a><ul>
<li><a href="#rethinkdb">rethinkdb</a></li>
<li><a href="#leancloud">leancloud</a></li>
<li><a href="#wilddog">wilddog</a></li>
<li><a href="#iot">带网关的 IoT 系统通信需求</a></li>
<li><a href="#websocket-long-polling">websocket &amp; long-polling</a></li>
<li><a href="#xaas">XaaS</a></li>
</ul>
</li>
<li><a href="#20160622">20160622</a><ul>
<li><a href="#the-observer-pattern">The observer pattern</a></li>
</ul>
</li>
<li><a href="#20160624">20160624</a><ul>
<li><a href="#the-difficulties-of-asynchronous-programming">The difficulties of asynchronous programming</a></li>
<li><a href="#using-plain-javascript">Using plain JavaScript</a></li>
</ul>
</li>
<li><a href="#20160627">20160627</a><ul>
<li><a href="#parallel-execution">Parallel execution</a></li>
</ul>
</li>
<li><a href="#20160630">20160630</a><ul>
<li><a href="#limiting-the-concurrency">Limiting the concurrency</a></li>
<li><a href="#globally-limiting-the-concurrency">Globally limiting the concurrency</a></li>
</ul>
</li>
<li><a href="#20160704">20160704</a><ul>
<li><a href="#the-async-library">The async library</a></li>
<li><a href="#promises">Promises</a><ul>
<li><a href="#what-is-a-promise">What is a promise?</a></li>
<li><a href="#promisesa-implementations">Promises/A+ implementations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#20160705">20160705</a><ul>
<li><a href="#_3">选股辅助系统</a></li>
</ul>
</li>
<li><a href="#20160706">20160706</a><ul>
<li><a href="#promises_1">Promises</a><ul>
<li><a href="#promisifying-a-nodejs-style-function">Promisifying a Node.js style function</a></li>
<li><a href="#sequential-execution">Sequential execution</a></li>
<li><a href="#parallel-execution_1">Parallel execution</a></li>
<li><a href="#limited-parallel-execution">Limited parallel execution</a></li>
<li><a href="#_4">示例代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#20160713">20160713</a><ul>
<li><a href="#generator">Generator</a><ul>
<li><a href="#basic">Basic</a></li>
<li><a href="#generator-as-iterator">Generator as iterator</a></li>
<li><a href="#passing-values-back-to-a-generator">Passing values back to a generator</a></li>
<li><a href="#asynchronous-control-flow-with-generators">Asynchronous control flow with generators</a></li>
<li><a href="#generator-based-control-flow-using-co">Generator-based control flow using co</a></li>
<li><a href="#sequential-execution_1">Sequential execution</a></li>
<li><a href="#parallel-execution_2">Parallel execution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#20160715">20160715</a><ul>
<li><a href="#generator_1">Generator</a><ul>
<li><a href="#producer-consumer-pattern">Producer-consumer pattern</a></li>
</ul>
</li>
<li><a href="#_5">比较总结</a></li>
</ul>
</li>
<li><a href="#20160716">20160716</a><ul>
<li><a href="#_6">以练习为核心的编程学习打卡社区</a><ul>
<li><a href="#_7">核心业务流程</a></li>
<li><a href="#_8">内容运营开发</a></li>
<li><a href="#_9">课程示例</a></li>
<li><a href="#_10">运营模式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#20160720">20160720</a><ul>
<li><a href="#discovering-the-importance-of-streams">Discovering the importance of streams</a></li>
</ul>
</li>
<li><a href="#20160821">20160821</a><ul>
<li><a href="#blockly-games-bootjs">Blockly-Games - boot.js</a></li>
<li><a href="#blockly-games-deps">Blockly-Games - deps</a></li>
<li><a href="#blockly-games-build">Blockly-Games - build</a></li>
</ul>
</li>
<li><a href="#20160822">20160822</a><ul>
<li><a href="#google-closure-templates">Google Closure Templates</a></li>
<li><a href="#closure-templates-helloworld">Closure Templates HelloWorld</a></li>
</ul>
</li>
<li><a href="#20160823">20160823</a><ul>
<li><a href="#blockly-games-multi-languages">Blockly-Games - Multi-languages</a></li>
<li><a href="#blockly-games-closure-templates">Blockly-Games - closure-templates</a></li>
<li><a href="#blockly-games-mvc">Blockly-Games - MVC</a></li>
</ul>
</li>
<li><a href="#20160826">20160826</a><ul>
<li><a href="#_11">欺诈交易异常检测</a></li>
<li><a href="#_12">实施步骤</a></li>
<li><a href="#_13">高斯分布异常检测模型</a></li>
<li><a href="#_14">欺诈交易异常检测</a></li>
</ul>
</li>
<li><a href="#20160907">20160907</a><ul>
<li><a href="#_15">三步塑造你的职场气场</a></li>
</ul>
</li>
<li><a href="#20160911">20160911</a><ul>
<li><a href="#beyond-feelings-preface">Beyond Feelings - Preface</a></li>
<li><a href="#beyond-feeling-part-one-the-context">Beyond Feeling - Part One - The Context</a></li>
<li><a href="#beyond-feeling-chapter-1-who-are-you">Beyond Feeling - Chapter 1 - Who Are You?</a></li>
</ul>
</li>
<li><a href="#20160913">20160913</a><ul>
<li><a href="#beyond-feeling-becoming-an-individual">Beyond Feeling - Becoming an Individual</a></li>
<li><a href="#beyond-feeling-chapter-2-what-is-critical-thinking">Beyond Feeling - Chapter 2 What Is Critical Thinking?</a></li>
<li><a href="#_16">博客主题：从进化的角度看短视</a></li>
</ul>
</li>
<li><a href="#20160929">20160929</a><ul>
<li><a href="#_17">博客主题：难与易</a></li>
<li><a href="#_18">博客主题：龟毛的程序员</a></li>
<li><a href="#_19">博客主题：逆向思维</a></li>
<li><a href="#_20">博客主题：瞎忙是一种福分</a></li>
</ul>
</li>
<li><a href="#20161001">20161001</a></li>
<li><a href="#20161022">20161022</a><ul>
<li><a href="#app">跨平台 App 开发技术信息汇总</a><ul>
<li><a href="#hybrid">Hybrid 技术</a></li>
<li><a href="#_21">准原生平台</a></li>
<li><a href="#_22">总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#20161105">20161105</a><ul>
<li><a href="#_23">博客主题：微信小程序框架的实现原理</a></li>
<li><a href="#_24">博客主题：微信小程序开发环境的不足</a></li>
</ul>
</li>
<li><a href="#20161113">20161113</a><ul>
<li><a href="#_25">博客主题：白话网站架构演进</a></li>
</ul>
</li>
<li><a href="#20161120">20161120</a><ul>
<li><a href="#ssl">博客主题：白话 SSL 证书及安全性</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="20160406">20160406</h2>
<h3 id="pelican">Pelican 代码阅读</h3>
<ul>
<li>命令行参数解析: python std lib -&gt; argparse</li>
<li>Log 系统: python std lib -&gt; logging</li>
<li>导入 pelicanconf.py 中的设置信息<br />
  使用 <code>imp.load_source()</code> 或 <code>SourceFileLoader().load_module()</code> 把 <code>pelicanconf.py</code> 作为模块导入，再使用 <code>inspect.getmembers()</code> 来获取模块里的变量，所有的全大写的变量作为设置信息读取进来。导入模块时，也可以使用 <code>__import__()</code> 函数，但参数的形式是不一样的。</li>
<li>给定一个字符串 <code>pelican.Pelican</code>，怎么样用这个字符串所代表的类创建对象？<br />
  使用 <code>__import__</code> 和 <code>getattr()</code> 实现</li>
</ul>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">    cls <span style="color: #666666">=</span> settings[<span style="color: #BB4444">&#39;PELICAN_CLASS&#39;</span>]     <span style="color: #008800; font-style: italic"># default class: &#39;pelican.Pelican&#39;</span>
    <span style="color: #AA22FF; font-weight: bold">if</span> <span style="color: #AA22FF">isinstance</span>(cls, six<span style="color: #666666">.</span>string_types):
        module, cls_name <span style="color: #666666">=</span> cls<span style="color: #666666">.</span>rsplit(<span style="color: #BB4444">&#39;.&#39;</span>, <span style="color: #666666">1</span>)
        module <span style="color: #666666">=</span> <span style="color: #AA22FF">__import__</span>(module)
        cls <span style="color: #666666">=</span> <span style="color: #AA22FF">getattr</span>(module, cls_name)

    <span style="color: #AA22FF; font-weight: bold">return</span> cls(settings), settings
</pre></div>


<ul>
<li>如何把某个目录加入当前的模块搜索目录？<br />
  把目录添加进 <code>sys.path</code> 列表即可</li>
<li>进程内信号/事件: 使用 <a href="https://github.com/jek/blinker">blinker</a> 实现</li>
<li>插件系统</li>
<li>使用进程内信号 <code>blinker</code> 来实现与插件的通信</li>
<li>插件需要实现 <code>register()</code> 函数，这个函数由 Pelican 在初始化时调用</li>
<li>插件需要注册 Pelican 系统的信号，根据不同的信号做相应的处理，具体参阅 <code>docs/plugins.rst</code> 以及 <code>pelican/signals.py</code>。</li>
<li>如何处理可选的依赖包？<br />
  比如 Pelican 支持多种文档格式 markdown, rst, etc. 怎么样确保只使用 markdown 的人没安装 rst 转码库 <code>docutils</code> 也能正常运行呢？这里的方法是处理 <code>ImportError</code>，并且当发生 <code>ImportError</code> 时禁用这个转换器。</li>
<li>TODO: Reader/Writer/Generator 源码阅读</li>
</ul>
<h2 id="20150413">20150413</h2>
<h4 id="alfred-stackoverflow-github">配置 Alfred 来搜索 StackOverflow 和 Github</h4>
<ul>
<li>StackOverflow<br />
  http://stackoverflow.com/search?q={query}</li>
<li>Github<br />
  https://github.com/search?q={query}</li>
</ul>
<h4 id="unsplash-api">unsplash api</h4>
<p>http://tumblr.unsplash.com/api/read?num=10</p>
<h4 id="unsplash">壁纸应用，图片来自 unsplash</h4>
<p>https://github.com/kamidox/wallsplash-android</p>
<h2 id="20150416">20150416</h2>
<h4 id="wallsplash-android-mainactivityjava">wallsplash-android MainActivity.java</h4>
<ul>
<li>Enum for Java<br />
  definitin of MainActivity.Category</li>
<li>materialdrawer<br />
  https://github.com/mikepenz/MaterialDrawer</li>
<li>OpenLibra-Material<br />
  https://github.com/saulmm/OpenLibra-Material</li>
<li>aboutlibraries<br />
  https://github.com/mikepenz/AboutLibraries</li>
<li>iconics<br />
  https://github.com/mikepenz/Android-Iconics</li>
</ul>
<h4 id="wallsplash-android-imagesfragmentjava">wallsplash-android ImagesFragment.java</h4>
<ul>
<li>RecyclerView -&gt; fragment_images.xml<br />
  A flexible view for providing a limited window into a large data set.<br />
  REF: GridLayoutManager, RecyclerView.Adapter</li>
<li>ActivityOptionsCompat<br />
  Helper for accessing features in android.app.ActivityOptions introduced in API level 16 in a backwards compatible fashion.</li>
<li>errorview<br />
  https://github.com/xiprox/ErrorView<br />
  A custom view that displays an error image, a title, and a subtitle given an HTTP status code.</li>
</ul>
<h4 id="wallsplash-android-unsplashapijava">wallsplash-android UnsplashApi.java</h4>
<ul>
<li>RxAndroid<br />
  https://github.com/ReactiveX/RxAndroid<br />
  Android specific bindings for RxJava</li>
<li>RxJava<br />
  https://github.com/ReactiveX/RxJava<br />
  RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM</li>
<li>retrofit<br />
  https://github.com/square/retrofit<br />
  Type-safe REST client for Android and Java by Square, Inc.</li>
<li>okhttp<br />
  https://github.com/square/okhttp<br />
  An HTTP+SPDY client for Android and Java applications.</li>
<li>Gson<br />
  https://github.com/google/gson<br />
  Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.</li>
<li>API<br />
  http://wallsplash.lanora.io/pictures<br />
  http://wallsplash.lanora.io/random</li>
</ul>
<h2 id="20150423">20150423</h2>
<h4 id="_1">做成一件事情</h4>
<ul>
<li>选择一个方向：Android 进阶社区</li>
<li>持续输入价值：入门，进阶，疑难问题案例分析</li>
<li>持续运营：把文章/视频发到热闹的社区引流</li>
<li>想像空间：证明团队价值；与更大的世界发生交集；</li>
</ul>
<p><strong>注意点</strong>：专注；持续；快乐。忌朝三暮四，左顾右盼。</p>
<h2 id="20150419">20150419</h2>
<h4 id="android-performance-training">Android Performance Training</h4>
<ul>
<li>udacity.com 上来自 google 官方的原始资料<br />
  https://www.udacity.com/course/viewer#!/c-ud825/l-3729268966/m-3785788694</li>
<li>ChinaGDG from youku.com<br />
  整理出几个专题：主要是内存专题和电池专题。同归复习渲染和运算专题。<br />
  http://www.youku.com/playlist_show/id_23494296.html</li>
<li>通过示例现场演示几个工具的使用<br />
  Memory Monitor, Heap Viewer, Allocation Tracker</li>
<li>可参考的文章<br />
  hukai.me<br />
  http://hukai.me/android-performance-memory</li>
</ul>
<h2 id="20150607">20150607</h2>
<h4 id="_2">《持续的幸福》阅读笔记</h4>
<ul>
<li>幸福 1.0 vs 幸福 2.0<br />
  幸福 1.0 主要关注生活满意度，由积极情绪，投入和意义构成。而幸福 2.0 则由 PERMA 指标构成，具体就是积极情绪，投入，意义，成就，积极的人际关系。Seligman 教授认为，要让人生蓬勃发展，可以提高这五项指标来获得。</li>
<li>三件好事练习<br />
  从进化的角度来看，人是悲观偏好的，那些过分乐观的人活不过冰河世纪。如何克服悲观偏好，可以从三个好事练习着手。即每天记录三个好事，可以是大事（如获得升职），也可以是生活的小事（如发现一个好吃的饭馆）。然后写上这个事对你的影响或产生的原因。这样来引导自己多关注积极的事情。</li>
<li>突出优势练习<br />
  通过 www.authentichappiness.org 来测量自己的性格优势，通过发挥自己的性格优势来增加幸福感。</li>
<li>积极主动式回应 vs 消极主动式回应<br />
  女儿告诉我她在学校运动会上获得了一个奖牌。<br />
  积极主动：太棒了，你拿到奖牌时是什么感受？你的同学是什么反应？这个运动挺难的，平时没见你练啊，你怎么拿到奖牌的？<br />
  积极被动：哦，真厉害。<br />
  消极被动：我今天上班很累。<br />
  消极主动：不好好读书，拿个运动会奖牌干什么用，把时间花在学习上。</li>
<li>洛萨达比例<br />
  职场洛萨达比例在 3:1 以上时，公司的业务是蓬勃发展的。要获得良好的家庭生活，洛萨达比例需要达到 5:1。<br />
  洛萨达比例 (以其发现者 Marcel Losada 命名) 是指对所有的语言按照积极和消极进行编码，积极和消极的比例即洛萨达比例。</li>
<li>成就公式<br />
  成就 = 技能 x 努力。成就是一个矢量，而不是绝对距离。成就是朝一个特定的方向持续努力的结果。<br />
<strong>速度</strong>: 自动化的东西越多，速度越快，我们对该任务的知识就越多。<br />
<strong>缓慢</strong>: 成就中举足轻重，有意识的过程（如规划，精细化，检查错误和创造）。速度越快，知识越多，留给这些执行功能的时间就越多。<br />
<strong>学习速度</strong>: 新的信息能以多快的速度变为自动知识，以留给缓慢的执行过程更多的时间。</li>
<li>学习的速度<br />
  技能的学习是让我们获得一种自动化处理的能力。比如打字，刚开始的时候需要先想我们打什么字，这个字由哪几个字根组成，这些字根在哪个按键上，然后手指再按下这些按键。这是技能，当这项技能经过足够多的练习，变成一个自动化的过程后，打字就快很多了。因为头脑在想打哪个字的时候，手指已经直接按下能打出这个字所在的键盘了。这就是自动化处理能力。自动化处理能力可以大大提高效率。这也是一万小时天才理论的基础。学习的快，是指你能以多快的速度培养一项技能的自动化处理能力。</li>
<li>创伤后成长的五要素<br />
  1. 认识到创伤后信念崩塌是正常的反应；<br />
  2. 减少焦虑和强迫性的想法；<br />
  3. 讲出创作经历；<br />
  4. 描述创伤后积极的改变；<br />
  5. 总结因为创伤而产生的更加坚强，更加无惧挑战的人生原则和立场。<br />
<strong>那些杀不死我的，必将使我强大。</strong>&mdash;尼采</li>
<li>ABCDE 模式<br />
  情感的后果不是由不好的事情导致的，而是由你对这个事情的解读导致的。<br />
  Adversity -&gt; Belief -&gt; Consequence。Disputation 代表反驳，Energization 代表你成功进行反驳后受到的启发。</li>
<li>习得性无助<br />
  经历过束手无策的逆境，再遇到逆境时，就会变得消极被动，容易放弃。<br />
<strong>实验第一部份</strong><br />
  掌握组：老鼠经历 64 次可避免的电击。<br />
  无助组：老鼠经历 64 次无法避免电击。<br />
  对照组：没有受到电击。<br />
<strong>实验第二部分</strong>：注射有 50% 概率到死的癌细胞<br />
  掌握组：25% 死亡率<br />
  无助组：75% 死亡率<br />
  对照组：50% 死亡率</li>
</ul>
<h2 id="20160614">20160614</h2>
<p>Node.js Design Patterns: Chapeter 1 Node.js Design Fundamentals</p>
<p>异步和回调；模块系统；观察者模式等等</p>
<h3 id="the-nodejs-philosophy">The Node.js philosophy</h3>
<ul>
<li>Small Core: 微内核</li>
<li>Small Module: 小模块。解决了 dependency hell 问题，每个模块可以有自己独立的依赖模块列表。即一个软件可以依赖同一个模块的不同版本。</li>
<li>Small is beautiful.</li>
<li>Make each program do one thing well.</li>
<li>Easier to understand and use</li>
<li>Simpler to test and maintain</li>
<li>Perfect to share with the browser</li>
<li>Small surface area: 小接口。暴露出最小的，最重要的接口。次要的放在模块的属性，方法里。</li>
<li>暴露尽量少的接口 -&gt; 易于使用</li>
<li>模块设计的目的是为了被使用，而不是被扩展</li>
<li>Simplicity and pragmatism: 简单实用原则</li>
</ul>
<h2 id="20160615">20160615</h2>
<p>最高效的深度拷贝库: https://github.com/ivolovikov/fastest-clone</p>
<ul>
<li>javascript 元编程：利用 <code>new Function('params', 'function body')</code> 或 <code>eval('code')</code> 来进行实现函数</li>
<li>javascript 元编程：利用 <code>Function.prototype.call()</code> 或 <code>Function.prototype.apply()</code> 来对函数进行调用</li>
<li>判断是否在 node.js 环境： <code>if (typeof module == 'object' &amp;&amp; typeof module.exports == 'object')</code></li>
<li>递归获取 Object 实例的所有属性以及属性的属性：<code>_getKeyMap: function (source, deep, baseKey, arrIndex)</code></li>
</ul>
<p>Node.js Design Patterns: Chapeter 1 Node.js Design Fundamentals</p>
<h3 id="the-reactor-pattern">The reactor pattern</h3>
<ul>
<li>I/O is slow: 与内存访问速度在 GB/s 数量级；磁盘的访问速度在 MB/s 数量级。</li>
<li>Blocking I/O:　阻塞式访问 I/O ，需要用多线程机制来处理并发。需要增加线程锁和线程数据同步，增加了复杂性。</li>
<li>Non-blocking I/O: 使用非阻塞式 I/O 的一个方案是忙等待 (Busy Wait)，即不停地调用 I/O 函数，直到读出数据或出错为止。这种方案较浪费 CPU 。</li>
<li>Event demultiplexing: 多路事件分解器来提高使用非阻塞 I/O 的效率。把所有待监控的资源都放在一个数组里，交给事件分解器来监视，当资源上有事件发生（比如有数据可供读取）时，监视动作返回，再去读取数据。当没有事件发生时，监控函数会进入睡眠状态，把 CPU 让给别的程序。这一编程模式类似用 <code>select</code> 函数实现异步 Socket 编程。</li>
<li>The reactor pattern: 反应堆模式。比 Event demultiplexing 更进一步。直接给资源的操作提供一个 Handler 作为回调函数。当资源可用时，直接调用回调函数。实现完整的异步 I/O 编程模式。</li>
<li>libuv: The non-blocking I/O engine of Node.js。不同的操作系统有各种的 Event demultiplexing 机制，比如 Linux 下的 <code>epoll</code>，Mac OS X 下的 <code>kqueue</code>，Windows 下的 I/O Completion Port API (IOCP)。不同平台的事件分发机制不同，且同一个平台下不同的资源的异步模式也不同。比如 Unix 下 socket 支持异步 I/O，而普通的文件系统 API 则不支持异步 I/O，这个时候就需要用单独的线程来模拟异步文件读写操作。libuv 库就是为了解决这些问题而产生的。它向 javascript 提供了不同操作系统，不同资源的异步 I/O 的抽像封装和实现。</li>
<li>The recipe for Node.js: Node.js 包含以下几部分</li>
<li>操作系统底层接口的封装，并暴露给 javascript 调用，如 libuv 等</li>
<li>V8, 这是 Google 给 Chrome 开发的高性能的 javascript 引擎</li>
<li>node.js 核心库 (node-core)，实现 Node.js 的高层 API</li>
</ul>
<h2 id="20160616">20160616</h2>
<p>Node.js Design Patterns: Chapeter 1 Node.js Design Fundamentals</p>
<h3 id="the-callback-pattern">The callback pattern</h3>
<ul>
<li>The continuation-passing style: CPS 把函数作为参数传递，完成回调</li>
<li>Synchronous continuation-passing style：同步回调，即函数返回后，回调也己调用了。</li>
<li>Asynchronous continuation-passing style：异步回调，即函数返回后，回调还没被调用，回调会被推送到 event queue 里，在下一轮的 event loop 里调用回调。比如使用 <code>setTimeout()</code>， <code>process.nextTick()</code> 来实现。</li>
<li>Non continuation-passing style callbacks：非 CPS 方式的回调。比如 <code>Array.map()</code> 的回调函数，通过回调函数的返回值直接交互。</li>
<li>Synchronous or asynchronous?：同步还是异步？</li>
<li>An unpredictable function：同步和异步不可预见性，即<a href="#an_unpredictable_function">有时是同步回调，有时是异步回调</a>。这种问题会引入非常难查的 bug 。</li>
<li>Using synchronous APIs：改装成同步 API，比如通过 <code>fs.readFileSync()</code> 函数来实现。不推荐使用这种方式，会破坏 Node.js 的异步 I/O 模式。一个判断标准是：Use blocking API only when they don&rsquo;t affect the ability of the application to serve concurrent requests.</li>
<li>Deferred execution：延后执行，把 API 改装成异步回调。通过 <code>process.nextTick()</code> 实现。需要注意在 event loop 里的优先级。</li>
<li>Node.js callback conventions: Node.js 的回调惯例</li>
<li>Callbacks come last: 把回调放在最后一个参数，这样在使用的时候，可以直接用匿名函数或箭头函数实现。如 <code>fs.readFile(filename, [options], callback)</code> 。</li>
<li>Error comes first: 把错误放在第一个参数。在 Node.js 里，CPS 风格的回调的第一个参数通常是错误信息，数据结果在第二个及之后的参数提供。如果没有出错，第一个参数的值为 <code>null</code> 或 <code>undefined</code> 。如 <code>fs.readFile('foo.txt', 'utf8', function(err, data) {}</code> 。</li>
<li>Propagating errors: 错误传递机制。同步调用时，错误传递机制通过 <code>throw</code> 来抛出异常，这样可以使错误在调用栈里往上跳，直到它被处理为止。而在异常调用里，异常处理的机制是，在 CPS 回调链里，通过回调函数一层层往上传递。可参阅<a href="#propagating_errors">示例代码</a>。</li>
<li>Uncaught exceptions: 未处理的异常可以通过 <code>process.on('uncaughtException', function(err){}</code> 来捕获到。系统默认是直接退出程序。一般的处理是在这里记录异步 Log ，然后退出程序。针对网络服务而言，退出程序重启总是保证持续服务可用的一个折衷策略。</li>
</ul>
<p><a name="an_unpredictable_function"></a><strong>同步或异步不可预测的函数</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> fs <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;fs&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> cache <span style="color: #666666">=</span> {};
<span style="color: #AA22FF; font-weight: bold">function</span> inconsistentRead(filename, callback) {
  <span style="color: #AA22FF; font-weight: bold">if</span>(cache[filename]) {
    <span style="color: #008800; font-style: italic">//invoked synchronously</span>
    callback(cache[filename]);
  } <span style="color: #AA22FF; font-weight: bold">else</span> {
    <span style="color: #008800; font-style: italic">//asynchronous function</span>
    fs.readFile(filename, <span style="color: #BB4444">&#39;utf8&#39;</span>, <span style="color: #AA22FF; font-weight: bold">function</span>(err, data) {
      cache[filename] <span style="color: #666666">=</span> data;
      callback(data);
    });
  }
}
</pre></div>


<p><a name="propagating_errors"></a><strong>异步回调的异常处理</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> fs <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;fs&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">function</span> readJSON(filename, callback) {
  fs.readFile(filename, <span style="color: #BB4444">&#39;utf8&#39;</span>, <span style="color: #AA22FF; font-weight: bold">function</span>(err, data) {
    <span style="color: #AA22FF; font-weight: bold">var</span> parsed;
    <span style="color: #AA22FF; font-weight: bold">if</span>(err)
      <span style="color: #008800; font-style: italic">//propagate the error and exit the current function</span>
      <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
    <span style="color: #AA22FF; font-weight: bold">try</span> {
      <span style="color: #008800; font-style: italic">//parse the file contents</span>
      parsed <span style="color: #666666">=</span> JSON.parse(data);
    } <span style="color: #AA22FF; font-weight: bold">catch</span>(err) {
      <span style="color: #008800; font-style: italic">//catch parsing errors</span>
      <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
    }
    <span style="color: #008800; font-style: italic">//no errors, propagate just the data</span>
    callback(<span style="color: #AA22FF; font-weight: bold">null</span>, parsed);
  });
};
</pre></div>


<h2 id="20160620">20160620</h2>
<p>Node.js Design Patterns: Chapeter 1 Node.js Design Fundamentals</p>
<h3 id="the-module-system-and-its-patterns">The module system and its patterns</h3>
<p>模块系统是 Node.js 的代码结构化的基础，实现信息隐藏和接口实现的功能。</p>
<ul>
<li>The revealing module pattern: 模块系统的本质是利用函数来创建具有信息隐藏功能的代码块。函数内的嵌套函数及变量对模块外部不可见，只有函数返回的属性和方法才对外可见。</li>
<li>Node.js modules explained: 官方文档 <a href="https://nodejs.org/api/modules.html">Node.js 模块系统</a> 是最权威且最清晰的资料。</li>
<li>module.exports vs exports: The variable exports is just a reference to the initial value of module. exports。</li>
<li>require is synchronous</li>
<li>The resolving algorithm</li>
<li>File modules: 以 <code>/</code> 或 <code>./</code> 或 <code>../</code> 开头的参数，解释为文件模块</li>
<li>Core modules: 如果没有以路径开头，则解释为 Node.js 核心内置模块，如 <code>var fs = require(fs);</code> 。</li>
<li>Package modules: 如果没有核心模块与之匹配，则查找当前目录下的 <code>node_modules</code> 目录下查找匹配的模块，如果找不到，则查找从父目录的 <code>node_modules</code> 目录下查找，直至根目录下的 <code>node_modules</code> 。</li>
<li>文件模块/包模块匹配策略<ul>
<li><code>moduleName.js</code></li>
<li><code>moduleName/index.js</code></li>
<li>The <code>main</code> property of <code>moduleName/package.json</code></li>
</ul>
</li>
<li>Solution for <strong>Dependency Hell</strong>: 按照上述模块搜索算法，每个模块都可以通过自己的 <code>node_modules</code> 子目录指定其依赖的子模块。这样即使同一个应用程序里不同模块引用了相同的子模块，他们各自独立，可以是不同的版本。</li>
<li>The module cache: 模块缓存可以解决几个问题</li>
<li>循环引用问题</li>
<li>确保引用的一致性</li>
<li>加快效率</li>
<li>Cycles: 模块循环引用问题，A require B, B require A</li>
<li>Module de nition patterns</li>
<li>Named exports: <code>exports.info = function(message) { ... }</code></li>
<li>Exporting a function: <code>module.exports = function(message) { ... }</code></li>
<li>Exporting a constructor: <a href="#exporting_a_constructor">示例代码</a></li>
<li>Exporting an instance: <a href="#exporting_an_instance">示例代码</a>。巧妙地利用模块的缓存功能，使每个引用此模块的模块都引用了同一个实例。这样就实现了单例 (Singleton) 模式。</li>
<li>Modifying other modules or the global scope: 不是好的实践，但在自动测试领域有其应用场景，我们称之为猴子补丁 (Monkey Patching) 。<a href="#monkey_patching">示例代码</a> 。</li>
</ul>
<p><a name="exporting_a_constructor"></a><strong>模块返回构造函数</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008800; font-style: italic">//file logger.js</span>
<span style="color: #AA22FF; font-weight: bold">function</span> Logger(name) {
 <span style="color: #AA22FF; font-weight: bold">this</span>.name <span style="color: #666666">=</span> name;
};
Logger.prototype.log <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span>(message) {
 console.log(<span style="color: #BB4444">&#39;[&#39;</span> <span style="color: #666666">+</span> <span style="color: #AA22FF; font-weight: bold">this</span>.name <span style="color: #666666">+</span> <span style="color: #BB4444">&#39;] &#39;</span> <span style="color: #666666">+</span> message);
};
Logger.prototype.info <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span>(message) {
 <span style="color: #AA22FF; font-weight: bold">this</span>.log(<span style="color: #BB4444">&#39;info: &#39;</span> <span style="color: #666666">+</span> message);
};
Logger.prototype.verbose <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span>(message) {
 <span style="color: #AA22FF; font-weight: bold">this</span>.log(<span style="color: #BB4444">&#39;verbose: &#39;</span> <span style="color: #666666">+</span> message);
};
module.exports <span style="color: #666666">=</span> Logger;
</pre></div>


<p><a name="exporting_an_instance"></a><strong>模块返回一个实例/单例</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008800; font-style: italic">// file logger.js</span>
<span style="color: #AA22FF; font-weight: bold">function</span> Logger(name) {
  <span style="color: #AA22FF; font-weight: bold">this</span>.count <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
  <span style="color: #AA22FF; font-weight: bold">this</span>.name <span style="color: #666666">=</span> name;
};

Logger.prototype.log <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span>(message) {
  <span style="color: #AA22FF; font-weight: bold">this</span>.count<span style="color: #666666">++</span>;
  console.log(<span style="color: #BB4444">&#39;[&#39;</span> <span style="color: #666666">+</span> <span style="color: #AA22FF; font-weight: bold">this</span>.name <span style="color: #666666">+</span> <span style="color: #BB4444">&#39;] &#39;</span> <span style="color: #666666">+</span> message);
};
module.exports <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">new</span> Logger(<span style="color: #BB4444">&#39;DEFAULT&#39;</span>);
</pre></div>


<p><a name="monkey_patching"></a><strong>猴子补丁</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008800; font-style: italic">// file patcher.js</span>
<span style="color: #008800; font-style: italic">// ./logger is another module</span>
require(<span style="color: #BB4444">&#39;./logger&#39;</span>).customMessage <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span>() {
  console.log(<span style="color: #BB4444">&#39;This is a new functionality&#39;</span>);
};

<span style="color: #008800; font-style: italic">// Using our new patcher module would be as easy as writing the following code:</span>
<span style="color: #008800; font-style: italic">// file main.js</span>
require(<span style="color: #BB4444">&#39;./patcher&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> logger <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;./logger&#39;</span>);
logger.customMessage();
</pre></div>


<h2 id="20160621">20160621</h2>
<h3 id="rethinkdb">rethinkdb</h3>
<p>提供在线数据库，提供数据的增删改查。一大亮眼特性是 changefeed。它能够把数据库中某个查询结果集的改变 publish 出来，供其他人 subscribe。这个特性对 realtime collaboration 的 app 来说非常有用。可以实现数据实时同步。</p>
<p>什么样的场景适合使用 rethinkdb ?</p>
<ul>
<li>Collaborative web and mobile apps</li>
<li>Streaming analytics apps</li>
<li>Multiplayer games</li>
<li>Realtime marketplaces</li>
<li>Connected devices</li>
</ul>
<h3 id="leancloud">leancloud</h3>
<p>提供在线非结构化数据库，提供数据的增删改查。辅助类，提供实时聊天及推送，流量分析等功能。</p>
<h3 id="wilddog">wilddog</h3>
<p>国内的 BaaS (Backend as a Service) 平台。提供两大功能：</p>
<ul>
<li>实时同步: 提供毫秒级实时数据同步。使用 TLS + websocket 保障通信安全。不支持 websocket 的环境使用 long-polling 模拟长连接。保障通信实时性。即一个数据修改后，另外一个订阅者可以马上得到同步。</li>
<li>在线 Json 数据库：提供数据的增删改查功能。</li>
</ul>
<h3 id="iot">带网关的 IoT 系统通信需求</h3>
<ul>
<li>安全性：通信安全 (TLS) 及访问授权 (Auth)</li>
<li>实时性：控制命令和状态能及时送达，达到毫秒级实时性</li>
<li>双向通信：不同于 request/response 响应模型。App 与 Gateway，App 与 Server 之间必须支持双向实时通信。</li>
<li>一致性：App 与 Gateway 之间；App 与 Server 之间需要实现一致的通信协议和通信模型，减少系统复杂度和开发工作量。</li>
</ul>
<h3 id="websocket-long-polling">websocket &amp; long-polling</h3>
<ul>
<li><a href="http://tools.ietf.org/html/rfc6455">RFC 6455 - The WebSocket Protocol</a></li>
<li><a href="http://www.w3.org/TR/websockets/">WebSocket API Specification</a></li>
<li><a href="http://socket.io">socket.io</a>: A powerful cross-platform WebSocket API for Node.js</li>
</ul>
<h3 id="xaas">XaaS</h3>
<blockquote>
<p>传统云服务公司的定义：SaaS、PaaS、IaaS。越往下自由度越高，越往上使用起来越简单。<br />
SaaS解决的是开箱即用的问题，不用写代码，直接用。PaaS解决的是运维的问题，写完代码往云端一扔，搞定。而IaaS解决的是硬件资源弹性扩容的问题，像个水龙头，用多少拧多少。<br />
目前PaaS代表的产品比如HeroKu，Google App Engine、国内SAE等，几乎全线已挂或半死不活。PaaS挂掉的原因是没有解决根本问题，半吊子。又不简单，又不自由。<br />
广义BaaS是指用户需要通过远程API获得服务的云服务产品。比如类似统计服务MixPanel、友盟等。狭义的BaaS是指通过远程API提供计算和存储资源的产品，比如Parse、Firebase、Twilio、Pusher，Apple Cloud Kit这样的产品。</p>
</blockquote>
<p>REF: http://www.leiphone.com/news/201605/UQ4LxnsXfxqv2r39.html</p>
<h2 id="20160622">20160622</h2>
<p>Node.js Design Patterns: Chapeter 1 Node.js Design Fundamentals</p>
<h3 id="the-observer-pattern">The observer pattern</h3>
<p>The observer pattern is already built into the Node.js core and is available through the <code>EventEmitter</code> class.</p>
<ul>
<li>EventEmitter 类的用法，可以手动创建一个 <code>EventEmitter</code> 实例来使用。</li>
<li>错误处理：不能直接抛出异常，因为事件回调一般在单独的消息循环里处理，抛出的异常会丢失。一个通用的做法是定义一个独立的 <code>error</code> 事件，然后 <code>emmit</code> 这个事件。</li>
<li>Make any object observable：通过继承 <code>EventMitter</code> 来实现。ES5 可以通过 <code>util.inherits()</code> 实现，ES6 可以直接用 <code>inherit</code> 关键字实现。</li>
<li>Synchronous and asynchronous events: 同步事件和异常事件</li>
<li>EventEmitter vs Callbacks: 应该用哪个呢？</li>
<li>semantic: callbacks should be used when a result must be returned in an asynchronous way; events should instead be used when there is a need to communicate that something has just happened.</li>
<li>如果一个事件可能发生多次，或者可能根本不会发生，使用 EventEmitter 是较好的选择</li>
<li>使用 EventEmitter 可以让多个监听者同时监听到事件。而 callback 是一对一的结果返回。</li>
<li>Combine callbacks and EventEmitter: 结合两者的优势。</li>
</ul>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> glob <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;glob&#39;</span>);
glob(<span style="color: #BB4444">&#39;data/*.txt&#39;</span>, <span style="color: #AA22FF; font-weight: bold">function</span>(error, files) {
  console.log(<span style="color: #BB4444">&#39;All files found: &#39;</span> <span style="color: #666666">+</span> JSON.stringify(files));
}).on(<span style="color: #BB4444">&#39;match&#39;</span>, <span style="color: #AA22FF; font-weight: bold">function</span>(match) {
  console.log(<span style="color: #BB4444">&#39;Match found: &#39;</span> <span style="color: #666666">+</span> match);
});
</pre></div>


<p>关于 <code>EventEmitter</code> 可参阅<a href="https://nodejs.org/dist/latest-v6.x/docs/api/events.html">官方资料</a> 。</p>
<h2 id="20160624">20160624</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="the-difficulties-of-asynchronous-programming">The difficulties of asynchronous programming</h3>
<p><strong>The callback hell</strong>: 使用 <code>request</code> 和 <code>mkdirp</code> 实现的一个简单的爬虫程序，可以明显地看到异步流程控制代码很容易陷入 callback hell 的陷阱。如<a href="#callback_hell">示例程序</a>。callback hell 的代码有如下问题：</p>
<ul>
<li>可读性差：很难界定回调函数的起始位置和结束位置</li>
<li>变量名重叠：比如回调函数里的错误码 <code>err</code> 在每个回调函数里都有，容易引起误解</li>
<li>闭包函数会引起少量的内存和性能问题，比如内存泄露</li>
</ul>
<p><a name="callback_hell"></a><strong>爬虫程序：callback hell</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> spider(url, callback) {
    <span style="color: #AA22FF; font-weight: bold">var</span> filename <span style="color: #666666">=</span> utilities.urlToFilename(url);
    fs.exists(filename, <span style="color: #AA22FF; font-weight: bold">function</span>(exists) {                              <span style="color: #008800; font-style: italic">//[1]</span>
        <span style="color: #AA22FF; font-weight: bold">if</span>(<span style="color: #666666">!</span>exists) {
            console.log(<span style="color: #BB4444">&quot;Downloading &quot;</span> <span style="color: #666666">+</span> url);
            request(url, <span style="color: #AA22FF; font-weight: bold">function</span>(err, response, body) {                <span style="color: #008800; font-style: italic">//[2]</span>
                <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
                    callback(err);
                } <span style="color: #AA22FF; font-weight: bold">else</span> {
                    mkdirp(path.dirname(filename), <span style="color: #AA22FF; font-weight: bold">function</span>(err) {      <span style="color: #008800; font-style: italic">//[3]</span>
                        <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
                            callback(err);
                        } <span style="color: #AA22FF; font-weight: bold">else</span> {
                            fs.writeFile(filename, body, <span style="color: #AA22FF; font-weight: bold">function</span>(err) { <span style="color: #008800; font-style: italic">//[4]</span>
                                <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
                                    callback(err);
                                } <span style="color: #AA22FF; font-weight: bold">else</span> {
                                    callback(<span style="color: #AA22FF; font-weight: bold">null</span>, filename, <span style="color: #AA22FF; font-weight: bold">true</span>);
                                } });
                        } });
                } });
        } <span style="color: #AA22FF; font-weight: bold">else</span> {
            callback(<span style="color: #AA22FF; font-weight: bold">null</span>, filename, <span style="color: #AA22FF; font-weight: bold">false</span>);
        } });
}
</pre></div>


<h3 id="using-plain-javascript">Using plain JavaScript</h3>
<p>使用 JavaScript 的一些通用规则可以避免 callback hell 问题。</p>
<p><strong>Callback discipline</strong>: 编写回调函数的一些原则</p>
<ul>
<li>You must exit as soon as possible. 尽早返回。即先处理错误。</li>
<li>You need to create named functions for callbacks. 给回调创建命名函数。</li>
<li>You need to modularize the code. Split the code into smaller, reusable functions whenever it&rsquo;s possible.</li>
</ul>
<p>下面是按照编写回调函数的原则执行后的改进版本：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> saveFile(filename, contents, callback) {
    mkdirp(path.dirname(filename), <span style="color: #AA22FF; font-weight: bold">function</span>(err) {
        <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
            <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
        }
        fs.writeFile(filename, contents, callback);
    });
}

<span style="color: #AA22FF; font-weight: bold">function</span> download(url, filename, callback) {
    console.log(<span style="color: #BB4444">&#39;Downloading &#39;</span> <span style="color: #666666">+</span> url);
    request(url, <span style="color: #AA22FF; font-weight: bold">function</span>(err, response, body) {
        <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
            <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
        }
        saveFile(filename, body, <span style="color: #AA22FF; font-weight: bold">function</span>(err) {
            console.log(<span style="color: #BB4444">&#39;Downloaded and saved: &#39;</span> <span style="color: #666666">+</span> url);
            <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
                <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
            }
            callback(<span style="color: #AA22FF; font-weight: bold">null</span>, body);
        });
    });
}

<span style="color: #AA22FF; font-weight: bold">function</span> spider(url, callback) {
    <span style="color: #AA22FF; font-weight: bold">var</span> filename <span style="color: #666666">=</span> utilities.urlToFilename(url);
    fs.exists(filename, <span style="color: #AA22FF; font-weight: bold">function</span>(exists) {
        <span style="color: #AA22FF; font-weight: bold">if</span>(exists) {
            <span style="color: #AA22FF; font-weight: bold">return</span> callback(<span style="color: #AA22FF; font-weight: bold">null</span>, filename, <span style="color: #AA22FF; font-weight: bold">false</span>);
        }
        download(url, filename, <span style="color: #AA22FF; font-weight: bold">function</span>(err) {
            <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
                <span style="color: #AA22FF; font-weight: bold">return</span> callback(err);
            }
            callback(<span style="color: #AA22FF; font-weight: bold">null</span>, filename, <span style="color: #AA22FF; font-weight: bold">true</span>);
        })
    });
}
</pre></div>


<p><strong>Sequential execution</strong>: 顺序执行</p>
<p>爬虫程序就是一个典型的顺序执行的程序。文件是否存在 -&gt; 从网络下载 -&gt; 新建文件夹 -&gt; 写文件。对己知的顺序执行的异步任务，可以使用下面的代码模板：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> task1(callback) {
    asyncOperation(<span style="color: #AA22FF; font-weight: bold">function</span>() {
        Start Task <span style="color: #666666">1</span> Task <span style="color: #666666">2</span> Task <span style="color: #666666">3</span> End
        task2(callback);
    });
}

<span style="color: #AA22FF; font-weight: bold">function</span> task2(callback) {
    asyncOperation(<span style="color: #AA22FF; font-weight: bold">function</span>(result) {
        task3(callback);
    });
}

<span style="color: #AA22FF; font-weight: bold">function</span> task3(callback) {
    asyncOperation(<span style="color: #AA22FF; font-weight: bold">function</span>() {
        callback();
    });
}

task1(<span style="color: #AA22FF; font-weight: bold">function</span>() {
    <span style="color: #008800; font-style: italic">//task1, task2, task3 completed</span>
});
</pre></div>


<p><strong>Sequential iteration</strong>: 异步遍历序列数据</p>
<ul>
<li><code>task()</code> 函数最好是异步函数，如果是同步函数，可能造成深度递归，从而使栈溢出</li>
</ul>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> iterate(index) {
    <span style="color: #AA22FF; font-weight: bold">if</span>(index <span style="color: #666666">===</span> tasks.length)  {
        <span style="color: #AA22FF; font-weight: bold">return</span> finish();
    }
    <span style="color: #AA22FF; font-weight: bold">var</span> task <span style="color: #666666">=</span> tasks[index];
    task(<span style="color: #AA22FF; font-weight: bold">function</span>() {
        iterate(index <span style="color: #666666">+</span> <span style="color: #666666">1</span>);
    });
}

<span style="color: #AA22FF; font-weight: bold">function</span> finish() {
    <span style="color: #008800; font-style: italic">//iteration completed</span>
}

iterate(<span style="color: #666666">0</span>);   <span style="color: #008800; font-style: italic">// start iterate sequence asynchronize</span>
</pre></div>


<p><strong>思考</strong></p>
<ul>
<li>使用异步遍历序列数据的方法，实现爬虫的另外一个版本：递归下载网页和网页里的所有链接。注意，只下载相同域名下的链接。</li>
<li>更一般化地抽你异步遍历模型，可以实现如下函数签名的异步遍历函数 <code>iterateSeries(collection, iteratorCallback, finalCallback)</code> 。</li>
</ul>
<h2 id="20160627">20160627</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="parallel-execution">Parallel execution</h3>
<p>如果多个任务没有先后顺序上的依赖，那么可以使用并行执行的模型来实现。当任务全部完成后，通过回调函数通知调用者。</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> tasks <span style="color: #666666">=</span> [...];
<span style="color: #AA22FF; font-weight: bold">var</span> completed <span style="color: #666666">=</span> <span style="color: #666666">0</span>;

tasks.forEach(<span style="color: #AA22FF; font-weight: bold">function</span>(task) {
    task(<span style="color: #AA22FF; font-weight: bold">function</span>() {
        <span style="color: #AA22FF; font-weight: bold">if</span>(<span style="color: #666666">++</span>completed <span style="color: #666666">===</span> tasks.length) {
            finish(); }
    });
});

<span style="color: #AA22FF; font-weight: bold">function</span> finish() {
    <span style="color: #008800; font-style: italic">//all the tasks completed</span>
}
</pre></div>


<h2 id="20160630">20160630</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="limiting-the-concurrency">Limiting the concurrency</h3>
<p>带上限的并发执行可以有效地控制资源消耗，避免资源过载。</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> tasks <span style="color: #666666">=</span> [...];
<span style="color: #AA22FF; font-weight: bold">var</span> concurrency <span style="color: #666666">=</span> <span style="color: #666666">2</span>, running <span style="color: #666666">=</span> <span style="color: #666666">0</span>, completed <span style="color: #666666">=</span> <span style="color: #666666">0</span>, index <span style="color: #666666">=</span> <span style="color: #666666">0</span>;

<span style="color: #AA22FF; font-weight: bold">function</span> next() {              <span style="color: #008800; font-style: italic">//[1]</span>
    <span style="color: #AA22FF; font-weight: bold">while</span>(running <span style="color: #666666">&lt;</span> concurrency <span style="color: #666666">&amp;&amp;</span> index <span style="color: #666666">&lt;</span> tasks.length) {
        task <span style="color: #666666">=</span> tasks[index<span style="color: #666666">++</span>];
        task(<span style="color: #AA22FF; font-weight: bold">function</span>() {            <span style="color: #008800; font-style: italic">//[2]</span>
            <span style="color: #AA22FF; font-weight: bold">if</span>(completed <span style="color: #666666">===</span> tasks.length) {
                <span style="color: #AA22FF; font-weight: bold">return</span> finish();
            }
            completed<span style="color: #666666">++</span>, running<span style="color: #666666">--</span>;
            next();
        });
        running<span style="color: #666666">++</span>;
    }
}

next();

<span style="color: #AA22FF; font-weight: bold">function</span> finish() {
    <span style="color: #008800; font-style: italic">//all tasks finished</span>
}
</pre></div>


<h3 id="globally-limiting-the-concurrency">Globally limiting the concurrency</h3>
<p>上面的模式无法实现全局限制，如果一个任务产生两个并发任务，多个任务就会产生多个并发任务。我们需要实现全局并发数量限制，可以用一个队列来实现。</p>
<p><a name="globally_limiting_the_concurrency"></a><strong>全局限制并发数量</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> TaskQueue (concurrency) {
    <span style="color: #AA22FF; font-weight: bold">this</span>.concurrency <span style="color: #666666">=</span> concurrency;
    <span style="color: #AA22FF; font-weight: bold">this</span>.running <span style="color: #666666">=</span> <span style="color: #666666">0</span>;
    <span style="color: #AA22FF; font-weight: bold">this</span>.queue <span style="color: #666666">=</span> [];
}

TaskQueue.prototype.pushTask <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span> (task, callback) {
    <span style="color: #AA22FF; font-weight: bold">this</span>.queue.push([task, callback]);
    <span style="color: #AA22FF; font-weight: bold">this</span>.nextTask();
};

TaskQueue.prototype.nextTask <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span> () {

    <span style="color: #AA22FF; font-weight: bold">function</span> makeCallback(self, task, callback) {
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF; font-weight: bold">function</span> (err) {
            callback(err, task);
            self.running <span style="color: #666666">--</span>;
            self.nextTask();
        }
    }

    <span style="color: #AA22FF; font-weight: bold">while</span> (<span style="color: #AA22FF; font-weight: bold">this</span>.running <span style="color: #666666">&lt;</span> <span style="color: #AA22FF; font-weight: bold">this</span>.concurrency <span style="color: #666666">&amp;&amp;</span> <span style="color: #AA22FF; font-weight: bold">this</span>.queue.length <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>) {
        <span style="color: #AA22FF; font-weight: bold">var</span> [task, callback] <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">this</span>.queue.shift();
        task(makeCallback(<span style="color: #AA22FF; font-weight: bold">this</span>, task, callback));
        <span style="color: #AA22FF; font-weight: bold">this</span>.running <span style="color: #666666">++</span>;
    }
};

module.exports <span style="color: #666666">=</span> TaskQueue;
</pre></div>


<p>具体 <code>TaskQueue</code> 代码可<a href="https://github.com/kamidox/exercism/tree/master/javascript/task-queue">参阅 GitHub 上的源码</a>。</p>
<h2 id="20160704">20160704</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="the-async-library">The async library</h3>
<p><a href="https://npmjs.org/package/async">async</a> 已经成为 JavaScriopt 异步流程控制的事实标准。它最初设计目标是运行在 Node.js 环境，目前也可以在浏览器环境执行。</p>
<p><strong>Sequential execution</strong></p>
<p>async 库有 20 多个函数用来执行串行任务。<a href="http://caolan.github.io/async/docs.html#.series"><code>series()</code></a> 函数确保异步函数顺序执行；<a href="http://caolan.github.io/async/docs.html#.waterfall"><code>waterfall()</code> </a> 在确保异步函数顺序执行的同时，还会以上一个函数的输出作为下一个函数的输入。</p>
<p><strong>Parallel execution</strong></p>
<p>async 库有大量的并行异步任务控制器。比如 <code>map()</code> 从一个列表逐个元素映射，生成一个新列表，在列表元素映射的过程中，是并行发生的，所以没有顺序保证。<code>parallel()</code> 只是单纯地确保任务并行执行。</p>
<p><strong>Limited parallel execution</strong></p>
<p>async 也可以限制并发个数的并行执行。典型地，<code>parallel()</code> 有个对应的 <code>parallelLimit()</code> 函数，作为并发个数限制的版本。<code>queue()</code> 作为任务队列，和书中介绍过的 <code>TaskQueue</code> 完成类似的功能。</p>
<h3 id="promises">Promises</h3>
<h4 id="what-is-a-promise">What is a promise?</h4>
<p>Promises 是一种抽像，它允许异步函数返回一个 Promises 对象，用这个对象来表达异步函数的最终结果。用 Promises 术语来讲，当异步函数未完成时，这个 Promises 对象处于 <strong>未决 (pending)</strong> 状态。当异步函数成功完成时，这个 Promises 对象处于 <strong>达成 (fulfilled)</strong> 状态。当异步任务发生错误时，这个 Promises 对象处于 <strong>驳回 (rejected)</strong> 状态。只要异步函数完成，不管是成功还是失败，我们称这个 Promises 对象为 <strong>确定 (settled)</strong> 状态，这个状态和未决状态相对应。</p>
<p>In very simple terms, promises are an abstraction that allow an asynchronous function to return an object called a promise, which represents the eventual result of the operation. In the promises jargon, we say that a promise is pending when the asynchronous operation is not yet complete, it&rsquo;s fulfilled when the operation successfully completes, and rejected when the operation terminates with an error. Once a promise is either fulfilled or rejected, it&rsquo;s considered settled.</p>
<p>Promises 对象有个重要的方法 <code>then()</code> 可以用来处理异步代码。</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">promise.then([onFulfilled], [onRejected])
</pre></div>


<p><code>onFulfilled</code> 是一个函数，用来处理达成状态的 Promises。<code>onRejected</code> 用来处理驳回状态的 Promises。</p>
<p>利用这一特性，可以把 CPS 回调转换为 Promises 异步处理方式：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">asyncOperation(arg, <span style="color: #AA22FF; font-weight: bold">function</span>(err, result) {
    <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
        <span style="color: #008800; font-style: italic">//handle error</span>
    }
    <span style="color: #008800; font-style: italic">//do stuff with result</span>
});

asyncOperation(arg)
    .then(<span style="color: #AA22FF; font-weight: bold">function</span>(result) {
        <span style="color: #008800; font-style: italic">//do stuff with result</span>
    }, <span style="color: #AA22FF; font-weight: bold">function</span>(err) {
        <span style="color: #008800; font-style: italic">//handle error</span>
    });
</pre></div>


<p>用 Promises 写的代码更简洁，结构化现强。但这不是 Promises 的主要功能。<strong>Promises 的神奇功能在于 <code>then</code> 函数本身返回一个 Promises 对象</strong>。 <code>then</code> 函数的函数 <code>onFullfilled</code> 和 <code>onRejected</code> 什么时候被调用？在异步函数处于 settled 状态时被调用。如果 <code>onFulfilled</code> 或 <code>onRejected</code> 函数返回一个对象 <code>x</code>，那么 <code>then</code> 函数返回的 Promises 对象具有以下特性：</p>
<ul>
<li>如果 <code>x</code> 是一个值，那么 <code>then</code> 返回的 Promises 对象处于<strong>达成</strong>状态，且其值为 <code>x</code></li>
<li>如果 <code>x</code> 是一个 Promises 对象，那么 <code>then</code> 返回的 Promises 对象将会<strong>达成</strong> <code>x</code> 所达成的状态</li>
<li>如果 <code>x</code> 是一个 Promises 对象，那么 <code>then</code> 返回的 Promises 对象将会<strong>驳回</strong> <code>x</code> 所最终驳回的状态</li>
</ul>
<p>这一特性的重要性在于我们可以写出链式的 Promises 表达式。如果我们不指定 <code>onFulfilled</code> 或 <code>onRejected</code> ，那么 Promises 对象会自动把确定的状态 (达成或驳回) 传递给下一个 Promises 对象。这样我们可以非常方便地把错误处理传递下去，直到最后一环的 <code>onRejected</code> 函数中处理即可。</p>
<p>使用这个编程模型，顺序执行的异步函数可以写得非常简洁：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">asyncOperation(arg)
    .then(<span style="color: #AA22FF; font-weight: bold">function</span>(result1) {
        <span style="color: #008800; font-style: italic">//returns another promise</span>
        <span style="color: #AA22FF; font-weight: bold">return</span> asyncOperation(arg2);
    })
    .then(<span style="color: #AA22FF; font-weight: bold">function</span>(result2) {
        <span style="color: #008800; font-style: italic">//returns a value</span>
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #BB4444">&#39;done&#39;</span>;
    })
    .then(<span style="color: #AA22FF; font-weight: bold">undefined</span>, <span style="color: #AA22FF; font-weight: bold">function</span>(err) {
        <span style="color: #008800; font-style: italic">//any error in the chain is caught here</span>
    });
</pre></div>


<p>关于链式 Promises 的工作流程，可以参阅下图：</p>
<p><img alt="Promises Chain" src="../../images/accumulate_promises_chain.png" /></p>
<p>另外一个特性是，Promises 对象的 <code>then</code> 函数总是确保 <code>onFulfilled</code> 和 <code>onRejected</code> 被异步调用。即使一个 Promises 对象是由一个同步函数返回的，也是如此。这样就确保了调用的一致性，避免出现<a href="#an_unpredictable_function">同步异步不可预测性的问题</a>。这种问题最典型的情况是，不知道函数的调用顺序。</p>
<h4 id="promisesa-implementations">Promises/A+ implementations</h4>
<p><a href="https://promisesaplus.com">Promises/A+</a> 是 ES6 Promises 采纳的实现标准。除此之外，还有一系列第三方库实现了 Promises/A+ 标准：</p>
<ul>
<li>Bluebird (https://npmjs.org/package/bluebird)</li>
<li>Q (https://npmjs.org/package/q)</li>
<li>RSVP (https://npmjs.org/package/rsvp)</li>
<li>Vow (https://npmjs.org/package/vow)</li>
<li>When.js (https://npmjs.org/package/when)</li>
<li>ES6 Promises</li>
</ul>
<p>这些库的区别在于在 Promises/A+ 标准之外的功能上。Promises/A+ 实际上只规范了 <code>then</code> 函数的行为以及 Promises 对象从 pending 状态到 settled 状态的过程。对其他功能并没有规定，比如怎么样创建一个 Promises 对象，即构造函数的函数签名是没有规定的。</p>
<p>关于 ES6 Promises 可以参阅 <a href="https://github.com/DrkSephy/es6-cheatsheet#promises">ES6-cheatsheet</a>。</p>
<h2 id="20160705">20160705</h2>
<h3 id="_3">选股辅助系统</h3>
<p>做一个产品，采集所有股票的历史数据，可以对选股进行辅助分析。用户输入一个股票后，给出买入或卖出的建议。以及股票适合长线还是短线的策略建议。</p>
<ul>
<li>股价全部历史走势图</li>
<li>股价在其历史股价的水平：当前价格与历史最高价的百分比</li>
<li>股价以月为周期的波动情况：波动幅度越大，投机价值越大</li>
<li>股价以年为周期的波动情况</li>
<li>每个季度净利润走势图</li>
<li>每个季度净利润排名走势图</li>
<li>每个季度营收数据走势图</li>
<li>每个季度营收数据排名走势图</li>
<li>每个季度每股收益走势图</li>
<li>每个季度每股收益排名走势图</li>
<li>每个季度每股营收走势图</li>
<li>每个季度每股营收排名走势图</li>
<li>历史分红配股情况：分列出每一年的分红配股情况</li>
<li>历史分红配股情况在所有股票中的排名：需要有个算法，算出每支股票分红配股分数</li>
<li>股价与 深证指数/上证指数 的吻合情况及其排名 （排名：需要算出每支股票与上证指数/深证指数的相关系数）</li>
</ul>
<h2 id="20160706">20160706</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="promises_1">Promises</h3>
<h4 id="promisifying-a-nodejs-style-function">Promisifying a Node.js style function</h4>
<p>Node.js 库里只有少数几个原生支持 Promises ，我们可以通过转换，把 Node.js 类型的 CPS 回调函数改装成 Promises 样式的函数。</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> Promise <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;bluebird&#39;</span>);

module.exports.promisify <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">function</span> (callbackBasedApi) {
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF; font-weight: bold">function</span> promisified() {
        <span style="color: #008800; font-style: italic">// copy array: copy arguments of function promisified()</span>
        <span style="color: #AA22FF; font-weight: bold">var</span> args <span style="color: #666666">=</span> [].slice.call(arguments);
        <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF; font-weight: bold">new</span> Promise(<span style="color: #AA22FF; font-weight: bold">function</span> (resolve, reject) {
            args.push(<span style="color: #AA22FF; font-weight: bold">function</span> (err, result) {
                <span style="color: #AA22FF; font-weight: bold">if</span> (err) {
                    <span style="color: #AA22FF; font-weight: bold">return</span> reject(err);
                }
                <span style="color: #AA22FF; font-weight: bold">if</span> (arguments.length <span style="color: #666666">&lt;=</span> <span style="color: #666666">2</span>) {
                    resolve(result);
                } <span style="color: #AA22FF; font-weight: bold">else</span> {
                    resolve([].slice.call(arguments, <span style="color: #666666">1</span>));
                }
            });
            callbackBasedApi.apply(<span style="color: #AA22FF; font-weight: bold">null</span>, args);
        });
    }
};
</pre></div>


<p>大多数 Promises 实现都提供了把传统的 CPS 回调的 API 转换为 Promises 样式的工具函数，比如 Q 的 <code>Q.denodeify()</code>, <code>Q.nbind()</code>，bluebird 的 <code>Promises.promisify()</code> 等。</p>
<h4 id="sequential-execution">Sequential execution</h4>
<p>Promises 对己知函数的顺序执行的模式代码如下：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> promisesFunc() {
    <span style="color: #AA22FF; font-weight: bold">return</span> func1(params1)
        .then(<span style="color: #666666">=&gt;</span> (result1) {
            <span style="color: #AA22FF; font-weight: bold">return</span> func2(result1[<span style="color: #666666">0</span>]);
        })
        .then(<span style="color: #666666">=&gt;</span> (result2) {
            <span style="color: #AA22FF; font-weight: bold">return</span> func3(result2);
        })
        .then(<span style="color: #666666">=&gt;</span> (result3)) {
            <span style="color: #AA22FF; font-weight: bold">return</span> func4(result3);
        };
}
</pre></div>


<p>对未知列表进行迭代顺序执行时，其模式代码如下：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> tasks <span style="color: #666666">=</span> [...];
<span style="color: #AA22FF; font-weight: bold">var</span> promise <span style="color: #666666">=</span> Promise.resolve();    <span style="color: #008800; font-style: italic">// create a empty Promise Object which resolved as &#39;undefined&#39;</span>
tasks.forEach(<span style="color: #AA22FF; font-weight: bold">function</span> (task) {     <span style="color: #008800; font-style: italic">// chain each task with Promises Object</span>
    promise <span style="color: #666666">=</span> promise.then(<span style="color: #AA22FF; font-weight: bold">function</span> () {
        <span style="color: #AA22FF; font-weight: bold">return</span> task();
    });
});
</pre></div>


<h4 id="parallel-execution_1">Parallel execution</h4>
<p>使用 Promises 也可轻松执行并行任务：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> spiderLinks(currentUrl, body, nesting) {
    <span style="color: #AA22FF; font-weight: bold">if</span> (nesting <span style="color: #666666">===</span> <span style="color: #666666">0</span>) {
        <span style="color: #AA22FF; font-weight: bold">return</span> Promise.resolve();
    }
    <span style="color: #AA22FF; font-weight: bold">var</span> links <span style="color: #666666">=</span> utilities.getPageLinks(currentUrl, body);
    <span style="color: #AA22FF; font-weight: bold">var</span> promises <span style="color: #666666">=</span> links.map(<span style="color: #AA22FF; font-weight: bold">function</span> (link) {
        <span style="color: #AA22FF; font-weight: bold">return</span> spider(link, nesting <span style="color: #666666">-</span> <span style="color: #666666">1</span>);
    });
    <span style="color: #AA22FF; font-weight: bold">return</span> Promise.all(promises);
}
</pre></div>


<h4 id="limited-parallel-execution">Limited parallel execution</h4>
<p>ES6 Promises 并没有提供原生的机制来实现并行任务的控制。一个办法是使用 Javascript 原生方法来实现并行执行数量限制，比如<a href="#globally_limiting_the_concurrency">使用 <code>TaskQueue</code> 来实现</a>。</p>
<h4 id="_4">示例代码</h4>
<p>关于使用 ES6 Promise 实现的网络爬虫己发布到 github 上。</p>
<ul>
<li><a href="https://github.com/kamidox/exercism/tree/master/javascript/spider">spider</a><br />
  使用串行 Promise 模型，递归下载一个网站下的所有资源，包括 html, css, javascript 等。</li>
<li><a href="https://github.com/kamidox/exercism/tree/master/javascript/spider-v2">spider v2</a><br />
  使用全局并发限制的 Promise 模型，递归下载一个网站下的所有资源，包括 html, css, javascript 等。</li>
</ul>
<h2 id="20160713">20160713</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="generator">Generator</h3>
<h4 id="basic">Basic</h4>
<p>生成器是 ES6 引入的一个新特性，和其他语言的生成器类似：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> <span style="color: #666666">*</span>infiniteNumbers() {
    <span style="color: #AA22FF; font-weight: bold">var</span> n <span style="color: #666666">=</span> <span style="color: #666666">1</span>;
    <span style="color: #AA22FF; font-weight: bold">while</span> (<span style="color: #AA22FF; font-weight: bold">true</span>) {
        <span style="color: #AA22FF; font-weight: bold">yield</span> n<span style="color: #666666">++</span>;
    }
}

<span style="color: #AA22FF; font-weight: bold">var</span> numbers <span style="color: #666666">=</span> infiniteNumbers(); <span style="color: #008800; font-style: italic">// returns an iterable object</span>

numbers.next(); <span style="color: #008800; font-style: italic">// { value: 1, done: false }</span>
numbers.next(); <span style="color: #008800; font-style: italic">// { value: 2, done: false }</span>
numbers.next(); <span style="color: #008800; font-style: italic">// { value: 3, done: false }</span>
</pre></div>


<h4 id="generator-as-iterator">Generator as iterator</h4>
<p>生成器可以作为替代器使用：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span><span style="color: #666666">*</span> iteratorGenerator(arr) {
    <span style="color: #AA22FF; font-weight: bold">for</span>(<span style="color: #AA22FF; font-weight: bold">var</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>; i <span style="color: #666666">&lt;</span> arr.length; i<span style="color: #666666">++</span>) {
        <span style="color: #AA22FF; font-weight: bold">yield</span> arr[i];
    };
}
<span style="color: #AA22FF; font-weight: bold">var</span> iterator <span style="color: #666666">=</span> iteratorGenerator([<span style="color: #BB4444">&#39;apple&#39;</span>, <span style="color: #BB4444">&#39;orange&#39;</span>, <span style="color: #BB4444">&#39;watermelon&#39;</span>]);
<span style="color: #AA22FF; font-weight: bold">var</span> currentItem <span style="color: #666666">=</span> iterator.next();
<span style="color: #AA22FF; font-weight: bold">while</span>(<span style="color: #666666">!</span>currentItem.done) {
    console.log(currentItem.value);
    currentItem <span style="color: #666666">=</span> iterator.next();
}
</pre></div>


<h4 id="passing-values-back-to-a-generator">Passing values back to a generator</h4>
<p>通过生成器的 <code>next()</code> 函数可以向生成器传递参数：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span><span style="color: #666666">*</span> twoWayGenerator() {
    <span style="color: #AA22FF; font-weight: bold">var</span> what <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">yield</span> <span style="color: #AA22FF; font-weight: bold">null</span>;
    console.log(<span style="color: #BB4444">&#39;Hello &#39;</span> <span style="color: #666666">+</span> what);
}
<span style="color: #AA22FF; font-weight: bold">var</span> twoWay <span style="color: #666666">=</span> twoWayGenerator();
twoWay.next();
twoWay.next(<span style="color: #BB4444">&#39;world&#39;</span>);
</pre></div>


<p>甚至可以向生成器传递一个异常：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> twoWay <span style="color: #666666">=</span> twoWayGenerator();
twoWay.next();
twoWay.<span style="color: #AA22FF; font-weight: bold">throw</span>(<span style="color: #AA22FF; font-weight: bold">new</span> <span style="color: #AA22FF">Error</span>());
</pre></div>


<p>这个代码会使生成器函数在 <code>yield</code> 返回的地方抛出异常。</p>
<h4 id="asynchronous-control-flow-with-generators">Asynchronous control flow with generators</h4>
<p>生成器可以用来作为异步流程控制工具。用来解决 callback hell 问题。</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> asyncFlow(generatorFunction) {

    <span style="color: #AA22FF; font-weight: bold">function</span> callback(err) {
        <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
            <span style="color: #AA22FF; font-weight: bold">return</span> generator.<span style="color: #AA22FF; font-weight: bold">throw</span>(err);
        }
        <span style="color: #AA22FF; font-weight: bold">var</span> results <span style="color: #666666">=</span> [].slice.call(arguments, <span style="color: #666666">1</span>);
        generator.next(results.length <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span> <span style="color: #666666">?</span> results <span style="color: #666666">:</span> results[<span style="color: #666666">0</span>]);
    };

    <span style="color: #AA22FF; font-weight: bold">var</span> generator <span style="color: #666666">=</span> generatorFunction(callback);
    generator.next();
}
</pre></div>


<p><code>asyncFlow()</code> 函数接受一个生成器函数作为参数。作为参数的生成器函数有个特点，即接受一个 <code>callback</code> 作为参数。有了 <code>asyncFlow()</code> 我们可以实现一个简单的文件复制的函数：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> fs <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;fs&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> path <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;path&#39;</span>);

asyncFlow(<span style="color: #AA22FF; font-weight: bold">function</span><span style="color: #666666">*</span> (callback) {
    <span style="color: #AA22FF; font-weight: bold">var</span> fileName <span style="color: #666666">=</span> path.basename(__filename);
    <span style="color: #AA22FF; font-weight: bold">var</span> myself <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">yield</span> fs.readFile(fileName, <span style="color: #BB4444">&#39;utf8&#39;</span>, callback);
    <span style="color: #AA22FF; font-weight: bold">yield</span> fs.writeFile(<span style="color: #BB4444">&#39;clone_of_&#39;</span> <span style="color: #666666">+</span> fileName, myself, callback);
    console.log(<span style="color: #BB4444">&#39;Clone created&#39;</span>);
});
</pre></div>


<p>这样，通过 <code>asyncFlow()</code> 函数把异步的流程变成类似<strong>同步</strong>函数的流程。注意到函数中的 <code>callback</code> 参数实在有点多余，可以进一步变形如下：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> readFileThunk(filename, options) {
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF; font-weight: bold">function</span>(callback) {
        fs.readFile(filename, options, callback);
    }
}

<span style="color: #AA22FF; font-weight: bold">function</span> writeFileThunk(filename, options) {
    <span style="color: #AA22FF; font-weight: bold">return</span> <span style="color: #AA22FF; font-weight: bold">function</span>(callback) {
        fs.writeFile(filename, options, callback);
    }
}

<span style="color: #AA22FF; font-weight: bold">function</span> asyncFlowWithThunks(generatorFunction) {
    <span style="color: #AA22FF; font-weight: bold">function</span> callback(err) {
        <span style="color: #AA22FF; font-weight: bold">if</span>(err) {
            <span style="color: #AA22FF; font-weight: bold">return</span> generator.<span style="color: #AA22FF; font-weight: bold">throw</span>(err);
        }
        <span style="color: #AA22FF; font-weight: bold">var</span> results <span style="color: #666666">=</span> [].slice.call(arguments, <span style="color: #666666">1</span>);
        <span style="color: #AA22FF; font-weight: bold">var</span> thunk <span style="color: #666666">=</span> generator.next(results.length <span style="color: #666666">&gt;</span> <span style="color: #666666">1</span> <span style="color: #666666">?</span> results <span style="color: #666666">:</span> results[<span style="color: #666666">0</span>]).value;
        thunk <span style="color: #666666">&amp;&amp;</span> thunk(callback);   <span style="color: #008800; font-style: italic">// 注意：这里的 thunk 是生成器的返回值，它是一个函数</span>
    };

    <span style="color: #AA22FF; font-weight: bold">var</span> generator <span style="color: #666666">=</span> generatorFunction();
    <span style="color: #AA22FF; font-weight: bold">var</span> thunk <span style="color: #666666">=</span> generator.next().value;
    thunk <span style="color: #666666">&amp;&amp;</span> thunk(callback);   <span style="color: #008800; font-style: italic">// 注意：这里的 thunk 是生成器的返回值，它是一个函数</span>
}
</pre></div>


<p>经过变形以后，我们使用 Generator 来实现异步流程控制的时候，就不需要看到 <code>callback</code> 函数了，显得更简洁：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">asyncFlowWithThunks(<span style="color: #AA22FF; font-weight: bold">function</span><span style="color: #666666">*</span> () {
    <span style="color: #AA22FF; font-weight: bold">var</span> myself <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">yield</span> readFileThunk(__filename, <span style="color: #BB4444">&#39;utf8&#39;</span>);
    <span style="color: #AA22FF; font-weight: bold">yield</span> writeFileThunk(<span style="color: #BB4444">&quot;clone of clone.js&quot;</span>, myself);
    console.log(<span style="color: #BB4444">&quot;Clone created&quot;</span>);
});
</pre></div>


<p>关于如何使用 Generator 进行异步流程控制，可参阅 Github 上的 <a href="https://github.com/kamidox/exercism/tree/master/javascript/async-flow">async-flow</a> 示例代码。</p>
<h4 id="generator-based-control-flow-using-co">Generator-based control flow using co</h4>
<p>一些第三方库利用上面介绍的 <code>asyncFlow()</code> 的原理实现了异步控制，其中最早的是 <a href="https://npmjs.org/package/suspend"><code>suspend</code></a>，另外一个是 <a href="https://npmjs.org/package/co"><code>co</code></a>。<code>co</code> 有自己的生态系统：</p>
<ul>
<li>Web frameworks, the most popular being <a href="https://npmjs.org/package/koa">koa</a></li>
<li>Libraries implementing specific control flow patterns</li>
<li>Libraries wrapping popular APIs to support co</li>
</ul>
<p>另外一个值得介绍的是 <a href="https://npmjs.org/package/thunkify"><code>thunkify</code></a>，用来对传统的 CPS 回调函数进行变形处理。</p>
<h4 id="sequential-execution_1">Sequential execution</h4>
<p>利用上面介绍的内容，使用 Generator 重新实现网络爬虫的串行版本。</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> thunkify <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;thunkify&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> co <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;co&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> request <span style="color: #666666">=</span> thunkify(require(<span style="color: #BB4444">&#39;request&#39;</span>));
<span style="color: #AA22FF; font-weight: bold">var</span> fs <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;fs&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> mkdirp <span style="color: #666666">=</span> thunkify(require(<span style="color: #BB4444">&#39;mkdirp&#39;</span>));
<span style="color: #AA22FF; font-weight: bold">var</span> readFile <span style="color: #666666">=</span> thunkify(fs.readFile);
<span style="color: #AA22FF; font-weight: bold">var</span> writeFile <span style="color: #666666">=</span> thunkify(fs.writeFile);
<span style="color: #AA22FF; font-weight: bold">var</span> nextTick <span style="color: #666666">=</span> thunkify(process.nextTick);
</pre></div>


<p>经过 thunkify 后，使用生成器函数版本的资源下载函数 <code>download</code> 变成跟同步函数一样简洁，线性写下来即可：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span><span style="color: #666666">*</span> download(url, filename) {
    console.log(<span style="color: #BB4444">&#39;Downloading &#39;</span> <span style="color: #666666">+</span> url);
    <span style="color: #AA22FF; font-weight: bold">var</span> results <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">yield</span> request(url);
    <span style="color: #AA22FF; font-weight: bold">var</span> body <span style="color: #666666">=</span> results[<span style="color: #666666">1</span>];
    <span style="color: #AA22FF; font-weight: bold">yield</span> mkdirp(path.dirname(filename));
    <span style="color: #AA22FF; font-weight: bold">yield</span> writeFile(filename, body);
    console.log(<span style="color: #BB4444">&#39;Downloaded and saved:&#39;</span> <span style="color: #666666">+</span> url);
    <span style="color: #AA22FF; font-weight: bold">return</span> body;
}
</pre></div>


<p>使用相同的方法可以写出 <code>spider()</code> 和 <code>spiderLinks()</code> 函数，最后使用 <code>co</code> 来调用生成器函数：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">co(<span style="color: #AA22FF; font-weight: bold">function</span><span style="color: #666666">*</span> () {
    <span style="color: #AA22FF; font-weight: bold">try</span> {
        <span style="color: #AA22FF; font-weight: bold">yield</span> spider(process.argv[<span style="color: #666666">2</span>], <span style="color: #666666">1</span>);
        console.log(<span style="color: #BB4444">&#39;Download complete&#39;</span>);
    } <span style="color: #AA22FF; font-weight: bold">catch</span>(err) {
        console.log(err);
    };
})();
</pre></div>


<h4 id="parallel-execution_2">Parallel execution</h4>
<p>使用 Generator 并不有直接实现并行执行。但第三方库 <code>co</code> 提供了针对数组进行并发执行的功能。如下示例代码：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%">co(<span style="color: #AA22FF; font-weight: bold">function</span><span style="color: #666666">*</span> () {
    <span style="color: #AA22FF; font-weight: bold">var</span> res <span style="color: #666666">=</span> <span style="color: #AA22FF; font-weight: bold">yield</span> [
        Promise.resolve(<span style="color: #666666">1</span>),
        Promise.resolve(<span style="color: #666666">2</span>),
        Promise.resolve(<span style="color: #666666">3</span>),
    ];
    console.log(res); <span style="color: #008800; font-style: italic">// =&gt; [1, 2, 3]</span>
}).<span style="color: #AA22FF; font-weight: bold">catch</span>(onerror);
</pre></div>


<p><code>co</code> 的参数是个生成器函数，生成器函数 <code>yield</code> 了一个数组。数组里包含了一系列的任务，这些任务将会<strong>并发</strong>执行，直到所有任务都完成后，<code>yield</code> 才会返回。所以上面的示例代码将输出 <code>[1, 2, 3]</code> 。</p>
<h2 id="20160715">20160715</h2>
<p>Node.js Design Patterns: Chapeter 2 Asynchronous Control Flow Patterns</p>
<h3 id="generator_1">Generator</h3>
<h4 id="producer-consumer-pattern">Producer-consumer pattern</h4>
<p>如果要使用 Generator 实现并发数据控制，我们有一些思路：</p>
<ul>
<li>使用我们之前实现的基于回调的 <code>TaskQueue</code> 来实现并发数量控制。要使用这一机制，我们需要把 Generator 函数和其他函数通过 thunkify 进行变形。</li>
<li>使用我们之前实现的基于 Promise 的 <code>TaskQueue</code> 版本来进行并发数量控制。要使用这一机制，我们需要把 Generator 函数转换为 Promise 对象即可。</li>
<li>使用 <code>async</code> 进行并发数量控制。我们需要把 Generator 函数转换为普通的基于回调的函数。</li>
<li>使用 <code>co</code> 生态库 <a href="https://npmjs.org/package/co-limiter">co-limiter</a> 进行并发数量控制。</li>
<li>实现生产者/消费者模型，用它来进行并发数量控制。这实际上也是 <code>co-limiter</code> 库的原理。</li>
</ul>
<h3 id="_5">比较总结</h3>
<p>几种异步流程控制的优缺点对比如下：</p>
<p><img alt="Comparation" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/js_async_flow.png" /></p>
<h2 id="20160716">20160716</h2>
<h3 id="_6">以练习为核心的编程学习打卡社区</h3>
<h4 id="_7">核心业务流程</h4>
<ul>
<li>学生登录网站，查找需要练习的编程课程</li>
<li>进入课程后，逐个练习完成作业，每个练习配有思路讲解以及用到的关键技术介绍</li>
<li>上传作业发起打卡流程</li>
<li>系统运行测试例检查作业完成情况，如果失败学生可以选择重试或者参考标准答案，如果成功则记录打卡行为</li>
<li>学习完某个课程后，获得相关课程的徽章或证书，徽章和证书可分享到社交媒体</li>
</ul>
<h4 id="_8">内容运营开发</h4>
<ul>
<li>以 <a href="http://exercism.io">exercism.io</a> 为蓝本，摘抄合理的练习</li>
<li>以领域内优质图书为蓝本，提取关键技术，开发想着练习</li>
</ul>
<h4 id="_9">课程示例</h4>
<ul>
<li>JavaScript 快速入门<ul>
<li>课程目标：熟悉 JavaScript 语法；熟悉 JavaScript 标准库；使用 JavaScript 解决简单问题</li>
<li>目标用户：有其他语言背影，想要学习 JavaScript 编程的程序员</li>
<li>课程内容：以 exercism.io 为蓝本进行习题设计</li>
</ul>
</li>
<li>Node.js 设计模式<ul>
<li>课程目标：JavaScript 进阶；熟悉 Node.js 及其生态库的核心设计模式</li>
<li>目标用户：熟悉 JavaScript 基础知识，想进一步深入 JavaScript 设计模式的程序员</li>
<li>课程内容：以 Node.js Design Patterns 为蓝本，设计不同版本的爬虫程序来进行练习</li>
</ul>
</li>
<li>轻松掌握 ES6：逐个知识点，配合适量的练习，掌握 ES6 新特性</li>
</ul>
<h4 id="_10">运营模式</h4>
<p>前期开发一些课程，在微信公众号，掘金，简书等平台推广。后期设计充值打卡的赢利模式。如十节课，需要充值 100 元，完成一节课返还 10 元。超过期限没有完成课程的同学，没收课程充值费用。后期可设计，放弃某个练习，返还一半练习费用；参考标准答案扣除全部的练习费用。</p>
<h2 id="20160720">20160720</h2>
<p>Node.js Design Patterns: Chapeter 3 Coding With Stream</p>
<h3 id="discovering-the-importance-of-streams">Discovering the importance of streams</h3>
<p>大部分的异步 IO API 使用 Buffering 模式，即数据缓存起来，然后一次性返回。比如 <code>fs.readFile()</code> 即工作在缓存模式下。而 Streaming 模式允许数据一到就直接被处理。流模式有以下两个优点：</p>
<ul>
<li>空间效率高：当处理大文件（比如超过 1 GB）时，缓存模式可能会耗尽内存而出错。而流模式则没问题。具体可参阅<a href="#spatial_efficiency">空间效率</a>。</li>
<li>时间效率高：缓存模式需要把数据全部缓存完了，才通过回调函数返回给调用者。而流模式只要有数据到达，就直接返回给调用者。具体可参阅<a href="#time_efficiency">时间效率</a>。</li>
<li>可组合性：这个是流模式最显著的优点。可以通过 <code>pipe()</code> 函数把几个流处理程序组合起来。比如，如果需要在传输过程中加密，只需要在客户端加上代码 <code>.pipe(crypto.createCipher('aes192', 'a_shared_secret'))</code>，然后在服务端加上代码 <code>.pipe(crypto.createDecipher('aes192', 'a_shared_secret'))</code> 。这样就加上了加密功能。</li>
</ul>
<p><a name="spatial_efficiency"></a><strong>空间效率: 使用 GZip 算法压缩文件</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">var</span> fs <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;fs&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> zlib <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;zlib&#39;</span>);

<span style="color: #008800; font-style: italic">// 压缩大于 1 GB 的文件时，会报错</span>
<span style="color: #AA22FF; font-weight: bold">function</span> gzipBuffered(filename) {
    <span style="color: #AA22FF; font-weight: bold">var</span> start <span style="color: #666666">=</span> <span style="color: #AA22FF">Date</span>.now();
    fs.readFile(filename, (err, data) <span style="color: #666666">=&gt;</span> {
        zlib.gzip(data, (err, data) <span style="color: #666666">=&gt;</span> {
            fs.writeFile(filename <span style="color: #666666">+</span> <span style="color: #BB4444">&#39;.b.gz&#39;</span>, data, () <span style="color: #666666">=&gt;</span> {
                console.log(<span style="border: 1px solid #FF0000">`</span>${filename} successful compressed. Elapsed ${<span style="color: #AA22FF">Date</span>.now() <span style="color: #666666">-</span> start} ms.<span style="border: 1px solid #FF0000">`</span>);
            })
        })
    })
}

<span style="color: #008800; font-style: italic">// 对超大文件工作良好</span>
<span style="color: #AA22FF; font-weight: bold">function</span> gzipStreamed(filename) {
    <span style="color: #AA22FF; font-weight: bold">var</span> start <span style="color: #666666">=</span> <span style="color: #AA22FF">Date</span>.now();
    fs.createReadStream(filename)
        .pipe(zlib.createGzip())
        .pipe(fs.createWriteStream(filename <span style="color: #666666">+</span> <span style="color: #BB4444">&#39;.s.gz&#39;</span>))
        .on(<span style="color: #BB4444">&#39;finish&#39;</span>, () <span style="color: #666666">=&gt;</span> {
            console.log(<span style="border: 1px solid #FF0000">`</span>${filename} successful compressed. Elapsed ${<span style="color: #AA22FF">Date</span>.now() <span style="color: #666666">-</span> start} ms.<span style="border: 1px solid #FF0000">`</span>)
        })
}
</pre></div>


<p><a name="time_efficiency"></a><strong>时间效率: 上传经过 gzip 压缩的文件</strong></p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008800; font-style: italic">// 服务器端代码 gzip-stream-server.js</span>
<span style="color: #AA22FF; font-weight: bold">var</span> http <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;http&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> fs <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;fs&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> zlib <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;zlib&#39;</span>);

<span style="color: #AA22FF; font-weight: bold">var</span> server <span style="color: #666666">=</span> http.createServer((req, res) <span style="color: #666666">=&gt;</span> {
    <span style="color: #AA22FF; font-weight: bold">var</span> filename <span style="color: #666666">=</span> req.headers.filename;
    console.log(<span style="border: 1px solid #FF0000">`</span>receiving ${filename} ...<span style="border: 1px solid #FF0000">`</span>);
    <span style="color: #AA22FF; font-weight: bold">var</span> start <span style="color: #666666">=</span> <span style="color: #AA22FF">Date</span>.now();
    req.pipe(zlib.createGunzip())
        .pipe(fs.createWriteStream(filename <span style="color: #666666">+</span> <span style="color: #BB4444">&#39;.received&#39;</span>))
        .on(<span style="color: #BB4444">&#39;finish&#39;</span>, () <span style="color: #666666">=&gt;</span> {
            res.writeHead(<span style="color: #666666">201</span>, {<span style="color: #BB4444">&#39;Content-Type&#39;</span><span style="color: #666666">:</span> <span style="color: #BB4444">&#39;text/plain&#39;</span>});
            res.end(<span style="color: #BB4444">&#39;File uploading successful.&#39;</span>);
            console.log(<span style="border: 1px solid #FF0000">`</span>received ${filename} <span style="color: #666666">-</span> elapsed ${<span style="color: #AA22FF">Date</span>.now() <span style="color: #666666">-</span> start} ms<span style="border: 1px solid #FF0000">`</span>)
        });
});

server.listen(<span style="color: #666666">3000</span>, () <span style="color: #666666">=&gt;</span> {
    console.log(<span style="color: #BB4444">&#39;Listening on 3000 ...&#39;</span>);
});

<span style="color: #008800; font-style: italic">// 客户端代码 gzip-stream-client.js</span>
<span style="color: #AA22FF; font-weight: bold">var</span> fs <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;fs&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> zlib <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;zlib&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> http <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;http&#39;</span>);
<span style="color: #AA22FF; font-weight: bold">var</span> path <span style="color: #666666">=</span> require(<span style="color: #BB4444">&#39;path&#39;</span>);

<span style="color: #AA22FF; font-weight: bold">var</span> file <span style="color: #666666">=</span> process.argv[<span style="color: #666666">2</span>];
file <span style="color: #666666">=</span> file <span style="color: #666666">||</span> <span style="color: #BB4444">&#39;./gzip-stream-client.js&#39;</span>;
<span style="color: #AA22FF; font-weight: bold">var</span> server <span style="color: #666666">=</span> <span style="color: #BB4444">&#39;localhost&#39;</span>;
<span style="color: #AA22FF; font-weight: bold">var</span> port <span style="color: #666666">=</span> <span style="color: #666666">3000</span>;

<span style="color: #AA22FF; font-weight: bold">var</span> options <span style="color: #666666">=</span> {
    hostname<span style="color: #666666">:</span> server,
    port<span style="color: #666666">:</span> port,
    method<span style="color: #666666">:</span> <span style="color: #BB4444">&#39;PUT&#39;</span>,
    headers<span style="color: #666666">:</span> {
        filename<span style="color: #666666">:</span> path.basename(file),
        <span style="color: #BB4444">&#39;Content-Type&#39;</span><span style="color: #666666">:</span> <span style="color: #BB4444">&#39;application/octet-stream&#39;</span>,
        <span style="color: #BB4444">&#39;Content-Encoding&#39;</span><span style="color: #666666">:</span> <span style="color: #BB4444">&#39;gzip&#39;</span>
    }
};

<span style="color: #AA22FF; font-weight: bold">var</span> req <span style="color: #666666">=</span> http.request(options, (res) <span style="color: #666666">=&gt;</span> {
    console.log(<span style="border: 1px solid #FF0000">`</span>Server response<span style="color: #666666">:</span> ${res.statusCode}<span style="border: 1px solid #FF0000">`</span>);
});

<span style="color: #AA22FF; font-weight: bold">var</span> start <span style="color: #666666">=</span> <span style="color: #AA22FF">Date</span>.now();
fs.createReadStream(file)
    .pipe(zlib.createGzip())
    .pipe(req)
    .on(<span style="color: #BB4444">&#39;finish&#39;</span>, () <span style="color: #666666">=&gt;</span> {
        console.log(<span style="border: 1px solid #FF0000">`</span>${file} successful uploaded.  <span style="color: #666666">-</span> elapsed ${<span style="color: #AA22FF">Date</span>.now() <span style="color: #666666">-</span> start} ms<span style="border: 1px solid #FF0000">`</span>)
    });
</pre></div>


<h2 id="20160821">20160821</h2>
<p><a href="https://github.com/google/blockly-games">blockly-games</a> - Games for tomorrow&rsquo;s programmers.</p>
<h3 id="blockly-games-bootjs">Blockly-Games - boot.js</h3>
<p>Blockly-Games 应用程序的 BootLoader，负载载入指定的应用程序。</p>
<ol>
<li>根据 <code>location.pathname</code> 解析出应用的名称和语言</li>
<li>把语言记录在 <code>window</code> 全局变量里</li>
<li>根据解析出来的名称和语言，创建一个 <code>script</code> 标签，把应用对应的脚本 <code>compressed.js</code> 或 <code>uncompressed.js</code> 插入到页面里</li>
</ol>
<h3 id="blockly-games-deps">Blockly-Games - deps</h3>
<p>构建 Blockly-Games 用到的工具和库。</p>
<ul>
<li><a href="https://github.com/google/closure-library">closure-library</a>: Google&rsquo;s common JavaScript library<br />
  Closure Library is a powerful, low-level JavaScript library designed for building complex and scalable web applications. It is used by many Google web applications, such as Google Search, Gmail, Google Docs, Google+, Google Maps, and others.</li>
<li><a href="https://github.com/google/closure-templates">closure-templates</a>: A client- and server-side templating system that helps you dynamically build reusable HTML and UI elements<br />
<a href="https://developers.google.com/closure/templates/docs/helloworld_js">helloword_js</a> is a example to getting started.</li>
<li><a href="https://github.com/google/closure-compiler">closure-compiler</a>: A JavaScript checker and optimizer.<br />
  The Closure Compiler is a tool for making JavaScript download and run faster. It is a true compiler for JavaScript. Instead of compiling from a source language to machine code, it compiles from JavaScript to better JavaScript. It parses your JavaScript, analyzes it, removes dead code and rewrites and minimizes what&rsquo;s left. It also checks syntax, variable references, and types, and warns about common JavaScript pitfalls.</li>
<li><a href="https://github.com/google/closure-library/blob/master/closure/bin/build/closurebuilder.py">closurebuilder.py</a>: Utility for Closure Library dependency calculation.<br />
  ClosureBuilder scans source files to build dependency info.  From the dependencies, the script can produce a manifest in dependency order, a concatenated script, or compiled output from the Closure Compiler.</li>
</ul>
<h3 id="blockly-games-build">Blockly-Games - build</h3>
<p>Blockly-Games 应用程序编译流程。</p>
<ol>
<li>使用 <code>closure-templates</code> 格式编写后缀为 <code>.soy</code> 的源代码。并把它编译成 JavaScript 文件 <code>soy.js</code>。</li>
<li>最后通过 <code>closurebuilder.py</code> 工具，把所有依赖的文件打包，生成 <code>compressed.js</code> 和 <code>uncompressed.js</code>。</li>
<li>Apps 的 <code>index.html</code> 通过 <code>boot.js</code> 载入应用对应的 <code>compressed.js</code> 或 <code>uncompressed.js</code>。</li>
</ol>
<p>这样就构建出了一个完整的应用。其中 <code>uncompressed.js</code> 代码是关键：</p>
<div class="codehilite" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF; font-weight: bold">function</span> loadScript() {
    <span style="color: #AA22FF; font-weight: bold">var</span> src <span style="color: #666666">=</span> srcs.shift();
    <span style="color: #AA22FF; font-weight: bold">if</span> (src) {
      <span style="color: #AA22FF; font-weight: bold">var</span> script <span style="color: #666666">=</span> <span style="color: #AA22FF">document</span>.createElement(<span style="color: #BB4444">&#39;script&#39;</span>);
      script.src <span style="color: #666666">=</span> src;
      script.type <span style="color: #666666">=</span> <span style="color: #BB4444">&#39;text/javascript&#39;</span>;
      <span style="color: #008800; font-style: italic">// 下面的代码是关键：第一个脚本载入完成后会载入第二个脚本，直到所有 JavaScript 全部载入为止</span>
      script.onload <span style="color: #666666">=</span> loadScript;
      <span style="color: #AA22FF">document</span>.head.appendChild(script);
    }
  }
  loadScript();
</pre></div>


<h2 id="20160822">20160822</h2>
<p><a name="google-closure-templates"></a></p>
<h3 id="google-closure-templates">Google Closure Templates</h3>
<p>Closure Templates are a client- and server-side templating system that helps you dynamically build reusable HTML and UI elements.</p>
<ul>
<li>传统的模板 (如 jinja2 etc.) 需要为每个页面制作一个巨大的模板文件。而 Closure Templates 的思想则是定义 UI 组件，这些 UI 组件可以在不同的页面里重用。<em>注：这一点有点牵强，很多模板框架支持 include 机制引用页面片段。</em></li>
<li>原生的多语言支持。</li>
<li>可以把 Closure Templates 编译成 JavaScript 或 Java 语言，这样可以在客户端和服务器重用代码。</li>
</ul>
<p><em>在客户端生成页面的技术就叫 Client Rendering, 在服务器生成页面的技术就叫 Server Rendering.</em></p>
<p>What are the benefits of using Closure Templates?</p>
<ul>
<li>Convenience. Closure Templates provide an easy way to build pieces of HTML for your application&rsquo;s UI and help you separate application logic from display.</li>
<li>Language-neutral. Closure Templates work with JavaScript or Java. You can write one template and share it between your client- and server-side code.</li>
<li>Client-side speed. Closure Templates are compiled to efficient JavaScript functions for maximum client-side performance.</li>
<li>Easy to read. You can clearly see the structure of the output HTML from the structure of the template code. Messages for translation are inline for extra readability.</li>
<li>Designed for programmers. Templates are simply functions that can call each other. The syntax includes constructs familiar to programmers. You can put multiple templates in one source file.</li>
<li>A tool, not a framework. Works well in any web application environment in conjunction with any libraries, frameworks, or other tools.</li>
<li>Battle-tested. Closure Templates are used extensively in some of the largest web applications in the world, including Gmail and Google Docs.</li>
<li>Secure. Closure Templates are contextually autoescaped to reduce the risk of XSS.</li>
</ul>
<h3 id="closure-templates-helloworld">Closure Templates HelloWorld</h3>
<p><a href="https://developers.google.com/closure/templates/docs/helloworld_js">Hello World Using JavaScript</a> 是个快速了解 Closure Templates 的入门示例。几个关键步骤：</p>
<ol>
<li>下载 <a href="https://dl.google.com/closure-templates/closure-templates-for-javascript-latest.zip">Closure Templates JavaScript Compiler</a><br />
  使用这个工具把 Closure Templates 源文件 <code>.soy</code> 编译成 JavaScript 源码</li>
<li>按照 Closure Templates 规范编写 <code>.soy</code> 文件。目的是定义一系列可重用的 UI 组件。这些 UI 组件可以包含基本的程序化定制的内容，如参数，条件判断，循环等等。还可以使用 Closure Templates 的 <code>call</code> 命令调用其他 <code>.soy</code> 文件里定义的 UI 组件。</li>
<li>使用 Closure Templates JavaScript Compiler 把 <code>.soy</code> 文件编译生成 JavaScript 文件。每个 template 会被编译成一个同名的 JavaScript 函数。</li>
<li>创建 html 文件，通过 <code>&lt;script&gt;</code> 标签引用生成的 JavaScript 文件。并且在 html 文件里通过 JavaScript 调用之前定义在 <code>.soy</code> 文件里的 UI 组件。再通过 <code>document.write</code> 函数把 UI 组件的内容写到 html dom 树里。</li>
</ol>
<p>本质上，Closure Templates 还是使用 JavaScript 输出 html 界面元素，再通过 <code>document.write</code> 输出到 html dynamic dom 里。那为什么要发明一个 Closure Templates，绕一大圈来做这个事情呢？</p>
<p>画外音响起，是一个中年男子磁性又略带沧桑的声音：我们到达一个个目的地，却忘记了为什么出发。是时候停下脚步 &hellip;</p>
<p>其实，<a href="#google-closure-templates">Closure Templates 的设计目标及特点</a> 就是目的。</p>
<h2 id="20160823">20160823</h2>
<h3 id="blockly-games-multi-languages">Blockly-Games - Multi-languages</h3>
<p>Blockly-Games 多语言使用 Google Closure Templates 来实现的，其<a href="https://developers.google.com/closure/templates/docs/translation">官方文档</a>有详细的步骤说明。</p>
<p>多语言的编译步骤如下：</p>
<ol>
<li>在 <code>.soy</code> 文件里，把所有需要翻译的文本用 <code>msg</code> 命令标记</li>
<li>下载 <a href="https://dl.google.com/closure-templates/closure-templates-msg-extractor-latest.zip">closure-templates-msg-extractor-latest.zip</a></li>
<li>运行 <code>SoyMsgExtractor.jar</code> 用来从 <code>.soy</code> 文件里提取出所有待翻译的文本，并生成 XLIFF 格式</li>
<li>运行 <code>i18n/xliff_to_json.py</code> 把 XLIFF 文件转成 json 文件，放在 <code>json</code> 目录下</li>
<li>运行 <code>i18n/json_to_js.py</code> 把 <code>.soy</code> 文件编译成对应语言的 <code>soy.js</code> 源文件</li>
<li>运行 <code>python build-app.py</code> 生成每种语言 <code>compressed.js</code> 和 <code>uncompressed.js</code> 文件</li>
</ol>
<h3 id="blockly-games-closure-templates">Blockly-Games - closure-templates</h3>
<p><code>.soy</code> 文件规范。</p>
<h3 id="blockly-games-mvc">Blockly-Games - MVC</h3>
<p>Blockly-Games 的 MVC 架构。</p>
<h2 id="20160826">20160826</h2>
<h3 id="_11">欺诈交易异常检测</h3>
<p>核心思路：从数据集里，找出大部分帐户的行为模式，以此建立模型。如果一个帐户的行为模式与此模型偏差较远，则可定义为异常。<br />
欺诈交易：并非所有的异常帐户都有欺诈交易，但我们可以通过人工参与的方式从异常帐户里人为发现一些线索，从而优化特征选择，从而不断地优化模型。</p>
<p>经过不断优化后的模型，检测出来的异常帐户中，大部分都是欺诈交易。则这个模型就是个成功的模型。</p>
<p><strong>行为模式</strong></p>
<ul>
<li>被欺诈的帐户是否有这样的特点：欺诈发生时的一段时间内（比如一周）的资金转出量会不会比平常大很多？<br />
  如果有这样的特征，则可使用<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.24.5743&amp;rep=rep1&amp;type=pdf">PGA 算法</a>来检查出这些帐户。</li>
<li>实施欺诈的帐户资金动向有哪些特点？比如多次均衡地有资金转入，但一次性有大比资金转出？<br />
  如果有这样的特征，也可以使用 PGA 算法检测出来。</li>
<li>检测出可能被欺诈的帐户后，再看看可能实施了欺诈的帐户列表。看看他们之间有没有资金往来，如果有，这两个帐户存在欺诈的可能性就更大了。</li>
</ul>
<h3 id="_12">实施步骤</h3>
<ol>
<li>清洗数据<br />
   把不活跃帐户信息过滤掉，以免模型过多地关注这些不活跃的帐户的行为模式。怎么样定义不活跃帐户？</li>
<li>提取特征<br />
   根据行为模式的分析，提取特征</li>
<li>建立模型<br />
   建立模型，并拿测试数据来训练算法</li>
<li>检测算法<br />
   拿算法来找出异常的帐户，人工确认其是否存在欺诈，如果不存在欺诈，则优化特征。以此不断迭代，直到找出合理的模型。</li>
</ol>
<h3 id="_13">高斯分布异常检测模型</h3>
<p>使用高斯分布进行检测，这一算法简单方便，可以较快地得出异常帐户列表。但这些异常帐户是否存在欺诈交易需要人工鉴别，并且根据鉴别的结果，进一步优化特征。这一算法的其他挑战有：</p>
<ol>
<li>所有的特征需要逐一检查，让其<strong>独立地满足正态分布</strong>，否则不能适用这个算法。</li>
<li>训练数据是一个超级大矩阵，因为我们需要把用户的一段时间内所有行为数据都提取为特征，并且和所有的用户组成一个超级大矩阵。这样在非分布式计算的环境下，要训练这样的模型可能性基本为零。不过可以拿小部分数据试运行，检测模型的合理程度。如果可行，再想办法解决运算量的问题。</li>
</ol>
<h3 id="_14">欺诈交易异常检测</h3>
<ol>
<li>根据 PGA 算法检测可能被欺诈的帐户</li>
<li>根据 PGA 算法检测可能实施欺诈的帐户</li>
<li>检查被欺诈帐户和实施欺诈帐户之间的资金关联关系，如果存在强关联关系，则这组欺诈可能将变得很高</li>
</ol>
<h2 id="20160907">20160907</h2>
<h3 id="_15">三步塑造你的职场气场</h3>
<ol>
<li>引出问题：职场气场是客观存在的<br />
   有的人动不动被老板骂，连提出的合理要求都被驳回。有的人老板安排任务时说话很客气，更会替他考虑任务的资源是否充足。</li>
<li>多听<br />
   * 学会问问题，收集尽量多信息<br />
   * 多思考，理解老板的真实意图<br />
   * 换位思考，站在老板的角度思考问题</li>
<li>少说<br />
   * 不轻易摆困难，绝不抱怨<br />
   * 说出信息，而不是噪声<br />
   * 说出有价值的观点和分析，提升影响力<br />
   * 状态汇报，预警风险，汇报结果</li>
<li>多做<br />
   * 言必信，行必果。这是塑造可信赖形象的不二法宝。<br />
   * 结果导向</li>
</ol>
<h2 id="20160911">20160911</h2>
<h3 id="beyond-feelings-preface">Beyond Feelings - Preface</h3>
<p>Why we need a critical thinking?</p>
<blockquote>
<p>First, because we live in an age of manipulation. Armies of hucksters and demagogues stand ready with the rich resources of psychology to play upon our emotions and subconscious needs to persuade us that superficial is profound, harmful is beneficial, evil is virtuous. And feelings are especially vulnerable to such manipulation.</p>
<p>Secondly, because in virtually every important area of modern life — law, medicine, government, education, science, business, and community affairs — we are beset with serious problems and complex issues that demand careful gathering and weighing of facts and informed opinions, thoughtful consideration of various conclusions or actions, and judicious selection of the best conclusion or most appropriate action &hellip;</p>
<p>Feeling and thought are perfectly complementary. Feeling, being more spontaneous, is an excellent beginning to the development of conclusions. And thought, being more deliberate, provides a way to identify the best and most appropriate feeling. Both are natural.</p>
</blockquote>
<h3 id="beyond-feeling-part-one-the-context">Beyond Feeling - Part One - The Context</h3>
<blockquote>
<p>Anyone who wishes to master an activity must first understand its tools and rules.</p>
<p>In critical thinking, however, the tools are not material objects but concepts, and the rules govern mental rather than physical performance.</p>
</blockquote>
<p>李笑来一直在强调概念要升级。爱因斯坦说过，如果有一个问题需要我一个小时内给出答案，我需要花 55 分钟搞清楚问题是什么。这都说明了概念的重要性。</p>
<h3 id="beyond-feeling-chapter-1-who-are-you">Beyond Feeling - Chapter 1 - Who Are You?</h3>
<blockquote>
<p>It would have to include all your characteristics—not only the physical but also the emotional and intellectual.</p>
</blockquote>
<p>哲学史上的圣杯问题。需要从身体，情感和智力方面去定义一个个体。个体特性会受以下方面的影响：</p>
<ul>
<li>The Influence of Time and Place: 时间和空间对人(身体，情感，智力)的影响。</li>
<li>The Influence of Ideas: 观念的暗示作用。</li>
<li>The Influence of Mass Culture: 多元文化，多渠道信息的广泛影响。</li>
<li>The “Science” of Manipulation: 科学操纵。行为主义心理学的发展。</li>
<li>The Influence of Psychology: 心理学的影响。</li>
</ul>
<blockquote>
<p>tell [the consumer] something that will tie him up with fear, something that will stir up a mild rage, that will call out an affectionate or love response, or strike at a deep psychological or habit need. &mdash; 行为主义心理学之父 John Watson</p>
</blockquote>
<p>几乎所有的现代广告和推广策略都离不开这段话。包括那些所谓产品情怀。</p>
<blockquote>
<p>advertisers and people with political or social agendas are not content to stimulate emotions and/or plant ideas in our minds. They also seek to reinforce those impressions by repeating them again and again. The more people hear a slogan or talking point, the more familiar it becomes. Before long, it becomes indistinguishable from ideas developed through careful thought.</p>
</blockquote>
<p>脑白金广告的真谛。</p>
<h2 id="20160913">20160913</h2>
<h3 id="beyond-feeling-becoming-an-individual">Beyond Feeling - Becoming an Individual</h3>
<ol>
<li>Treat your first reaction to any person, issue, or situation as tentative.<br />
   No matter how appealing it may be, refuse to embrace it until you have examined it.</li>
<li>Decide why you reacted as you did.</li>
<li>Think of other possible reactions you might have had to the person, issue, or situation.</li>
<li>Ask yourself whether one of the other reactions is more appropriate than your first reaction. And when you answer, resist the influence of your conditioning.</li>
</ol>
<h3 id="beyond-feeling-chapter-2-what-is-critical-thinking">Beyond Feeling - Chapter 2 What Is Critical Thinking?</h3>
<blockquote>
<p>Clear thinking is a very rare thing, but even just plain thinking is almost as rare. Most of us most of the time do not think at all. We believe and we feel, but we do not think.</p>
<p>Mental indolence is one of the commonest of human traits.</p>
</blockquote>
<p>看到这些文字，令人恐慌，回忆过往，我们什么时候有理有据地分析思考过一个问题？大部分时候，我们只是凭直觉生活。让生活的列车由感觉这个司机来自动驾驶，而且没有配置雷达纠错机制。细细想来，又令人兴奋，既然大部分完全不思考，那么只要坚持哪怕一点点成果，可能就会超越很多人。</p>
<h3 id="_16">博客主题：从进化的角度看短视</h3>
<p>只有短视才能在残酷，朝不保夕，险像环生的环境中生存下来。</p>
<h2 id="20160929">20160929</h2>
<h3 id="_17">博客主题：难与易</h3>
<p>我们努力奋斗，迎难而上，或多或少都希望将来的生活越来越容易。但生活从来都不曾容易过。</p>
<p>微信小程序刚出来，就有人破解开发工具，有人在 github 上收集所有的可用资源，有人把知乎客户端的界面用微信小程序的框架开发出来。为的就是消费微信小程序的流量红利。小道消息曾经发表过一篇文章，分析哪些人可以从微信小程序上获利，最先获利的就是这些培训机构。</p>
<h3 id="_18">博客主题：龟毛的程序员</h3>
<p>程序员是龟毛的，甚至是吹毛求疵的。为了达到 DRY (Do not Repeat Yourself) 的目标，他们发明了一个又一个框架，抽像了一层又一层，把原本简单明了的东西，层层构架。最后呈现出来的，是简洁和一目了然。但在简洁之下，隐藏了复杂，隐藏了日日夜夜的冥思苦想。</p>
<h3 id="_19">博客主题：逆向思维</h3>
<p>一个程序员，如果他要设计一个模块给别人使用，一个好的方法是假设自己就是这个模块的用户，用这个模块的接口去实现一些典型的功能，真正地把代码写出来。从写出来的代码里去闻看看有没有坏味道，如果有，多半是接口设计得不合理。很多时候，我们抱怨模块接口复杂不好用。一个很重要的原因就是模块设计者没有把自己摆在使用者的位置上。</p>
<h3 id="_20">博客主题：瞎忙是一种福分</h3>
<p>一句被广泛传播的话：选择比努力重要。还有一个说法更令人焦虑：很多时候你只是在瞎忙。一下子否定了所有的努力，焦虑感油然而生。我的方向对不对？做这个事情有没有意义？做这个事情能不能对未来的成功有帮助？</p>
<p>一个残酷的现实时，大部分人不会选择，甚至无法选择。</p>
<p>1985 年乔布斯离开苹果公司，创建 NeXT，收购皮克斯，他能预见到皮克斯的成功？能预见到回归苹果，把 NeXT 软件和苹果操作系统结合，从而产生 Mac/iOS 系列软件生态系统？</p>
<p>未来不可预测。我们需要偶尔布个闲棋，就像 AlphaGo 在胶着状态下，索性到脚落里下个闲棋，最后这个闲棋还真发挥了巨大的威力。乔布斯早年痴迷字体设计，他根本无法预见有朝一日这个技能会大大提高苹果软件的颜值。</p>
<blockquote>
<p>生命里的每一个点都会最终连成线。&mdash;乔布斯</p>
</blockquote>
<p>这里的点，在当时的情境下，可能都是瞎忙。</p>
<p>我们在公司里上着班，做着不痛不痒的工作。为什么不利用闲暇时间瞎忙一下呢？人工智能很有神奇，为什么不花点时间了解机器学习的算法和原理呢？前端开发技术栈一日千里，为什么不花点时间看看这些层出不穷的前端框架有什么区别，如何解决开发过程中的问题？后端开发怎么解决海量并发问题的？海量数据是怎么存储和检索的？甚至可以花点时间学学画画，我们的画画水平和 10 岁的小孩基本没有差别，想想都觉得有点惭愧。</p>
<p>但行好事，莫问前程。愿好奇心不泯，愿有时间瞎忙。</p>
<h2 id="20161001">20161001</h2>
<p><a href="http://naotu.baidu.com/file/5d3cbd7009d2a26d0c5aa31b63934d12">React Ecosystem</a></p>
<h2 id="20161022">20161022</h2>
<h3 id="app">跨平台 App 开发技术信息汇总</h3>
<h4 id="hybrid">Hybrid 技术</h4>
<p>这类技术，使用 HTML/CSS/JavaScript 等前端技术来构建 App。利用 JSBridge 获取部分访问原生 API 的能力。最有代表性的是 <a href="http://phonegap.com">PhoneGap</a>，它是 Adobe 收购一家开源创业公司后推出的平台。<a href="http://blog.ionic.io/what-is-cordova-phonegap/">这个链接</a>有 PhoneGap 的一些历史信息。</p>
<p>这类平台的目标是保持大部分代码跨平台共用，涉及到平台不共用的 API （比如 GPS 接口，iOS 和 Android 肯定是不一样的），则由 PhoneGap 平台通过 JSBridge 提供。除此之外，还有一些明显的优点：</p>
<ul>
<li>开发效率较高：使用 HTML/CSS/JavaScript 构建界面的效率要比原生 App 速度快很多。而且前端开发有一堆现成的框架和开源库可以直接使用。</li>
<li>即时更新：有 Bug 可以快速更新，不需要发布新 App，只需要更新服务器上想着的 HTML/CSS/JavaScript 即可。可以绕过 AppStore 的上架认证时间。</li>
<li>开发门槛低：对于前端开发工程师，可以快速转岗，开发出可用的 App，不需要对 iOS 平台和 Android 平台有太深入的了解。</li>
</ul>
<p>这类平台的硬伤是：</p>
<ul>
<li>单线程：JavaScript 在 WebView 里执行时是单线程的。对系统并发能力有较大的影响。</li>
<li>性能低：大概只能达到原生 App 70% 的流畅度。</li>
</ul>
<p><a href="http://blog.csdn.net/pzhtpf/article/details/25326397">这篇文章</a>对几个热门的 Hybrid 平台进行了对比和介绍。</p>
<p>为了克服 Hybrid 的缺点，目前工程应用上典型的做法是，以原生 App 为主，把易变的逻辑，以及界面，不涉及性能瓶颈的部分使用基于 WebView 的 Hybrid 技术来开发。</p>
<h4 id="_21">准原生平台</h4>
<p>为了解决 Hybrid 的问题，一些其他的方案逐步流行起来，最火的要算 <a href="https://facebook.github.io/react-native/">React-Native</a>，它是 Facebook 基于其前端框架 <a href="https://facebook.github.io/react/index.html">React</a> 之上构建的跨平台 App 开发构架。</p>
<p>这类平台的特点是，只使用 JavaScript 来构建界面，但实际上构建出来的所有界面都是系统原生控件。这是和 Hybrid 平台最大的区别，在 Hybrid 平台，一个按钮就是 HTML 构建出来的，但在 Bridge 平台，一个按钮是在各自的平台 (Android/iOS) 上以原生控件的形式渲染出来的。</p>
<p>这类平台最大的优势是：</p>
<ul>
<li>跨平台开发界面及业务逻辑：以前端工程师熟悉的构架，以一致的方式构建界面。</li>
<li>即时更新：可以把部分逻辑放在 JavaScript 里，这样就可以直接在线更新功能。</li>
<li>性能较高：比 Hybrid 性能高，大概能达到原生 App 90% 的流畅度。</li>
<li>开发效率较高：可以使用前端技术快速构建界面。比如，熟悉 React 框架的人，可以无障碍地在 React-Native 下构建通用界面。</li>
</ul>
<p>这类平台和 Hybrid 相比，跟原生平台靠得更近一些，更多地依赖原生平台的一些知识。比如，很多机制，其实还是要分 iOS 平台和 Android 平台的。即无法做到真正的跨平台开发，在利用 React-Native 这类构架时，还是需要对目标平台有较深入的理解。</p>
<p>除了 React-Native 之外，比较著名的还有 <a href="http://alibaba.github.io/weex/">Weex</a> 这是 alibaba 出品的一个构架，它是基于最近火热的前端构架 Vue.js 的。另外一个是 <a href="https://www.nativescript.org/">NativeScript</a>，这是基于老牌的前端构架 Angular<br />
之上构架的。</p>
<p>大家注意到，这些热门平台都是基于一个热门的前端构架来构建的。从这一点也可以看到这种类型的构架的目标，就是<strong>让前端开发人员可以在其原有知识体系里，快速开发 App ，并且使用自己熟悉的语言 JavaScript 来处理业务逻辑</strong>。至于核心的代码以及性能相关的代码，还是需要使用原生编程语言 (OC for iOS, Java for Android) 来编写，不同的平台最终向上层提供一致接口。这样，上面界面部分代码，甚至一些逻辑代码就可以跨平台共用了。</p>
<p>原理上，JavaScript 怎么样和原生平台交互呢？</p>
<p>JavaScript 是脚本语言，可以在运行时解释并执行。这类平台上写出来的 JavaScript 代码最终是由原生平台里面的 JavaScript 引擎来负责执行的。那么 JavaScript 如何调用原生代码呢？答案是利用语言的元编程能力，OC 和 Java 都具备一定的元编程能力，这样 JavaScript 只要知道原生平台的类名称，函数名称，就可以调用到原生平台的这个函数了。</p>
<p>关于这个课题，<a href="http://www.jianshu.com/p/978c4bd3a759">这里有篇文章</a>写得深入浅出。</p>
<p>关于这几类平台的性能对比，<a href="https://my.oschina.net/vczero/blog/597980?fromerr=FY2e0zCC">这篇文章</a>有非常详细的数据。</p>
<h4 id="_22">总结</h4>
<p>Hybrid 技术的愿景是真正达到一次开发，跨平台运行，但其性能是其最大的瓶颈。准原生平台的目标是让前端开发人员其于其熟悉的前端框架，快速开发 App 的<strong>界面和业务逻辑</strong>，且其性能和原生 App 很接近。使用准原生平台开发 App ，除非你是全栈工程师，否则是需要不同原生平台的开发人员配合。</p>
<h2 id="20161105">20161105</h2>
<h3 id="_23">博客主题：微信小程序框架的实现原理</h3>
<ol>
<li>开发者工具及其技术选型比较 Electron vs nwjs</li>
<li>小程序运行环境 - 与 ReactNative 类比</li>
</ol>
<h3 id="_24">博客主题：微信小程序开发环境的不足</h3>
<ol>
<li>包模块管理 - 目前不支持 npm 等包管理模块</li>
<li>动画</li>
<li>drag-drop 框架</li>
</ol>
<h2 id="20161113">20161113</h2>
<h3 id="_25">博客主题：白话网站架构演进</h3>
<ol>
<li>刀耕火种时代</li>
<li>动静分离</li>
<li>CDN</li>
<li>读写分离</li>
<li>分布式数据库</li>
</ol>
<h2 id="20161120">20161120</h2>
<h3 id="ssl">博客主题：白话 SSL 证书及安全性</h3>
<ol>
<li>非对称加密的数学原理：公钥和私钥</li>
<li>证书及证书链</li>
<li>申请/废除网站 SSL 证书的流程</li>
</ol>
<p>参考链接：https://letsencrypt.org/how-it-works/</p>
	<hr/>
	<h6>Post by <a href="../author/joey-huang.html">Joey Huang</a> under <a href="../category/notes.html">notes</a> on 2015-04-13(Monday) 00:19.</h6>
</article>

<hr/>
<div class="row">
	<div class="small-12 columns">
		<h3>Comments</h3>
		<div id="disqus_thread"></div>
		<script type="text/javascript">
			var disqus_shortname = 'kamidox';
			(function() {
				var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
		<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	</div>
</div>
						</div>
						<!-- End Main Content -->
						<!-- Sidebar -->
						<aside class="medium-3 hide-for-small-only columns">
							<div class="panel">
								<h5>Places</h5>
								<ul class="side-nav">
										<li><a href="http://blog.kamidox.com/feeds/rss.xml" rel="alternate">RSS Feed</a></li>

								</ul>
							</div>


							<div class="panel">
								<h5>Categories</h5>
								<ul class="side-nav">
										<li><a href="../category/android.html">android</a></li>
										<li><a href="../category/essay.html">essay</a></li>
										<li><a href="../category/flask.html">flask</a></li>
										<li><a href="../category/ml.html">ml</a></li>
										<li><a href="../category/nlp.html">nlp</a></li>
										<li><a href="../category/python.html">python</a></li>
										<li><a href="../category/tools.html">tools</a></li>
										<li><a href="../category/weapp.html">weapp</a></li>
										<li><a href="../category/web.html">web</a></li>
										<li><a href="../category/werkzeug.html">werkzeug</a></li>
								</ul>
							</div>

							<div class="panel">
								<h5>Tags</h5>
								<ul class="tag-cloud">
										<li class="tag-3"><a href="../tag/web.html">web</a></li>
										<li class="tag-4"><a href="../tag/ebook.html">ebook</a></li>
										<li class="tag-4"><a href="../tag/miui.html">miui</a></li>
										<li class="tag-3"><a href="../tag/pelican.html">pelican</a></li>
										<li class="tag-3"><a href="../tag/sublime.html">sublime</a></li>
										<li class="tag-4"><a href="../tag/patchrom.html">patchrom</a></li>
										<li class="tag-2"><a href="../tag/flask.html">flask</a></li>
										<li class="tag-4"><a href="../tag/github.html">github</a></li>
										<li class="tag-1"><a href="../tag/python.html">python</a></li>
										<li class="tag-4"><a href="../tag/socketserver.html">SocketServer</a></li>
										<li class="tag-2"><a href="../tag/android.html">android</a></li>
										<li class="tag-2"><a href="../tag/tools.html">tools</a></li>
										<li class="tag-4"><a href="../tag/nlp.html">nlp</a></li>
										<li class="tag-1"><a href="../tag/machine-learning.html">machine-learning</a></li>
										<li class="tag-4"><a href="../tag/contacts.html">contacts</a></li>
										<li class="tag-4"><a href="../tag/contacts-provider.html">contacts provider</a></li>
										<li class="tag-2"><a href="../tag/weapp.html">weapp</a></li>
										<li class="tag-4"><a href="../tag/decorator.html">decorator</a></li>
										<li class="tag-4"><a href="../tag/react.html">react</a></li>
										<li class="tag-2"><a href="../tag/markdown.html">markdown</a></li>
										<li class="tag-1"><a href="../tag/thought.html">thought</a></li>
										<li class="tag-4"><a href="../tag/wekzeug.html">wekzeug</a></li>
										<li class="tag-4"><a href="../tag/uml.html">uml</a></li>
								</ul>
							</div>

							<div class="panel">
								<h5>Monthly Archives</h5>
								<ul class="side-nav">
											<li><a href="/posts/2018/03/index.html">March 2018 (1)</a></li>
											<li><a href="/posts/2017/05/index.html">May 2017 (2)</a></li>
											<li><a href="/posts/2017/04/index.html">April 2017 (1)</a></li>
											<li><a href="/posts/2017/02/index.html">February 2017 (1)</a></li>
											<li><a href="/posts/2017/01/index.html">January 2017 (1)</a></li>
											<li><a href="/posts/2016/12/index.html">December 2016 (2)</a></li>
											<li><a href="/posts/2016/11/index.html">November 2016 (3)</a></li>
											<li><a href="/posts/2016/10/index.html">October 2016 (1)</a></li>
											<li><a href="/posts/2016/09/index.html">September 2016 (1)</a></li>
											<li><a href="/posts/2016/03/index.html">March 2016 (2)</a></li>
											<li><a href="/posts/2016/02/index.html">February 2016 (2)</a></li>
											<li><a href="/posts/2016/01/index.html">January 2016 (2)</a></li>
											<li><a href="/posts/2015/12/index.html">December 2015 (10)</a></li>
											<li><a href="/posts/2015/11/index.html">November 2015 (6)</a></li>
											<li><a href="/posts/2015/10/index.html">October 2015 (2)</a></li>
											<li><a href="/posts/2015/09/index.html">September 2015 (7)</a></li>
											<li><a href="/posts/2015/08/index.html">August 2015 (1)</a></li>
											<li><a href="/posts/2015/07/index.html">July 2015 (1)</a></li>
											<li><a href="/posts/2015/05/index.html">May 2015 (1)</a></li>
											<li><a href="/posts/2015/04/index.html">April 2015 (1)</a></li>
											<li><a href="/posts/2015/03/index.html">March 2015 (3)</a></li>
											<li><a href="/posts/2015/02/index.html">February 2015 (2)</a></li>
											<li><a href="/posts/2015/01/index.html">January 2015 (2)</a></li>
											<li><a href="/posts/2014/12/index.html">December 2014 (3)</a></li>
											<li><a href="/posts/2014/11/index.html">November 2014 (4)</a></li>
											<li><a href="/posts/2014/10/index.html">October 2014 (6)</a></li>
											<li><a href="/posts/2014/09/index.html">September 2014 (1)</a></li>
											<li><a href="/posts/2014/07/index.html">July 2014 (1)</a></li>
								</ul>
							</div>

						</aside>
						<!-- End Sidebar -->
					</div>

					<!-- Footer -->
					<footer class="row">
						<div class="medium-9 small-12">
							<hr/>
							<p class="text-center">Powered by <a href="http://getpelican.com">Pelican</a> and <a href="http://foundation.zurb.com/">Zurb Foundation</a>. Theme by <a href="http://hamaluik.com">Kenton Hamaluik</a>.
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253471695'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1253471695%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
							</p>
						</div>
					</footer>
					<!-- End Footer -->
				</section>
				<a class="exit-off-canvas"></a>
			</div><!--off-canvas inner-->
		</div><!--off-canvas wrap-->

		<script src="../theme/js/jquery.js"></script>
		<script src="../theme/js/foundation.min.js"></script>
		<script>
			$(document).foundation();
		</script>
	</body>
</html>