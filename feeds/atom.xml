<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>kamidox.com</title><link href="http://blog.kamidox.com/" rel="alternate"></link><link href="http://blog.kamidox.com/feeds/atom.xml" rel="self"></link><id>http://blog.kamidox.com/</id><updated>2021-12-15T23:36:00+08:00</updated><entry><title>网络安全的基础 - 数字证书及签名</title><link href="http://blog.kamidox.com/security-basic-cert-sign.html" rel="alternate"></link><updated>2018-03-31T23:52:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2018-03-31:security-basic-cert-sign.html</id><summary type="html">&lt;h2 id="_1"&gt;写在前面&lt;/h2&gt;
&lt;p&gt;你哼着小曲，打开招商银行的网站，想查查看今年的奖金到账了没有。突然，一个想法惊出你一身冷汗：万一打开的是李鬼的招商银行网站，一输入密码登录，不是密码全被不法分子窃取了么？浏览器怎么判断这是一个可信的网站，而不是某李鬼网站呢？要回答这个问题，得从数字证书及数字签名的原理谈起。实际上，本文要介绍的这些知识，也是当前火热的区域链技术的基础。&lt;/p&gt;
&lt;h2 id="_2"&gt;摘要算法&lt;/h2&gt;
&lt;p&gt;要谈清楚这些问题，需要先了解一下摘要算法。摘要算法根据输入计算出摘要。&lt;/p&gt;
&lt;p&gt;&lt;img alt="摘要算法" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/digest.png" /&gt;&lt;/p&gt;
&lt;p&gt;它的特点是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定长输出：不管输入的数据是是长还是短，只要选定了特定的摘要算法，其输出的长度就是固定的。比如 SHA256 输出的摘要算法就是 32 字节。&lt;/li&gt;
&lt;li&gt;碰撞概率低：绝对不碰撞是不可能的，但好的摘要算法能做到非常低的碰撞概率。从应用的角度来看，基本上可以理解为一个输入对应一个输出，当输入改变了，输出也跟着改变。&lt;/li&gt;
&lt;li&gt;单向性：摘要算法是不可逆的。一个输入对应着一个输出，但从输出无法倒推出输入。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_3"&gt;数据指纹&lt;/h2&gt;
&lt;p&gt;摘要算法的这个特点经常被用来计算数据的指纹，然后进行指纹验证。常用的摘要算法有 SHA1, SHA256, MD5 等等。SHA256 摘要算法的输出是 32 个字节，MD5 的摘要算法是 16 字节。比如，网站登录时，用户会网页上输入密码，服务器端要对输入的密码进行验证。此时网页前端不必把密码直接发送给服务器去验证，而是使用摘要算法计算密码的指纹，并把这个摘要信息发送给服务器进行验证（这样可以减少密码被人截获的风险），这样服务器只要拿相同的摘要算法也算一下密码的摘要，对比两个摘要是否相同即可知道用户输入的密码是否正确。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;备注：服务器的规范做法，不会保存密码的原文在数据库里的，一般通用的做法是生成一个随机的盐值，称为 salt，然后计算并保存密码加盐的摘要。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;另外一个常用的场景是，对文件的完整性进行验证。比如，你从网站上下载了一个文件，下载提供方还会提供这个文件的 MD5 摘要信息，你把这个文件下载下来后，可以计算一下这个文件的 MD5 摘要，然后和网站提供的 MD5 对比，如果一样，说明下载下来的文件是完整的；如果不一致，说明下载下来的文件是不完整的。&lt;/p&gt;
&lt;h2 id="_4"&gt;非对称加密算法&lt;/h2&gt;
&lt;p&gt;非对称加密算法和摘要算法，构成了数字签名和数字证书的基础。非对称加密算法的最大特点是：&lt;strong&gt;加密时使用的密钥和解密时使用的密钥是不一样的&lt;/strong&gt;。即，非对称加密算法有两套密码，分别称为&lt;strong&gt;私钥&lt;/strong&gt;和&lt;strong&gt;公钥&lt;/strong&gt;，私钥私密保存，只有自己知道；公钥可以发给通信的对端。私钥加密的数据，只有对应的公钥能解密，公钥加密的信息，只有私钥能解密。用大白话，使用非对称加密算法来加密通信的数据后，我对外发的信息别人都能解读（因为公钥任何人都可以得到，是公开的），但别人给我发的信息，只有我能解读（因为只有我自己有私钥，能解密）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="加密" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/rsa_encrypt.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="解密" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/rsa_decrypt.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;备注：与非对称加密算法对应的是对称加密算法。对称加密算法的密码只有一个，通信双方共享这个密码。常用的对称加密算法有 AES, DES 等。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="_5"&gt;数字签名&lt;/h2&gt;
&lt;p&gt;常用的非对称加密算法有 RSA 和 ECC 等。非对称算法最经典的应用，是结合摘要算法对数据进行签名。现实生活中，签名的物理意义，是表示签下名字的主体认可被签名数据的有效性。比如，纸面签名是使用笔写上自己的名字，在签名认证时，通过确认笔迹来进行确认。那么，在数字世界中，怎么样进行数字签名呢？数字签名的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择合适的摘要算法（如 SHA256）计算出待签名数据的摘要&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;私钥&lt;/strong&gt;对摘要进行加密，输出的密文就是数据的&lt;strong&gt;签名&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="签名" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/digital_sign.png" /&gt;&lt;/p&gt;
&lt;p&gt;对签名进行检查的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;strong&gt;公钥&lt;/strong&gt;对签名进行解密，解密出来的就是数据的摘要&lt;/li&gt;
&lt;li&gt;使用与签名时相同的摘要算法计算出数据的摘要&lt;/li&gt;
&lt;li&gt;对比步骤 1 和步骤 2 的摘要，如果相同，则说明签名有效，否则说明数据是无效的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="签名检查" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/digital_sign_verify.png" /&gt;&lt;/p&gt;
&lt;p&gt;假设，有人偷偷篡改了数据，由于数字签名是没办法改变的，因为数字签名是经过私密保存的&lt;strong&gt;私钥&lt;/strong&gt;加密过的，别人没有私钥，故无法对数字签名进行修改。在验证签名时，上述步骤 2 算出来的摘要（被篡改后的数据算出来的摘要）和步骤 1 算出来的摘要（用公钥直接解密的，原数据的摘要）必定不相同，这样就可以验证出来数据被人篡改了。&lt;/p&gt;
&lt;h2 id="_6"&gt;证书签名&lt;/h2&gt;
&lt;p&gt;有了数字签名的算法，我们就可以对实体颁发数字证书，然后让有公信力的机构对数字证书进行签名，这样就可以证明实体的真实身份。数字证书的主体内容包含三部分主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证书基本信息：如证书的实体的名称，邮件地址，签发者，有效期等&lt;/li&gt;
&lt;li&gt;公钥：通信对端可以从数字证书里得到公钥，这样就可以对私钥加密过的数据进行解密&lt;/li&gt;
&lt;li&gt;数字签名：这个证书的数字签名。签名就是计算证书的摘要，然后用签发者的私钥进行加密后的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;老牌的提供数字签名服务的机构是 VeriSign，交纳一定的费用，VeriSign 可以使用他们的 CA 证书给你的数字证书进行签名。这样主流的浏览器就会认可这个证书，并认为使用了这个证书的网站是安全的。问题是 VeriSign 怎么做到的呢？&lt;/p&gt;
&lt;p&gt;实际上，VeriSign 以他们的信誉背书，生成了一个根证书，这个根证书是自签名的。即 VeriSign 在法律层面上要负责这个根证书的真实性和有效性。万一哪一天 VeriSign 的根证书的私钥泄漏了，被不法分子拿去，不法分子完全可以使用这个私钥，给一些恶意网站的证书进行签名。当用户打开这些恶意网站时，浏览器就不会提示用户。相反，浏览器会认为这是一个可信的网站。&lt;/p&gt;
&lt;p&gt;有了根证书，VeriSign 就可以用根证书，按照不同的业务和行业签发一堆专用的 CA 证书出来，然后再用 CA 证书去给具体的实体的数字证书进行签名。浏览器验证实体的数字证书的合法性时，先检查这个证书的签名是否正确，然后检查给这个证书签名的 CA 证书的合法性。这样沿着&lt;strong&gt;证书链&lt;/strong&gt;一步步往上验证，最终验证到了根证书。由于浏览器内置了 VeriSign 的根证书，故浏览器知道这个证书是合法的。浏览器就是这样判断一个网站的证书是否是可信的。&lt;/p&gt;
&lt;p&gt;比如下图是招商银行的证书：&lt;/p&gt;
&lt;p&gt;&lt;img alt="证书链" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/cert_chain.png" /&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，招商银行的证书是由 Symantec Class 3 EV SSL CA - G3 这个 CA 证书签名的，而这个 CA 证书又是由 VeriSign Class 3 Public Primary Certification Authority - G5 这个证书签名的。这样也就不难理解，为什么 VeriSign 在给你的网站的数字证书进行签名时需要收取费用：实际上这是一个名誉背书的费用。技术角度来看，运行一条指令就可以对你的数字证书进行签名，没有任何的成本，但 VeriSign 必须在法律层面保证，他们签名的对象是个可信的实体。&lt;/p&gt;
&lt;p&gt;实际上，你完全可以生成一个自签名的证书，即用你自己生成的证书的私钥给你自己的证书签名。这是完全合法的，但浏览器往往不认可这种自签名证书，并且提示用户说，这个网站的证书是不可信的。&lt;/p&gt;
&lt;h2 id="_7"&gt;实践出真知&lt;/h2&gt;
&lt;p&gt;如果你对技术细节不感兴趣，这篇文章阅读到此就可以结束了。本节演示如何使用 openssl 工具包，对数据进行数字签名及验证，以及对证书进行签名。&lt;/p&gt;
&lt;h3 id="_8"&gt;信息摘要&lt;/h3&gt;
&lt;p&gt;我们先把要计算摘要的数据保存到 &lt;code&gt;data.txt&lt;/code&gt; 文件里：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;&lt;span style="color: #AA22FF"&gt;echo&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;This is real words from Joey.&amp;quot;&lt;/span&gt; &amp;gt; data.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后以这个文件作为输入计算 SHA256 摘要信息：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl dgst -sha256 -hex data.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其输出为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;SHA256&lt;span style="color: #666666"&gt;(&lt;/span&gt;data.txt&lt;span style="color: #666666"&gt;)=&lt;/span&gt; f1b1b3f5f35944c8e2169031efac2a37147dac631b8dbd7cfa5d265e0e804e8d
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，我们也可以换成 MD5 算法并计算其摘要：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl dgst -md5 -hex data.txt
MD5&lt;span style="color: #666666"&gt;(&lt;/span&gt;data.txt&lt;span style="color: #666666"&gt;)=&lt;/span&gt; ed764086c5770a9d5ff0e60036aa4226
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从输出不难看出，SHA256 的摘要输出是 32 个字节（f1 是第一个字节，b1 是第二个字节，依此类推），MD5 的摘要输出是 16 字节。&lt;/p&gt;
&lt;h3 id="_9"&gt;非对称加密算法&lt;/h3&gt;
&lt;p&gt;我们先生成一个 2048 bit 的 RSA 算法私钥：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl genrsa -out rsa_private.key 2048
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;rsa_private.key&lt;/code&gt; 就是生成的私钥。这是个文本文件，你可以用任何文本编辑器打开它，内容如下：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;-----BEGIN RSA PRIVATE KEY-----
BASE64(PRIVATE KEY)
-----END RSA PRIVATE KEY-----
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;私钥数据是经过 BASE64 编码的数据，故显示成 ASCII 字符。私钥必须私密保存，一旦泄漏，整个安全体系就崩塌了。由于私钥是如此的重要，openssl 提供了一个方法来加密保存私钥文件。下面的命令用来生成密码保护的密钥：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl genrsa -aes256 -passout pass:yourpwd -out rsa_aes_private.key 2048
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个命令生成的私钥 &lt;code&gt;rsa_aes_private.key&lt;/code&gt; 是使用 AES 256 算法加密保存的，密码就是字符串 &lt;code&gt;yourpwd&lt;/code&gt; 。下次使用这个私钥时，就必须提供这个密码才能使用。我们还可以把加密保存的私钥转为不加密的，其命令为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl rsa -in rsa_aes_private.key -passin pass:yourpwd -out rsa_private.key
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，明文的私钥也可以加密保存起来：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl rsa -in rsa_private.key -aes256 -passout pass:newpwd -out rsa_aes_private.key
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有了私钥，我们就可以生成与之配套使用的公钥：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl rsa -in rsa_private.key -pubout -out rsa_public.key
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;rsa_public.key&lt;/code&gt; 就是对应的公钥。公钥文件也是一个纯文本文件，其内容示意如下：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA69EVk9GKyEQDRfV8OJUf
49eaJ67bTP/zAPm5huf9z7EhAaltjyfHNaCQMYVTAKUAS9c7XhKxA8NkHil/HNBE
4UONY054voisKWYqxtHaoFkcfY5QE+vj9JVJajwYAKZjA362zo2y8qbpJ6INCMeB
19oOuGFBTkn4z0RR71kFriyQ2pOjbHru5pH9bC9t4GjvkNMNWeFdSdR3uO3zIYB6
cl176kaYZ8Bwr+PeGl+jzMpd7lDSEVLLaAt1jZiNLQ1dYTN4GGuURy/6b3d4+TZ1
VxNlLc0+8l+vyzpXRZWxZcEBjA4voeWmxqBKUsA6jKTDS/V6IFOTakoOGLk5w3f1
EQIDAQAB
-----END PUBLIC KEY-----
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_10"&gt;证书及签名&lt;/h3&gt;
&lt;h4 id="_11"&gt;生成自签名证书&lt;/h4&gt;
&lt;p&gt;使用已有 RSA 算法的私钥生成自签名证书：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl req -new -x509 -days &lt;span style="color: #666666"&gt;365&lt;/span&gt; -key rsa_private.key -out cert.crt -subj &lt;span style="color: #BB4444"&gt;&amp;quot;/C=CN/ST=FJ/L=XM/O=sfox/OU=dev/CN=sfox.com/emailAddress=sfox@sfox.com&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-days 参数指明这个证书的有效期；-key 参数指定使用的 RSA 私钥文件；-out 参数指定输出的自签名证书文件，一般以 crt 作为后缀名；-subj 参数用来指定证书的名称，如果不带这个参数，则需要逐个输入证书的名称参数，包含国家，省份，城市，组织名称，部门名称，通用名称等等。&lt;/p&gt;
&lt;p&gt;可以使用下面命令来查看自签名证书的信息：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl x509 -in cert.crt -noout -text
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其输出示意如下：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Certificate:
    Data:
        Version: 1 (0x0)
        Serial Number: 11926462855904995145 (0xa5834ec7411ba749)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=CN, ST=FJ, L=XIAMEN, O=SFOX, OU=SW, CN=sfox/emailAddress=sfox@qq.com
        Validity
            Not Before: Mar 31 13:35:11 2018 GMT
            Not After : Mar 31 13:35:11 2019 GMT
        Subject: C=CN, ST=FJ, L=XIAMEN, O=SFOX, OU=SW, CN=sfox/emailAddress=sfox@qq.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:eb:d1:15:93:d1:8a:c8:44:03:45:f5:7c:38:95:
                    1f:e3:d7:9a:27:ae:db:4c:ff:f3:00:f9:b9:86:e7:
                    fd:cf:b1:21:01:a9:6d:8f:27:c7:35:a0:90:31:85:
                    53:00:a5:00:4b:d7:3b:5e:12:b1:03:c3:64:1e:29:
                    7f:1c:d0:44:e1:43:8d:63:4e:78:be:88:ac:29:66:
                    2a:c6:d1:da:a0:59:1c:7d:8e:50:13:eb:e3:f4:95:
                    49:6a:3c:18:00:a6:63:03:7e:b6:ce:8d:b2:f2:a6:
                    e9:27:a2:0d:08:c7:81:d7:da:0e:b8:61:41:4e:49:
                    f8:cf:44:51:ef:59:05:ae:2c:90:da:93:a3:6c:7a:
                    ee:e6:91:fd:6c:2f:6d:e0:68:ef:90:d3:0d:59:e1:
                    5d:49:d4:77:b8:ed:f3:21:80:7a:72:5d:7b:ea:46:
                    98:67:c0:70:af:e3:de:1a:5f:a3:cc:ca:5d:ee:50:
                    d2:11:52:cb:68:0b:75:8d:98:8d:2d:0d:5d:61:33:
                    78:18:6b:94:47:2f:fa:6f:77:78:f9:36:75:57:13:
                    65:2d:cd:3e:f2:5f:af:cb:3a:57:45:95:b1:65:c1:
                    01:8c:0e:2f:a1:e5:a6:c6:a0:4a:52:c0:3a:8c:a4:
                    c3:4b:f5:7a:20:53:93:6a:4a:0e:18:b9:39:c3:77:
                    f5:11
                Exponent: 65537 (0x10001)
    Signature Algorithm: sha256WithRSAEncryption
         b3:41:be:6f:54:3c:d7:fc:53:c6:21:f5:ea:fa:2d:c7:70:ed:
         29:57:c4:0b:74:43:74:24:1b:05:df:2e:9f:ef:76:32:8a:8e:
         4a:85:31:18:a2:50:95:1a:6e:07:cf:e9:82:04:55:ee:1b:26:
         0a:e7:bf:47:ef:d5:69:d1:ef:fb:db:50:52:84:2d:85:e9:2c:
         15:5c:de:2d:9c:74:fe:90:b9:02:29:1b:dc:fb:b8:ef:08:b2:
         04:0c:27:66:c8:f1:31:a6:f3:52:73:4b:16:41:0d:f1:a9:d5:
         f2:1b:60:3a:44:a0:be:35:ef:a6:e4:10:bf:90:4e:98:3f:56:
         3e:3d:ef:99:b2:38:97:2b:5a:f9:46:61:4a:e1:77:9e:76:0a:
         3a:d6:2f:f2:16:31:8c:cf:e5:e4:e5:42:14:07:8c:fa:a6:48:
         19:76:cd:6d:63:8e:62:a2:65:83:9f:9d:c4:d6:32:97:6a:54:
         e6:27:49:30:aa:08:72:0c:2f:e0:9a:a1:ae:2a:75:34:ad:31:
         0f:26:71:7e:6f:75:d4:cc:d3:58:13:2c:18:da:2d:ef:a1:e6:
         7a:9a:d1:d4:1d:48:b4:ac:06:84:8b:07:1b:15:9c:f8:e5:fe:
         ac:58:c4:50:74:a9:8e:c2:f9:24:01:a2:d1:83:92:41:96:fa:
         bb:42:73:7a
&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id="_12"&gt;生成签名请求文件&lt;/h4&gt;
&lt;p&gt;当需要申请使用 CA 证书对证书进行签名时，需要生成签名请求文件。使用己有的 RSA 私钥生成签名请求文件的命令为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl req -new -key rsa_private.key -out cert.csr -subj &lt;span style="color: #BB4444"&gt;&amp;quot;/C=CN/ST=FJ/L=XM/O=sfox/OU=dev/CN=sfox.com/emailAddress=sfox@sfox.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 -key 指定证书的私钥信息，openssl 命令会使用私钥来算出公钥，并把公钥包含在证书文件里；-out 指明要生成的证书签名请求文件的文件名，一般以 csr 作为后缀；-subj 表示待签名的证书的名称信息。生成的证书请求文件可以使用如下命令来查看详情：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl req -noout -text -in cert.csr
Certificate Request:
    Data:
        Version: &lt;span style="color: #666666"&gt;0&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;0x0&lt;span style="color: #666666"&gt;)&lt;/span&gt;
        Subject: &lt;span style="color: #B8860B"&gt;C&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;CN, &lt;span style="color: #B8860B"&gt;ST&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;FJ, &lt;span style="color: #B8860B"&gt;L&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;XM, &lt;span style="color: #B8860B"&gt;O&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;SFOX, &lt;span style="color: #B8860B"&gt;OU&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;SW, &lt;span style="color: #B8860B"&gt;CN&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;sfox.com/emailAddress&lt;span style="color: #666666"&gt;=&lt;/span&gt;sfox@qq.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: &lt;span style="color: #666666"&gt;(2048&lt;/span&gt; bit&lt;span style="color: #666666"&gt;)&lt;/span&gt;
                Modulus:
                    00:eb:d1:15:93:d1:8a:c8:44:03:45:f5:7c:38:95:
                    1f:e3:d7:9a:27:ae:db:4c:ff:f3:00:f9:b9:86:e7:
                    fd:cf:b1:21:01:a9:6d:8f:27:c7:35:a0:90:31:85:
                    53:00:a5:00:4b:d7:3b:5e:12:b1:03:c3:64:1e:29:
                    7f:1c:d0:44:e1:43:8d:63:4e:78:be:88:ac:29:66:
                    2a:c6:d1:da:a0:59:1c:7d:8e:50:13:eb:e3:f4:95:
                    49:6a:3c:18:00:a6:63:03:7e:b6:ce:8d:b2:f2:a6:
                    e9:27:a2:0d:08:c7:81:d7:da:0e:b8:61:41:4e:49:
                    f8:cf:44:51:ef:59:05:ae:2c:90:da:93:a3:6c:7a:
                    ee:e6:91:fd:6c:2f:6d:e0:68:ef:90:d3:0d:59:e1:
                    5d:49:d4:77:b8:ed:f3:21:80:7a:72:5d:7b:ea:46:
                    98:67:c0:70:af:e3:de:1a:5f:a3:cc:ca:5d:ee:50:
                    d2:11:52:cb:68:0b:75:8d:98:8d:2d:0d:5d:61:33:
                    78:18:6b:94:47:2f:fa:6f:77:78:f9:36:75:57:13:
                    65:2d:cd:3e:f2:5f:af:cb:3a:57:45:95:b1:65:c1:
                    01:8c:0e:2f:a1:e5:a6:c6:a0:4a:52:c0:3a:8c:a4:
                    c3:4b:f5:7a:20:53:93:6a:4a:0e:18:b9:39:c3:77:
                    f5:11
                Exponent: &lt;span style="color: #666666"&gt;65537&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;0x10001&lt;span style="color: #666666"&gt;)&lt;/span&gt;
        Attributes:
            a0:00
    Signature Algorithm: sha256WithRSAEncryption
         13:aa:fc:0f:82:a4:b1:cf:3a:f3:3f:ff:53:b8:50:e8:41:cc:
         6b:a3:1c:5b:e2:4d:b0:47:f3:02:a8:ae:34:22:94:fc:8d:6b:
         11:41:82:33:9f:b1:df:da:fd:90:18:55:5d:aa:9e:61:82:26:
         e0:b5:9e:86:0d:18:cb:8d:e4:f5:d3:2c:32:8d:21:9d:f8:c2:
         3d:c8:22:e2:9c:10:69:bc:25:de:a4:14:05:c3:2c:c7:7b:d4:
         ee:30:53:9c:71:2f:0e:f5:04:83:54:d8:74:28:e9:ef:4a:72:
         b5:88:a5:73:d5:78:8e:27:88:be:52:16:fd:a9:cc:13:38:aa:
         1c:94:a4:20:a5:23:4d:bd:7d:29:d2:db:da:ec:86:2c:99:36:
         fb:c0:b2:0f:ec:da:ef:51:d5:f7:37:d0:11:59:d0:66:c4:e9:
         d1:ed:a1:2b:d4:b3:46:6b:fe:6f:17:3b:77:0c:be:f8:20:5b:
         ca:66:2d:64:17:20:5d:19:73:4d:be:5e:e3:fc:25:1a:cb:03:
         87:4d:55:7a:56:9d:ed:d7:7d:5a:55:e2:85:1b:2f:d2:fe:74:
         43:6f:84:5c:2b:de:c9:0c:05:76:08:65:de:6a:21:d6:26:0f:
         23:5a:12:4e:13:0e:8f:fd:ef:7c:e6:b4:6b:07:80:0f:2b:b8:
         7f:66:c7:16
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;细心的读者可以发现，证书签名请求文件和自签名的证书文件相比，少了 Issuer（颁发者），Serial Number，Validity（有效期）等信息。&lt;/p&gt;
&lt;h4 id="ca-csr"&gt;使用 CA 证书对 CSR 文件进行签名&lt;/h4&gt;
&lt;p&gt;要使用 CA 证书对签名请求文件进行签名，你必须有 CA 证书文件以及 CA 证书的私钥文件。有了这两个文件，可以使用下面的命令进行签名：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl x509 -req -days &lt;span style="color: #666666"&gt;3650&lt;/span&gt; -in cert.csr -CA ca.crt -CAkey ca.key -passin pass:yourpwd -CAcreateserial -out cert_ca_signed.crt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-days 表示证书的有效期，此处指定 3650 表示 10 年有效期；-in 表示输入文件，此处是指证书请求签名文件的文件名；-CA 指定 CA 证书的文件名；-CAkey 指定 CA 证书的私钥文件；-passin 指定 CA 证书的私钥文件的加密密码，如果以明文保存的私钥文件，则此参数可省略。-CAcreateserial 参数指定给签名后的证书创建序列号；-out 参数指明输出的签名后的数字证书文件的文件名。&lt;/p&gt;
&lt;p&gt;当然，这里你完全可以使用自签名的证书文件及其对应的私钥文件给其他的证书请求文件进行签名。&lt;/p&gt;
&lt;h3 id="_13"&gt;数字签名及验证&lt;/h3&gt;
&lt;p&gt;本小节将演示对一段文本内容进行签名，然后验证签名的正确性。&lt;/p&gt;
&lt;p&gt;我们先生成待签名的数字内容：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;&lt;span style="color: #AA22FF"&gt;echo&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;This is real words from Joey.&amp;quot;&lt;/span&gt; &amp;gt; data.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着，对数字内容进行签名，签名的时候使用的是&lt;strong&gt;私钥&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl dgst -sha256 -sign rsa_private.key -out data.sign data.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个命令对 &lt;code&gt;data.txt&lt;/code&gt; 文件的内容计算 SHA256 摘要；然后使用对输出的 32 字节的摘要信息，使用 &lt;code&gt;rsa_private.key&lt;/code&gt; 指定的私钥进行加密，并把密文输出到 &lt;code&gt;data.sign&lt;/code&gt; 文件里。&lt;code&gt;data.sign&lt;/code&gt; 是个二进制文件，文件里保存的内容就是 &lt;code&gt;data.txt&lt;/code&gt; 文件的数字签名。&lt;/p&gt;
&lt;p&gt;接着，我们对数字内容进行签名检查，检查签名时使用的是公钥：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl dgst -sha256  -verify rsa_public.key -signature data.sign data.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不出意外的话，输出的内容为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Verified OK
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;表示数字签名验证成功，&lt;code&gt;data.txt&lt;/code&gt; 文件的内容没有被篡改。现在，我们把 &lt;code&gt;data.txt&lt;/code&gt; 文件修改一下，看看签名验证能否成功：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;&lt;span style="color: #AA22FF"&gt;echo&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;This is fake words from Joey.&amp;quot;&lt;/span&gt; &amp;gt; data.txt
&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;openssl dgst -sha256  -verify rsa_public.key -signature data.sign data.txt
Verification Failure
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时输出的是 &lt;code&gt;Verification Failure&lt;/code&gt; 表示数字签名验证失败。&lt;/p&gt;
&lt;p&gt;当然，如果我们手头没有现成的公钥业验证签名，只要有这个网站的证书，则可以可以从证书里获取到公钥：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;openssl x509 -in cert_ca_signed.crt -pubkey -noout &amp;gt; rsa_public.key
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（完）&lt;/p&gt;</summary><category term="web"></category></entry><entry><title>基于 Gitlab 的源代码管理及开发模型</title><link href="http://blog.kamidox.com/gitlab.html" rel="alternate"></link><updated>2017-05-14T20:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2017-05-14:gitlab.html</id><summary type="html">&lt;p&gt;&lt;a href="https://about.gitlab.com/products/"&gt;Gitlab CE&lt;/a&gt; 是一个开源的基于 Git 的源代码管理软件，本文介绍基于 Gitlab 的源代码管理规范及典型工作流程。关于 Gitlab 的安装，可参阅&lt;a href="https://about.gitlab.com/installation/"&gt;官方文档&lt;/a&gt;。Gitlab 是一个非常强大的系统，基本上可以搭建一个类似 Github 这样的私有网站了。本文描述的，只是针对嵌入式开发领域，进行项目管理，权限管理，代码评审，产品分支管理等有限领域的一些实践规则。&lt;/p&gt;
&lt;h2 id="1"&gt;1 用户管理&lt;/h2&gt;
&lt;p&gt;Gitlab 安装完成后，会自动创建一个 root 帐户，这个帐户是系统管理员。系统管理员有最高的系统权限，可以查看所有的项目，并给适当的项目分配权限。当系统管理员第一次登录时，系统会强制要求修改密码。&lt;/p&gt;
&lt;p&gt;用户可以自己注册，也可以由系统管理员创建用户。这里推荐由系统管理员创建用户，并设置初始密码，然后告诉用户。用户第一次登录时，系统要求修改密码。推荐用户登录后，修改个人头像，并使用真实头像，这样后续查看修改记录时可以一眼看出哪个人修改了什么内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="创建用户" src="https://raw.githubusercontent.com/kamidox/blogs/master/https://raw.githubusercontent.com/kamidox/blogs/master/images/git_create_user.png" /&gt;&lt;/p&gt;
&lt;p&gt;操作演练（建议实际安装完成后，演练一遍下面的任务）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Gitlab 系统上创建四个用户，分别是 user1, user2, user3, user4&lt;/li&gt;
&lt;li&gt;使用 user1 登录系统&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="2"&gt;2 项目管理&lt;/h2&gt;
&lt;p&gt;对正式的项目，推荐由系统管理员来进行项目管理工作，并分配权限。系统管理员账户一般由软件开发经理持有，这样确保不会有人能随意修改系统，也不会有人能看到全部的项目相关资料。&lt;/p&gt;
&lt;h3 id="21"&gt;2.1 创建项目&lt;/h3&gt;
&lt;p&gt;创建项目推荐在 Gitlab 网页上操作，简单易懂。需要注意，创建项目时，一定要选择 “Private” 的项目。Public 的项目注册用户都可以看得到。而 Private 的项目只有经过明确邀请的用户才能看得到这个项目。这对项目的权限管理有极大的帮助。&lt;/p&gt;
&lt;p&gt;&lt;img alt="创建项目" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_create_project.png" /&gt;&lt;/p&gt;
&lt;p&gt;操作演练：由系统管理员创建一个示例项目 demo&lt;/p&gt;
&lt;h3 id="22"&gt;2.2 设置项目成员&lt;/h3&gt;
&lt;p&gt;不同的帐户具有不同的项目权限。Gitlab 有多种角色的帐户，还可以基于 Group 来进行权限管理。在需求不是特别复杂的情况下，我们推荐采用最简单的权限模型来管理项目权限。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Master 账户是这个项目的主要负责人，他可以直接修改代码并提交，不需要经过审核。除此之外，Master 用户还可以对 Developer 提交的代码进行评审，并最终决定是合并进主干还是退回重新修改。&lt;/li&gt;
&lt;li&gt;Developer 账户是这个项目的贡献者，它可以查看代码并下载代码，但不能直接提交代码，提交的代码需要经过 Master 审核后才能合并进主干。&lt;/li&gt;
&lt;li&gt;其他的角色可根据实际情况酌情使用，比如可以给 SQA 开通 Reporter 角色的账户，用来 report issue 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gitlab 默认的角色列表项目权限可参阅官方文档&lt;a href="https://docs.gitlab.com/ce/user/permissions.html#project"&gt;项目角色与权限&lt;/a&gt;。需要注意，这里的 Master 指的是用户在项目上的角色，而不是指代码的主干。&lt;/p&gt;
&lt;p&gt;&lt;img alt="设置项目组成员" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_project_member.png" /&gt;&lt;/p&gt;
&lt;p&gt;操作演练：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加一个用户作为 Master 账户&lt;/li&gt;
&lt;li&gt;添加一个用户作为 Developer 帐户&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="3-git-flow"&gt;3 Git Flow&lt;/h2&gt;
&lt;p&gt;Git Flow 是一种基于 Git 的开发流程。其主要思想是，以 Master 为主线，所有的新功能开发在 Branch 上完成，等开发完成后，合并到 Master 里。&lt;/p&gt;
&lt;p&gt;原则：&lt;strong&gt;Master 里包含的永远是稳定（至少经过初步测试和代码评审）的源代码。可以直接在 Master 上把代码进行部署（编译并发布给测试部的版本）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Git Flow" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_flow.png" /&gt;&lt;/p&gt;
&lt;p&gt;主要分成几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建分支&lt;/li&gt;
&lt;li&gt;在分支上提交代码&lt;/li&gt;
&lt;li&gt;创建 Merge Request&lt;/li&gt;
&lt;li&gt;代码评审&lt;/li&gt;
&lt;li&gt;合并到主干&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，我们来讨论几个典型的场景下的 Git FLow 开发模型。熟悉 Github 的同学可能对 Merge Request 这个称呼感到奇怪，实际上它就是 Pull Request，不同的叫法而已。&lt;/p&gt;
&lt;h3 id="31-master"&gt;3.1 Master 用户直接在主干上开发&lt;/h3&gt;
&lt;p&gt;这种开发模式一般用在一些&lt;strong&gt;不需要团队协作&lt;/strong&gt;的小功能的开发上。这种开发模式和 SVN 开发模式基本相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 下载代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git clone http://user1@192.168.56.101/user1/demo.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;2. 编写代码，验证后提交&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git commit -am &lt;span style="color: #BB4444"&gt;&amp;quot;My feature is ready&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3. 推送到主干&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git push
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;便捷与安全有时是相互矛盾的。这种开发模式虽然简洁，但没有强制的代码评审，是否采用需要根据实际情况考量。&lt;/p&gt;
&lt;p&gt;操作演练：由 Master 用户直接提交代码修改到主干&lt;/p&gt;
&lt;h3 id="32"&gt;3.2 新功能分支开发流程&lt;/h3&gt;
&lt;p&gt;这种工作一般在一个较大的新功能开发时使用，一般需要进行团队协作，即由几个人共同来开发。这是最经典的 Git Flow 开发流程，在 Bug Fix 时也可以使用这个开发模式。典型步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 创建功能开发分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建新功能分支，并把分支推送到远程代码仓库。这个动作也可以在 Gitlab 网页上操作。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git clone http://user1@192.168.56.101/user1/demo.git
&lt;span style="color: #AA22FF"&gt;cd &lt;/span&gt;demo
git checkout -b feature2
git push origin feature2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;2. 其他开发人员下载代码，并在分支上开发新功能&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git clone http://user2@192.168.56.101/user1/demo.git
git checkout feature2
git config user.name &lt;span style="color: #BB4444"&gt;&amp;quot;user2&amp;quot;&lt;/span&gt;
git config user.email &lt;span style="color: #BB4444"&gt;&amp;quot;user2@example.com&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3. 测试新功能并提交&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git commit -am &lt;span style="color: #BB4444"&gt;&amp;quot;Developer user2 for Feature 2&amp;quot;&lt;/span&gt;
git push
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;4. 创建 Merge Request&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;步骤 2 和 3 可以无限制次数地进行，直到新功能开发完成，并完成单元测试为止。当新功能开发完成后，需要在 Gitlab 网页上创建合并请求。提交 Merge Request 的目的是为了发起代码评审流程。&lt;/p&gt;
&lt;p&gt;&lt;img alt="合并请求" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_merge_request.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 代码评审&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;合并请求可以指定具有 Master 角色的用户进行 Review。如果 Review 通过，则直接会把新功能合并进代码主干。如果 Review 不通过，则评审人员可以直接关闭这个 Merge Request。等待开发者重新修改代码，并重新提交 Merge Request。&lt;/p&gt;
&lt;p&gt;&lt;img alt="代码评审" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_code_review.png" /&gt;&lt;/p&gt;
&lt;p&gt;评审过程中，可以直接在 Gitlab 网页上，对着代码写上评审意见。这些评审意见对应的开发者都会看到。&lt;/p&gt;
&lt;p&gt;&lt;img alt="代码评审意见" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_code_review_comments.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 更新本地代码副本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当新功能合并到代码主干后，其他开发人员可以更新服务器上的最新代码到自己本地的工作副本中。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git pull
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;操作演练：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Master 用户创建一个远程分支&lt;/li&gt;
&lt;li&gt;Developer user2 下载代码，切换到开发分支，并提交代码到开发分支&lt;/li&gt;
&lt;li&gt;Developer user3 下载代码，切换到开发分支，并提交代码到开发分支&lt;/li&gt;
&lt;li&gt;Master user1 下载代码，切换到开发分支，并提交代码到开发分支&lt;/li&gt;
&lt;li&gt;创建合并请求&lt;/li&gt;
&lt;li&gt;代码评审&lt;/li&gt;
&lt;li&gt;评审不过，发回重新修改&lt;/li&gt;
&lt;li&gt;Developer user2 重新修改代码，并提交到开发分支&lt;/li&gt;
&lt;li&gt;重新发起合并请求&lt;/li&gt;
&lt;li&gt;代码评审&lt;/li&gt;
&lt;li&gt;评审通过，合并到代码主干&lt;/li&gt;
&lt;li&gt;删除开发分支&lt;/li&gt;
&lt;li&gt;开发者更新本地代码&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="33-developer"&gt;3.3 Developer 用户直接在主干上开发&lt;/h3&gt;
&lt;p&gt;这种开发模式一般用在一些&lt;strong&gt;不需要协作&lt;/strong&gt;的小功能开发或 Bug 修复上。由于 &lt;strong&gt;Developer 用户没有权限把修改的代码直接提交到主干&lt;/strong&gt;上。所以，需要先 Fork 一个本地分支，然后本地修改后，发起一个 Merge Request ，由 Master 用户进行代码评审，合格后由 Master 用户把代码合并到主干。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 开发者 Fork 一份基线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一步骤必须在 Gitlab 网页端进行。比如，我们使用 user2 Fork 一个由 user1 创建的 demo 项目，则其 Git 地址为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;http://user2@192.168.56.101/user2/demo.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意和原来直接从 user1 的 demo 项目的 Git 地址比较 &lt;code&gt;http://user2@192.168.56.101/user1/demo.git&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 开发者下载 Fork 的基线代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git clone http://user2@192.168.56.101/user2/demo.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;3. 开发者修改代码，测试，并提交&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git push origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;4. 提交 Merge Request&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一步骤必须在 Gitlab 网页上进行。点击 &lt;code&gt;Merge Requests&lt;/code&gt; -&amp;gt; &lt;code&gt;New Merge Request&lt;/code&gt; 来创建一个合并请求。需要指定合并请求的源分支和目的分支。&lt;/p&gt;
&lt;p&gt;&lt;img alt="合并请求" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_merge_request.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 代码评审&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指定的代码评审者可以查看这个合并请求，并选择直接关闭或者合并到主干。如果关闭，则一般会写上评审不通过的理由，然后由开发者重新修改，并重新提交合并请求。如果通过评审，则代码会合并到主干上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 开发者更新本地代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 Developer 角色的开发者 Fork 了一份代码后，本地 Git 仓库里实际是“追踪”开发者 Fork 出来的这份代码，而不是原始的代码仓库里的代码。如下所示：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;git remote -v
origin  http://user2@192.168.56.101/user2/demo.git &lt;span style="color: #666666"&gt;(&lt;/span&gt;fetch&lt;span style="color: #666666"&gt;)&lt;/span&gt;
origin  http://user2@192.168.56.101/user2/demo.git &lt;span style="color: #666666"&gt;(&lt;/span&gt;push&lt;span style="color: #666666"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时要怎么样把原始的代码仓库里的代码更新到本地呢？比如，另外一个开发者合并了一个新的功能到原始代码的主干上，怎么样把这个代码更新到本地呢？进而更新到 Fork 出来的代码仓库里呢？可以使用以下的方法：&lt;/p&gt;
&lt;p&gt;首先，把原始的 Git 代码仓库地址添加到本地：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;git remote add upstream http://user2@192.168.56.101/user1/demo.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看添加后的情况：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;git remote -v
origin  http://user2@192.168.56.101/user2/demo.git &lt;span style="color: #666666"&gt;(&lt;/span&gt;fetch&lt;span style="color: #666666"&gt;)&lt;/span&gt;
origin  http://user2@192.168.56.101/user2/demo.git &lt;span style="color: #666666"&gt;(&lt;/span&gt;push&lt;span style="color: #666666"&gt;)&lt;/span&gt;
upstream  http://user2@192.168.56.101/user1/demo.git &lt;span style="color: #666666"&gt;(&lt;/span&gt;fetch&lt;span style="color: #666666"&gt;)&lt;/span&gt;
upstream  http://user2@192.168.56.101/user1/demo.git &lt;span style="color: #666666"&gt;(&lt;/span&gt;push&lt;span style="color: #666666"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着，把原始 Git 代码仓库里的代码下载下来，只是把数据库下载下来而已，并没有合并到本地分支：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git fetch upstream
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下一步，把下载下来的代码合并到本地分支：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git merge upstream/master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行这一步时需要注意，需要确保本地没有未提交的修改，否则到时处理代码冲突会比较麻烦。上面的两条指令也可以由一条完成，即 &lt;code&gt;git pull upstream master&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;最后，把从原始 Git 代码仓库合并下来的代码，提交到 Fork 出来的远程代码仓库里。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;git commit -am &lt;span style="color: #BB4444"&gt;&amp;quot;Merge from upstream&amp;quot;&lt;/span&gt;
git push origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;操作演练：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发者 Fork 一份基线&lt;/li&gt;
&lt;li&gt;开发者下载 Fork 出来的基线代码到本地&lt;/li&gt;
&lt;li&gt;开发者修改代码并提交&lt;/li&gt;
&lt;li&gt;开发者再次修改代码，并再次提交&lt;/li&gt;
&lt;li&gt;开发者推送本地提交到 Fork 出来的远程代码仓库上&lt;/li&gt;
&lt;li&gt;开发者发起 Merge Request&lt;/li&gt;
&lt;li&gt;代码评审，不通过，关闭 Merge Request&lt;/li&gt;
&lt;li&gt;开发者根据评审意见重新修改代码，并提交，然后推送到远程代码仓库&lt;/li&gt;
&lt;li&gt;开发者发起 Merge Request&lt;/li&gt;
&lt;li&gt;代码评审，通过，合并到主干&lt;/li&gt;
&lt;li&gt;其他开发者提交代码到主干&lt;/li&gt;
&lt;li&gt;开发者更新本地代码到原始主干，并且使 Fork 出来的远程代码仓库与原始主干保持同步&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="4"&gt;4 分支及标签管理&lt;/h2&gt;
&lt;p&gt;分支的目的是为了做代码隔离。典型的代码隔离如前面介绍的新功能开发分支，另外一个典型的目的是为己发布的产品拉独立的分支来维护，或者虽然产品还没发布，但由于并行开发多个产品线，在产品测试后期，就拉出独立分支，隔离主干的频繁变动。这背后的原因是由于不同的分支代码的质量和稳定性是不一样的。一般来讲，新功能开发分支稳定性最差，因为只有开发者做了单元测试而已。其次是主干，做了代码评审，如果有自动化测试系统，那么还会做设备自动测试和系统自动测试。一般情况下，产品的集成测试版本以及前面几个系统测试版本会在主干上直接编译。最稳定的是产品分支，己发布或即将发布的产品的测试力度和强度是最大的，其稳定性也是最好的。综上，我们开发流程里采用的分支类型包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发分支：为了开发新功能而临时创建的，当合并进主干后，这种分支可以删除&lt;/li&gt;
&lt;li&gt;代码主干：一直存在，且在 Gitlab 里具有&lt;strong&gt;保护属性&lt;/strong&gt;，即普通的 Developer 要修改这个分支上的代码时需要经过评审&lt;/li&gt;
&lt;li&gt;产品分支：产品即将发布或发布后创建，然后一直存在，且在 Gitlab 里具有保护属性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="41"&gt;4.1 产品分支管理&lt;/h3&gt;
&lt;p&gt;假设，我们有一个产品已经经过了 8 轮的系统测试，目前软件整体上比较稳定，按计划再测试 2 轮即会正式发布。而当前，主干上频繁地有新功能合并进来，这些新功能又是这个产品不需要的。产品软件负责人经过讨论，决定拉出独立的产品分支来管理，以避免新合并进来的新功能由于稳定性较差，测试不全面，影响即将发布的产品的质量。&lt;/p&gt;
&lt;p&gt;在创建功能开发分支时，我们介绍了命令行创建远程分支的方法，实际上在 Gitlab 网页上操作更简单。&lt;/p&gt;
&lt;p&gt;&lt;img alt="创建分支" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_create_branch.png" /&gt;&lt;/p&gt;
&lt;p&gt;需要注意，默认情况下创建出来的分支是不处于保护状态的。即任何的 Developer 角色的人都可以推送代码到这个分支，这是我们不希望看到的。越到项目后期，代码的修改越需要谨慎地进行评审。所以，创建完分支，需要把分支设置为 Proteced 属性，这样可以对产品分支的代码修改进行严格地控制。&lt;/p&gt;
&lt;p&gt;&lt;img alt="产品分支保护" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_branch_protected.png" /&gt;&lt;/p&gt;
&lt;p&gt;大家可以看到，这里设置的&lt;strong&gt;保护级别比主干更高&lt;/strong&gt;，即没有人能直接推送代码到这个分支上。任何人，包括 Master 角色的开发者提交代码时，也只能通过创建 Bug Fix 分支，然后在分支上修改代码，验证，最后通过创建 Merge Request 来强制进行代码评审。当然，Master 角色的开发者可以自己评审自己的代码，但起码强制进行了二次确认。相应地，为了安全，也可以把主干的保护级别设置成和产品分支的保护级别一样，这样就没有人能直接向主干推送代码，都必须通过 Merge Request 进行代码评审后才可以合并代码到主干上。&lt;/p&gt;
&lt;p&gt;创建完分支后，后续&lt;strong&gt;这个产品的版本就直接从这个分支上编译，而不再从主干上编译&lt;/strong&gt;。假设，这个时候这个产品上修改了一个 Bug，并提交到了这个分支上。那么这个提交要不要也合并到主干上呢？答案是原则上需要合并到主干上，但也不能强制要求。如果这个 Bug 只和这个产品相关，而和其他产品无关，而且&lt;strong&gt;提交到主干上需要考虑不同产品的兼容性问题，复杂度增加很多&lt;/strong&gt;，此时可以允许不提交到主干。如果是最终决策不提交到主干，这个提交需要在 commit log 里注明 &lt;strong&gt;PSBF:&lt;/strong&gt; (Product Specific Bug Fix) 前缀，以方便以后根据前缀来查询。但如果这个 Bug 是个普遍存在的 Bug ，主干上的其他衍生产品也会有这样的 Bug，则这个 Bug 的修改&lt;strong&gt;必须&lt;/strong&gt;合并到主干上。由于提交到产品分支的修改必须强制经过评审，所以在评审的时候可以告诉开发者是否需要把这个修改合并进主干。&lt;/p&gt;
&lt;p&gt;另外一个问题，如果一个新功能分支合并到主干上了，这个时候一般是不需要合并到产品分支的。但如果主干上合并进了一个 Bug Fix 修改，此时要不要合并进产品分支呢？答案是看情况，不能一概而论。如果这个 Bug Fix 和具体的产品无关，则不需要合并进产品分支。如果这个 Bug Fix 和具体的产品相关，但不严重，属于 normal 或 minor 级别的 Bug，则根据产品的生命周期判断，可以合并也可以不合并进产品分支。如果这个 Bug Fix 和具体的产品相关，且非常严重，则&lt;strong&gt;必须&lt;/strong&gt;合并进产品分支。经过讨论后，还可能需要马上发起一个 ECR/ECN 流程来下发新软件。&lt;/p&gt;
&lt;p&gt;&lt;img alt="合并到产品分支" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_merge_to_product_branch.png" /&gt;&lt;/p&gt;
&lt;p&gt;操作演练：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个产品分支，并设置相应的保护级别&lt;/li&gt;
&lt;li&gt;Master 角色的用户提交 Bug 修改流程，演示强制代码评审的效果&lt;/li&gt;
&lt;li&gt;主干上合并了一个严重的问题修改，同时也需要合并到产品分支&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="42"&gt;4.2 标签管理&lt;/h3&gt;
&lt;p&gt;标签的目的是为了做标记，它能唯一地标识代码仓库中某个“时刻”的代码。典型地，所有的正式发布的软件版本会都会打上标签，以方便以后追溯。再如特单版本正式发布后，也会打上标签。&lt;strong&gt;标签的命名和软件命名采用相同的规则&lt;/strong&gt;，这样方便从己发布的软件直接找到对应的源码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="代码对比" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/git_tags.png" /&gt;&lt;/p&gt;
&lt;h2 id="5"&gt;5 其他&lt;/h2&gt;
&lt;p&gt;有一个非常重要的原则，需要强调，开发者需要尽量确保自己 Fork 出来的基线以及本地的代码副本和原基线的主干保持同步。即需要经常更新主干上的代码。否则，会给后续的代码评审以及代码合并造成很大的无谓的工作量。其次，为了减少代码合并时的工作量，推荐开发者在提交 Merge Request 前，把自己的工作分支更新到主干代码上，解决完冲突，验证完代码有效性后，再提交 Merge Request。这里也提醒代码评审者注意，如果评审一个 Merge Request 时，发现代码有冲突，不能进行 Fast-Forward 合并，而需要手动合并冲突，则开发者必定没有在提交 Merge Request 时更新到最新的主干上。此时代码评审者完全可以拒绝这个合并请求，并要求开发者更新到最新主干上，合并完冲突，验证通过后重新提交 Merge Request。&lt;/p&gt;
&lt;p&gt;推荐阅读阮一峰的两篇关于 Git 的博客，简洁明了，清晰易懂。分别是&lt;a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html"&gt;《Git 工作流程》&lt;/a&gt;和&lt;a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html"&gt;《Git远程操作详解》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于 Git 的系统性基础知识，可参阅 &lt;a href="https://git-scm.com/book/zh/v2"&gt;Pro Git&lt;/a&gt; 这本开源图书。关于 Windows 平台的 Git 客户端，如果喜欢命令行的用户，可使用 &lt;a href="https://git-for-windows.github.io"&gt;Git for windows&lt;/a&gt;。对于习惯 TortoiseSVN 客户端的用户，推荐使用 &lt;a href="https://tortoisegit.org"&gt;TortoiseGit&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;</summary><category term="tools"></category></entry><entry><title>利用朴素贝叶斯算法进行文档分类</title><link href="http://blog.kamidox.com/docs-classification.html" rel="alternate"></link><updated>2017-05-07T23:43:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2017-05-07:docs-classification.html</id><summary type="html">&lt;p&gt;在 scikit-learn 里，朴素贝叶斯算法在 &lt;code&gt;sklearn.naive_bayes&lt;/code&gt; 包里实现，包含了本章介绍的几种典型的概率分布算法。其中 &lt;code&gt;GaussianNB&lt;/code&gt; 实现了高斯分布的朴素贝叶斯算法，&lt;code&gt;MultinomialNB&lt;/code&gt; 实现了多项式分布的朴素贝叶斯算法，&lt;code&gt;BernoulliNB&lt;/code&gt; 实现了伯努利分布的朴素贝叶斯算法。本文我们用 &lt;code&gt;MultinomialNB&lt;/code&gt; 来实现文档自动分类。如果你不熟悉朴素贝叶斯算法，可参阅笔者的另外一篇博客&lt;a href="http://blog.kamidox.com/naive-bayes.html"&gt;零基础学习朴素贝叶斯算法&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="1"&gt;1 获取数据集&lt;/h2&gt;
&lt;p&gt;本节使用的数据集来自 mlcomp.org 上的 &lt;a href="http://mlcomp.org/datasets/379"&gt;20news-18828&lt;/a&gt;，免费注册后即可下载。下载完数据集后，可以解压解压到 &lt;code&gt;~/code/datasets/mlcomp/&lt;/code&gt; 目录下，解压后会在 &lt;code&gt;~/code/datasets/mlcomp&lt;/code&gt; 下生成一个名为 &lt;code&gt;379&lt;/code&gt; 的目录，其目录下包含三个子目录和一个名为 &lt;code&gt;metadata&lt;/code&gt; 的介绍文件：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;&lt;span style="color: #AA22FF"&gt;cd&lt;/span&gt; ~/code/datasets/mlcomp
&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;ls 379
metadata  raw  &lt;span style="color: #AA22FF"&gt;test  &lt;/span&gt;train
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们将使用 &lt;code&gt;train&lt;/code&gt; 子目录下的文档进行模型训练，然后使用 &lt;code&gt;test&lt;/code&gt; 子目录下的文档进行模型测试。&lt;code&gt;train&lt;/code&gt; 子目录下包含 20 个子目录，每个子目录代表一种文档的类型，子目录下的所有文档都是属于目录名称所标识的文档类型。读者朋友可以随意浏览数据集，以便对数据集有一个感性的认识。比如 &lt;code&gt;datasets/mlcomp/379/train/rec.autos/6652-103421&lt;/code&gt; ，这是一个纯广本文件，可以使用任何文本编辑器打开。这是一个讨论汽车主题的帖子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hahahahahaha.  &lt;em&gt;gasp&lt;/em&gt;  &lt;em&gt;pant&lt;/em&gt;  Hm, I&amp;rsquo;m not sure whether the above&lt;br /&gt;
was just a silly remark or a serious remark.  But in case there are&lt;br /&gt;
some misconceptions, I think Henry Robertson hasn&amp;rsquo;t updated his data&lt;br /&gt;
file on Korea since&amp;hellip;mid 1970s.  Owning a car in Korea is no longer&lt;br /&gt;
a luxury.  Most middle class people in Korea can afford a car and do&lt;br /&gt;
have at least one car.  The problem in Korea, especially in Seoul, is&lt;br /&gt;
that there are just so many privately-owned cars, as well as taxis and&lt;br /&gt;
buses, the rush-hour has become a 24 hour phenomenon and that there is&lt;br /&gt;
no place to park.  Last time I heard, back in January, the Kim Administration&lt;br /&gt;
wanted to legislate a law requireing a potential car owner to provide&lt;br /&gt;
his or her own parking area, just like they do in Japan.&lt;/p&gt;
&lt;p&gt;Also, Henry would be glad to know that Hyundai isn&amp;rsquo;t the only&lt;br /&gt;
car manufacturer in Korea.  Daewoo has always manufactured cars and&lt;br /&gt;
I believe Kia is back in business as well.  Imported cars, such as&lt;br /&gt;
Mercury Sable are becoming quite popular as well, though they are still&lt;br /&gt;
quite expensive.&lt;/p&gt;
&lt;p&gt;Finally, please ignore Henry&amp;rsquo;s posting about Korean politics&lt;br /&gt;
and bureaucracy.  He&amp;rsquo;s quite uninformed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="2"&gt;2 文档的数学表达&lt;/h2&gt;
&lt;p&gt;怎么样把一个文档表达为计算机可以理解并处理的信息？这是自然语言处理里的一个重要课题，完整的内容可以写成鸿篇巨著。本节简单介绍 TF-IDF 的原理，以便读者更好地理解本文介绍的实例。&lt;/p&gt;
&lt;p&gt;TF-IDF 是一种统计方法，用以评估一个词语对于一份文档的重要程度。TF 表示&lt;strong&gt;词频&lt;/strong&gt; (Term Frequency)，对一份文档而言，词频为特定词语在这篇文档里出现的次数除以文档的词语总数。比如一篇文档总共有 1000 个词，其中 “朴素贝叶斯” 出现了 5 次，“的” 出现了 25 次，“应用” 出现了 12 次，那么它们的词频分别是 0.005, 0.025, 0.012。&lt;/p&gt;
&lt;p&gt;IDF 表示一个词的&lt;strong&gt;逆向文档频率指数&lt;/strong&gt; (Inverse Document Frequency) ，可以由总文档数目除以包含该词语的文档的数目，再将得到的商取对数得到，它表达的是词语的权重指数。比如，我们的数据集总共有 10000 篇文档，其中 “朴素贝叶斯” 只出现在 10 篇文档中，则其权重指数 $IDF = log(\frac {10000} {10}) = 3$ 。“的” 在所有的文档中都出现，则其权重指数 $IDF = log(1) = 0$ 。“应用” 在 1000 篇文档中出现，则其权重指数 $IDF = log(\frac {10000} {1000}) = 1$ 。&lt;/p&gt;
&lt;p&gt;计算出每个词的词频和权重指数后，两者相乘，即可得到这个词在文档中的重要程度。词语的重要性随着它在文档中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。关于 TF-IDF 在搜索引擎上的应用，可参阅吴军老师的《数学之美》里的《如何确定网页和查询的相关性》一文。&lt;/p&gt;
&lt;p&gt;有了 TF-IDF 这个工具，我们就可以把一篇文档转换为一个向量。首先，可以从我们的数据集（在自然语言处理领域，也称为 corpus ，即语料库）里提取出所有出现的词语，我们称为&lt;strong&gt;词典&lt;/strong&gt;。假设词典里总共有 10000 个词语，则每个文档都可转化为一个 10000 维的向量。其次，针对我们要转换的文档里出现的每个词语，都去计算其 TF-IDF 的值，并把这个值填入文档向量里，这个词所对应的元素上。这样就完成了把一篇文档转换为一个向量的过程。一个文档往往只会由词典里的一小部分词语构成，这就意味着这个这个向量里大部分元素都是零。&lt;/p&gt;
&lt;p&gt;所幸，上述过程我们不需要自己写代码完成，scikit-learn 软件包里实现了把文档转换为向量的过程。首先，我们把训练用的语料库读入内存：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;time&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; time
&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;sklearn.datasets&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; load_files

&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;loading train dataset ...&amp;quot;&lt;/span&gt;)
t &lt;span style="color: #666666"&gt;=&lt;/span&gt; time()
news_train &lt;span style="color: #666666"&gt;=&lt;/span&gt; load_files(&lt;span style="color: #BB4444"&gt;&amp;#39;datasets/mlcomp/379/train&amp;#39;&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;summary: {0} documents in {1} categories.&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(
    &lt;span style="color: #AA22FF"&gt;len&lt;/span&gt;(news_train&lt;span style="color: #666666"&gt;.&lt;/span&gt;data), &lt;span style="color: #AA22FF"&gt;len&lt;/span&gt;(news_train&lt;span style="color: #666666"&gt;.&lt;/span&gt;target_names)))
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;done in {0} seconds&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(time() &lt;span style="color: #666666"&gt;-&lt;/span&gt; t))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们的代码保存在 &lt;code&gt;~/code/&lt;/code&gt; 目录下，其相对路径 &lt;code&gt;datasets/mlcomp/379/train&lt;/code&gt; 目录下放的就是我们的语料库，其中包含 20 个子目录，每个子目录的名字表示的是文档的类别，子目录下包含这种类别的所有文档。&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_files.html"&gt;load_files()&lt;/a&gt; 函数会从这个目录里把所有的文档都读入内存，并且自动根据所在的子目录名称打上标签。其中，&lt;code&gt;news_train.data&lt;/code&gt; 是一个数组，里面包含了所有文档的文本信息。&lt;code&gt;news_train.target&lt;/code&gt; 也是一个数组，包含了所有文档所属的类别，而 &lt;code&gt;news_train.target_names&lt;/code&gt; 则是的类别的名称，因此，如果我们想知道第一篇文档所属的类别名称，只需要通过代码 &lt;code&gt;news_train.target_names[news_train.target[0]]&lt;/code&gt; 即可得到。&lt;/p&gt;
&lt;p&gt;上述代码在笔者电脑上的输出是：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;loading train dataset &lt;span style="color: #666666"&gt;...&lt;/span&gt;
summary: &lt;span style="color: #666666"&gt;13180&lt;/span&gt; documents &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;20&lt;/span&gt; categories&lt;span style="color: #666666"&gt;.&lt;/span&gt;
done &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;0.212177991867&lt;/span&gt; seconds
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不难看到，我们的语料库里，总共有 13180 个文档，其中分成 20 个类别。接着，我们需要把这些文档全部转换为由 TF-IDF 表达的权重信息构成的向量：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;sklearn.feature_extraction.text&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; TfidfVectorizer

&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;vectorizing train dataset ...&amp;quot;&lt;/span&gt;)
t &lt;span style="color: #666666"&gt;=&lt;/span&gt; time()
vectorizer &lt;span style="color: #666666"&gt;=&lt;/span&gt; TfidfVectorizer(encoding&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;latin-1&amp;#39;&lt;/span&gt;)
X_train &lt;span style="color: #666666"&gt;=&lt;/span&gt; vectorizer&lt;span style="color: #666666"&gt;.&lt;/span&gt;fit_transform((d &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; d &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; news_train&lt;span style="color: #666666"&gt;.&lt;/span&gt;data))
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;n_samples: &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%d&lt;/span&gt;&lt;span style="color: #BB4444"&gt;, n_features: &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%d&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;%&lt;/span&gt; X_train&lt;span style="color: #666666"&gt;.&lt;/span&gt;shape)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;number of non-zero features in sample [{0}]: {1}&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(
    news_train&lt;span style="color: #666666"&gt;.&lt;/span&gt;filenames[&lt;span style="color: #666666"&gt;0&lt;/span&gt;], X_train[&lt;span style="color: #666666"&gt;0&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;getnnz()))
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;done in {0} seconds&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(time() &lt;span style="color: #666666"&gt;-&lt;/span&gt; t))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，&lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html"&gt;TfidfVectorizer&lt;/a&gt; 类是用来把所有的文档转换为矩阵，该矩阵每行都代表一个文档，一行中的每个元素代表一个对应的词语的重要性，词语的重要性由 TF-IDF 来表示。熟悉 scikit-learn API 的读者应该清楚，其 &lt;code&gt;fit_transform()&lt;/code&gt; 方法是 &lt;code&gt;fit()&lt;/code&gt; 和 &lt;code&gt;transform()&lt;/code&gt; 合并起来。其中，&lt;code&gt;fit()&lt;/code&gt; 会先完成语料库分析，提取词典等操作，&lt;code&gt;transform()&lt;/code&gt; 会把对每篇文档转换为向量，最终构成一个矩阵，保存在 &lt;code&gt;X_train&lt;/code&gt; 变量里。这段代码在笔者电脑上的输出为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;vectorizing train dataset &lt;span style="color: #666666"&gt;...&lt;/span&gt;
n_samples: &lt;span style="color: #666666"&gt;13180&lt;/span&gt;, n_features: &lt;span style="color: #666666"&gt;130274&lt;/span&gt;
number of non&lt;span style="color: #666666"&gt;-&lt;/span&gt;zero features &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; sample
  [datasets&lt;span style="color: #666666"&gt;/&lt;/span&gt;mlcomp&lt;span style="color: #666666"&gt;/379/&lt;/span&gt;train&lt;span style="color: #666666"&gt;/&lt;/span&gt;talk&lt;span style="color: #666666"&gt;.&lt;/span&gt;politics&lt;span style="color: #666666"&gt;.&lt;/span&gt;misc&lt;span style="color: #666666"&gt;/17860-178992&lt;/span&gt;]: &lt;span style="color: #666666"&gt;108&lt;/span&gt;
done &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;4.15024495125&lt;/span&gt; seconds
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由程序的输出，我们可以知道，我们的词典总共有 130274 个词语，即每篇文档都可转换为一个 130274 维的向量（这是一个巨大的向量）。第一篇文档中，只有 108 个非零元素，即这篇文章由 108 个单词组成，其单词数大于等于 108 个（因为有些词可出现多次）。在这篇文档中出现的这 108 个单词的 TF-IDF 值会被计算出来，并保存在向量中的指定位置上。&lt;code&gt;X_train&lt;/code&gt; 是一个维度为 13180 x 130274 的稀疏矩阵（这是一个巨稀疏的矩阵）。&lt;/p&gt;
&lt;h2 id="3"&gt;3 模型训练&lt;/h2&gt;
&lt;p&gt;费了好些功夫，终于把文档数据转换为 scikit-learn 里典型的训练数据集矩阵：矩阵的每一行表示一个数据样本，矩阵的每一列表示一个特征。接着，我们可以直接使用 &lt;code&gt;MultinomialNB&lt;/code&gt; 来对数据集进行训练：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;sklearn.naive_bayes&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; MultinomialNB

&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;traning models ...&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(time() &lt;span style="color: #666666"&gt;-&lt;/span&gt; t))
t &lt;span style="color: #666666"&gt;=&lt;/span&gt; time()
y_train &lt;span style="color: #666666"&gt;=&lt;/span&gt; news_train&lt;span style="color: #666666"&gt;.&lt;/span&gt;target
clf &lt;span style="color: #666666"&gt;=&lt;/span&gt; MultinomialNB(alpha&lt;span style="color: #666666"&gt;=0.0001&lt;/span&gt;)
clf&lt;span style="color: #666666"&gt;.&lt;/span&gt;fit(X_train, y_train)
train_score &lt;span style="color: #666666"&gt;=&lt;/span&gt; clf&lt;span style="color: #666666"&gt;.&lt;/span&gt;score(X_train, y_train)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;train score: {0}&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(train_score))
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;done in {0} seconds&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(time() &lt;span style="color: #666666"&gt;-&lt;/span&gt; t))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 &lt;code&gt;alpha&lt;/code&gt; 表示平滑参数，其值越小，越容易造成过拟合，值太大，容易造成欠拟合。这段代码在笔者电脑上的输出为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;traning models &lt;span style="color: #666666"&gt;...&lt;/span&gt;
train score: &lt;span style="color: #666666"&gt;0.997875569044&lt;/span&gt;
done &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;0.274363040924&lt;/span&gt; seconds
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着，我们加载测试数据集，并拿一篇文档来预测看看是否准确。测试数据集在 &lt;code&gt;~/code/datasets/mlcomp/379/test&lt;/code&gt; 目录下，我们用上文介绍的相同的方法，先加载数据集：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;loading test dataset ...&amp;quot;&lt;/span&gt;)
t &lt;span style="color: #666666"&gt;=&lt;/span&gt; time()
news_test &lt;span style="color: #666666"&gt;=&lt;/span&gt; load_files(&lt;span style="color: #BB4444"&gt;&amp;#39;datasets/mlcomp/379/test&amp;#39;&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;summary: {0} documents in {1} categories.&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(
    &lt;span style="color: #AA22FF"&gt;len&lt;/span&gt;(news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;data), &lt;span style="color: #AA22FF"&gt;len&lt;/span&gt;(news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;target_names)))
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;done in {0} seconds&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(time() &lt;span style="color: #666666"&gt;-&lt;/span&gt; t))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在笔者的电脑上的输出为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;loading test dataset &lt;span style="color: #666666"&gt;...&lt;/span&gt;
summary: &lt;span style="color: #666666"&gt;5648&lt;/span&gt; documents &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;20&lt;/span&gt; categories&lt;span style="color: #666666"&gt;.&lt;/span&gt;
done &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;0.117918014526&lt;/span&gt; seconds
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可见，我们的测试数据集总共有 5648 篇文档。接着，我们把文档向量化：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;vectorizing test dataset ...&amp;quot;&lt;/span&gt;)
t &lt;span style="color: #666666"&gt;=&lt;/span&gt; time()
X_test &lt;span style="color: #666666"&gt;=&lt;/span&gt; vectorizer&lt;span style="color: #666666"&gt;.&lt;/span&gt;transform((d &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; d &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;data))
y_test &lt;span style="color: #666666"&gt;=&lt;/span&gt; news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;target
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;n_samples: &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%d&lt;/span&gt;&lt;span style="color: #BB4444"&gt;, n_features: &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%d&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;%&lt;/span&gt; X_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;shape)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;number of non-zero features in sample [{0}]: {1}&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(
    news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;filenames[&lt;span style="color: #666666"&gt;0&lt;/span&gt;], X_test[&lt;span style="color: #666666"&gt;0&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;getnnz()))
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;done in &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%f&lt;/span&gt;&lt;span style="color: #BB4444"&gt;s&amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;%&lt;/span&gt; (time() &lt;span style="color: #666666"&gt;-&lt;/span&gt; t))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里需要注意，&lt;code&gt;vectorizer&lt;/code&gt; 变量是我们处理训练数据集时用到的广本向量化的类 TfidfVectorizer 的实例，此处我们只需要调用 &lt;code&gt;transform()&lt;/code&gt; 进行 TF-IDF 数值计算即可，不需要再调用 &lt;code&gt;fit()&lt;/code&gt; 进行语料库分析了。这段代码在笔者电脑上的输出为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;vectorizing test dataset &lt;span style="color: #666666"&gt;...&lt;/span&gt;
n_samples: &lt;span style="color: #666666"&gt;5648&lt;/span&gt;, n_features: &lt;span style="color: #666666"&gt;130274&lt;/span&gt;
number of non&lt;span style="color: #666666"&gt;-&lt;/span&gt;zero features &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; sample
    [datasets&lt;span style="color: #666666"&gt;/&lt;/span&gt;mlcomp&lt;span style="color: #666666"&gt;/379/&lt;/span&gt;test&lt;span style="color: #666666"&gt;/&lt;/span&gt;rec&lt;span style="color: #666666"&gt;.&lt;/span&gt;autos&lt;span style="color: #666666"&gt;/7429-103268&lt;/span&gt;]: &lt;span style="color: #666666"&gt;61&lt;/span&gt;
done &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;2.915759&lt;/span&gt;s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，我们的测试数据集也转换为一个维度为 5648 x 130274 的稀疏矩阵。我们可以取测试数据集里第一篇文档初步验证一下，看看我们训练出来的模型能否正确地预测这个文档所属的类别：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;pred &lt;span style="color: #666666"&gt;=&lt;/span&gt; clf&lt;span style="color: #666666"&gt;.&lt;/span&gt;predict(X_test[&lt;span style="color: #666666"&gt;0&lt;/span&gt;])
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;predict: {0} is in category {1}&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(
    news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;filenames[&lt;span style="color: #666666"&gt;0&lt;/span&gt;], news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;target_names[pred[&lt;span style="color: #666666"&gt;0&lt;/span&gt;]]))
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;actually: {0} is in category {1}&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;format(
    news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;filenames[&lt;span style="color: #666666"&gt;0&lt;/span&gt;], news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;target_names[news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;target[&lt;span style="color: #666666"&gt;0&lt;/span&gt;]]))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段代码在笔者电脑上的输出为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;predict: datasets&lt;span style="color: #666666"&gt;/&lt;/span&gt;mlcomp&lt;span style="color: #666666"&gt;/379/&lt;/span&gt;test&lt;span style="color: #666666"&gt;/&lt;/span&gt;rec&lt;span style="color: #666666"&gt;.&lt;/span&gt;autos&lt;span style="color: #666666"&gt;/7429-103268&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;is&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; category rec&lt;span style="color: #666666"&gt;.&lt;/span&gt;autos
actually: datasets&lt;span style="color: #666666"&gt;/&lt;/span&gt;mlcomp&lt;span style="color: #666666"&gt;/379/&lt;/span&gt;test&lt;span style="color: #666666"&gt;/&lt;/span&gt;rec&lt;span style="color: #666666"&gt;.&lt;/span&gt;autos&lt;span style="color: #666666"&gt;/7429-103268&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;is&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; category rec&lt;span style="color: #666666"&gt;.&lt;/span&gt;autos
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看来预测的和实际的是相符的。&lt;/p&gt;
&lt;h2 id="4"&gt;4 模型评价&lt;/h2&gt;
&lt;p&gt;显然，我们不能通过一个样本的预测来评价模型的准确性。我们需要对模型有个全方位的评价，所幸 scikit-learn 软件包提供了全方位的模型评价工具。&lt;/p&gt;
&lt;p&gt;首先，我们需要对测试数据集进行预测：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;predicting test dataset ...&amp;quot;&lt;/span&gt;)
t0 &lt;span style="color: #666666"&gt;=&lt;/span&gt; time()
pred &lt;span style="color: #666666"&gt;=&lt;/span&gt; clf&lt;span style="color: #666666"&gt;.&lt;/span&gt;predict(X_test)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;done in &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%f&lt;/span&gt;&lt;span style="color: #BB4444"&gt;s&amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;%&lt;/span&gt; (time() &lt;span style="color: #666666"&gt;-&lt;/span&gt; t0))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在笔者的电脑上输出：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;predicting test dataset &lt;span style="color: #666666"&gt;...&lt;/span&gt;
done &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;0.090978&lt;/span&gt;s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着，我们使用 &lt;code&gt;classification_report()&lt;/code&gt; 函数来查看一下针对每个类别的预测准确性：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;sklearn.metrics&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; classification_report

&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;classification report on test set for classifier:&amp;quot;&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(clf)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(classification_report(y_test, pred,
                            target_names&lt;span style="color: #666666"&gt;=&lt;/span&gt;news_test&lt;span style="color: #666666"&gt;.&lt;/span&gt;target_names))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在笔者电脑上的输出为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;classification report on test &lt;span style="color: #AA22FF"&gt;set&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; classifier:
MultinomialNB(alpha&lt;span style="color: #666666"&gt;=0.0001&lt;/span&gt;, class_prior&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;, fit_prior&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
                          precision    recall  f1&lt;span style="color: #666666"&gt;-&lt;/span&gt;score   support

             alt&lt;span style="color: #666666"&gt;.&lt;/span&gt;atheism       &lt;span style="color: #666666"&gt;0.90&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.91&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.91&lt;/span&gt;       &lt;span style="color: #666666"&gt;245&lt;/span&gt;
           comp&lt;span style="color: #666666"&gt;.&lt;/span&gt;graphics       &lt;span style="color: #666666"&gt;0.80&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.90&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.85&lt;/span&gt;       &lt;span style="color: #666666"&gt;298&lt;/span&gt;
 comp&lt;span style="color: #666666"&gt;.&lt;/span&gt;os&lt;span style="color: #666666"&gt;.&lt;/span&gt;ms&lt;span style="color: #666666"&gt;-&lt;/span&gt;windows&lt;span style="color: #666666"&gt;.&lt;/span&gt;misc       &lt;span style="color: #666666"&gt;0.82&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.79&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.80&lt;/span&gt;       &lt;span style="color: #666666"&gt;292&lt;/span&gt;
comp&lt;span style="color: #666666"&gt;.&lt;/span&gt;sys&lt;span style="color: #666666"&gt;.&lt;/span&gt;ibm&lt;span style="color: #666666"&gt;.&lt;/span&gt;pc&lt;span style="color: #666666"&gt;.&lt;/span&gt;hardware       &lt;span style="color: #666666"&gt;0.81&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.80&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.81&lt;/span&gt;       &lt;span style="color: #666666"&gt;301&lt;/span&gt;
   comp&lt;span style="color: #666666"&gt;.&lt;/span&gt;sys&lt;span style="color: #666666"&gt;.&lt;/span&gt;mac&lt;span style="color: #666666"&gt;.&lt;/span&gt;hardware       &lt;span style="color: #666666"&gt;0.90&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.91&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.91&lt;/span&gt;       &lt;span style="color: #666666"&gt;256&lt;/span&gt;
          comp&lt;span style="color: #666666"&gt;.&lt;/span&gt;windows&lt;span style="color: #666666"&gt;.&lt;/span&gt;x       &lt;span style="color: #666666"&gt;0.88&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.88&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.88&lt;/span&gt;       &lt;span style="color: #666666"&gt;297&lt;/span&gt;
            misc&lt;span style="color: #666666"&gt;.&lt;/span&gt;forsale       &lt;span style="color: #666666"&gt;0.87&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.81&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.84&lt;/span&gt;       &lt;span style="color: #666666"&gt;290&lt;/span&gt;
               rec&lt;span style="color: #666666"&gt;.&lt;/span&gt;autos       &lt;span style="color: #666666"&gt;0.92&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.93&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.92&lt;/span&gt;       &lt;span style="color: #666666"&gt;324&lt;/span&gt;
         rec&lt;span style="color: #666666"&gt;.&lt;/span&gt;motorcycles       &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;       &lt;span style="color: #666666"&gt;294&lt;/span&gt;
      rec&lt;span style="color: #666666"&gt;.&lt;/span&gt;sport&lt;span style="color: #666666"&gt;.&lt;/span&gt;baseball       &lt;span style="color: #666666"&gt;0.97&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.94&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;       &lt;span style="color: #666666"&gt;315&lt;/span&gt;
        rec&lt;span style="color: #666666"&gt;.&lt;/span&gt;sport&lt;span style="color: #666666"&gt;.&lt;/span&gt;hockey       &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.99&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.98&lt;/span&gt;       &lt;span style="color: #666666"&gt;302&lt;/span&gt;
               sci&lt;span style="color: #666666"&gt;.&lt;/span&gt;crypt       &lt;span style="color: #666666"&gt;0.95&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.95&lt;/span&gt;       &lt;span style="color: #666666"&gt;297&lt;/span&gt;
         sci&lt;span style="color: #666666"&gt;.&lt;/span&gt;electronics       &lt;span style="color: #666666"&gt;0.91&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.85&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.88&lt;/span&gt;       &lt;span style="color: #666666"&gt;313&lt;/span&gt;
                 sci&lt;span style="color: #666666"&gt;.&lt;/span&gt;med       &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;       &lt;span style="color: #666666"&gt;277&lt;/span&gt;
               sci&lt;span style="color: #666666"&gt;.&lt;/span&gt;space       &lt;span style="color: #666666"&gt;0.94&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.97&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;       &lt;span style="color: #666666"&gt;305&lt;/span&gt;
  soc&lt;span style="color: #666666"&gt;.&lt;/span&gt;religion&lt;span style="color: #666666"&gt;.&lt;/span&gt;christian       &lt;span style="color: #666666"&gt;0.93&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.94&lt;/span&gt;       &lt;span style="color: #666666"&gt;293&lt;/span&gt;
      talk&lt;span style="color: #666666"&gt;.&lt;/span&gt;politics&lt;span style="color: #666666"&gt;.&lt;/span&gt;guns       &lt;span style="color: #666666"&gt;0.91&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.93&lt;/span&gt;       &lt;span style="color: #666666"&gt;246&lt;/span&gt;
   talk&lt;span style="color: #666666"&gt;.&lt;/span&gt;politics&lt;span style="color: #666666"&gt;.&lt;/span&gt;mideast       &lt;span style="color: #666666"&gt;0.96&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.98&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.97&lt;/span&gt;       &lt;span style="color: #666666"&gt;296&lt;/span&gt;
      talk&lt;span style="color: #666666"&gt;.&lt;/span&gt;politics&lt;span style="color: #666666"&gt;.&lt;/span&gt;misc       &lt;span style="color: #666666"&gt;0.90&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.90&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.90&lt;/span&gt;       &lt;span style="color: #666666"&gt;236&lt;/span&gt;
      talk&lt;span style="color: #666666"&gt;.&lt;/span&gt;religion&lt;span style="color: #666666"&gt;.&lt;/span&gt;misc       &lt;span style="color: #666666"&gt;0.89&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.78&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.83&lt;/span&gt;       &lt;span style="color: #666666"&gt;171&lt;/span&gt;

             avg &lt;span style="color: #666666"&gt;/&lt;/span&gt; total       &lt;span style="color: #666666"&gt;0.91&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.91&lt;/span&gt;      &lt;span style="color: #666666"&gt;0.91&lt;/span&gt;      &lt;span style="color: #666666"&gt;5648&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从输出可以看出来，针对每种类别，都统计了查准率，召回率和 F1-Score。对这些概念不熟悉的读者可参阅笔者的另外一篇博客&lt;a href="http://blog.kamidox.com/evaluating-2.html"&gt;机器学习系统的设计与调优&lt;/a&gt;。此外，我们还可以通过 &lt;code&gt;confusion_matrix()&lt;/code&gt; 函数，来生成混淆矩阵，观察每种类别被错误分类的情况，比如，这些被错误分类的文档是被错误分类到哪些类别里的：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;sklearn.metrics&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; confusion_matrix

cm &lt;span style="color: #666666"&gt;=&lt;/span&gt; confusion_matrix(y_test, pred)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;confusion matrix:&amp;quot;&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(cm)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在笔者电脑上的输出为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;confusion matrix:
[[&lt;span style="color: #666666"&gt;224&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;5&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;  &lt;span style="color: #666666"&gt;13&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;1&lt;/span&gt; &lt;span style="color: #666666"&gt;267&lt;/span&gt;   &lt;span style="color: #666666"&gt;5&lt;/span&gt;   &lt;span style="color: #666666"&gt;5&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;8&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;3&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;1&lt;/span&gt;  &lt;span style="color: #666666"&gt;13&lt;/span&gt; &lt;span style="color: #666666"&gt;230&lt;/span&gt;  &lt;span style="color: #666666"&gt;24&lt;/span&gt;   &lt;span style="color: #666666"&gt;4&lt;/span&gt;  &lt;span style="color: #666666"&gt;10&lt;/span&gt;   &lt;span style="color: #666666"&gt;5&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;9&lt;/span&gt;  &lt;span style="color: #666666"&gt;21&lt;/span&gt; &lt;span style="color: #666666"&gt;242&lt;/span&gt;   &lt;span style="color: #666666"&gt;7&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;  &lt;span style="color: #666666"&gt;10&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;7&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;5&lt;/span&gt;   &lt;span style="color: #666666"&gt;5&lt;/span&gt; &lt;span style="color: #666666"&gt;233&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;3&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;  &lt;span style="color: #666666"&gt;20&lt;/span&gt;   &lt;span style="color: #666666"&gt;6&lt;/span&gt;   &lt;span style="color: #666666"&gt;3&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt; &lt;span style="color: #666666"&gt;260&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;5&lt;/span&gt;  &lt;span style="color: #666666"&gt;12&lt;/span&gt;   &lt;span style="color: #666666"&gt;3&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt; &lt;span style="color: #666666"&gt;235&lt;/span&gt;  &lt;span style="color: #666666"&gt;10&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;3&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;7&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;4&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;8&lt;/span&gt; &lt;span style="color: #666666"&gt;300&lt;/span&gt;   &lt;span style="color: #666666"&gt;4&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;3&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;3&lt;/span&gt; &lt;span style="color: #666666"&gt;283&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt; &lt;span style="color: #666666"&gt;297&lt;/span&gt;   &lt;span style="color: #666666"&gt;8&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt; &lt;span style="color: #666666"&gt;298&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt; &lt;span style="color: #666666"&gt;284&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;  &lt;span style="color: #666666"&gt;11&lt;/span&gt;   &lt;span style="color: #666666"&gt;3&lt;/span&gt;   &lt;span style="color: #666666"&gt;5&lt;/span&gt;   &lt;span style="color: #666666"&gt;4&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;4&lt;/span&gt;   &lt;span style="color: #666666"&gt;5&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;4&lt;/span&gt; &lt;span style="color: #666666"&gt;266&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;4&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt; &lt;span style="color: #666666"&gt;266&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;3&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt; &lt;span style="color: #666666"&gt;296&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;3&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt; &lt;span style="color: #666666"&gt;280&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt; &lt;span style="color: #666666"&gt;236&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;4&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;3&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt; &lt;span style="color: #666666"&gt;290&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [  &lt;span style="color: #666666"&gt;2&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;  &lt;span style="color: #666666"&gt;10&lt;/span&gt;   &lt;span style="color: #666666"&gt;7&lt;/span&gt; &lt;span style="color: #666666"&gt;212&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
 [ &lt;span style="color: #666666"&gt;16&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;   &lt;span style="color: #666666"&gt;0&lt;/span&gt;  &lt;span style="color: #666666"&gt;12&lt;/span&gt;   &lt;span style="color: #666666"&gt;4&lt;/span&gt;   &lt;span style="color: #666666"&gt;1&lt;/span&gt;   &lt;span style="color: #666666"&gt;4&lt;/span&gt; &lt;span style="color: #666666"&gt;134&lt;/span&gt;]]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从第一行数据可以看出来，类别 0 (alt.atheism) 的文档，有 13 个文档被错误地分类到类别 19 (talk.religion.misc) 里。当然，我们还可以把混淆矩阵进行数据可视化处理：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# Show confusion matrix&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;matplotlib.pyplot&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;as&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;plt&lt;/span&gt;

plt&lt;span style="color: #666666"&gt;.&lt;/span&gt;figure(figsize&lt;span style="color: #666666"&gt;=&lt;/span&gt;(&lt;span style="color: #666666"&gt;8&lt;/span&gt;, &lt;span style="color: #666666"&gt;8&lt;/span&gt;), dpi&lt;span style="color: #666666"&gt;=144&lt;/span&gt;)
plt&lt;span style="color: #666666"&gt;.&lt;/span&gt;title(&lt;span style="color: #BB4444"&gt;&amp;#39;Confusion matrix of the classifier&amp;#39;&lt;/span&gt;)
ax &lt;span style="color: #666666"&gt;=&lt;/span&gt; plt&lt;span style="color: #666666"&gt;.&lt;/span&gt;gca()
ax&lt;span style="color: #666666"&gt;.&lt;/span&gt;spines[&lt;span style="color: #BB4444"&gt;&amp;#39;right&amp;#39;&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;set_color(&lt;span style="color: #BB4444"&gt;&amp;#39;none&amp;#39;&lt;/span&gt;)
ax&lt;span style="color: #666666"&gt;.&lt;/span&gt;spines[&lt;span style="color: #BB4444"&gt;&amp;#39;top&amp;#39;&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;set_color(&lt;span style="color: #BB4444"&gt;&amp;#39;none&amp;#39;&lt;/span&gt;)
ax&lt;span style="color: #666666"&gt;.&lt;/span&gt;spines[&lt;span style="color: #BB4444"&gt;&amp;#39;bottom&amp;#39;&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;set_color(&lt;span style="color: #BB4444"&gt;&amp;#39;none&amp;#39;&lt;/span&gt;)
ax&lt;span style="color: #666666"&gt;.&lt;/span&gt;spines[&lt;span style="color: #BB4444"&gt;&amp;#39;left&amp;#39;&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;set_color(&lt;span style="color: #BB4444"&gt;&amp;#39;none&amp;#39;&lt;/span&gt;)
ax&lt;span style="color: #666666"&gt;.&lt;/span&gt;xaxis&lt;span style="color: #666666"&gt;.&lt;/span&gt;set_ticks_position(&lt;span style="color: #BB4444"&gt;&amp;#39;none&amp;#39;&lt;/span&gt;)
ax&lt;span style="color: #666666"&gt;.&lt;/span&gt;yaxis&lt;span style="color: #666666"&gt;.&lt;/span&gt;set_ticks_position(&lt;span style="color: #BB4444"&gt;&amp;#39;none&amp;#39;&lt;/span&gt;)
ax&lt;span style="color: #666666"&gt;.&lt;/span&gt;set_xticklabels([])
ax&lt;span style="color: #666666"&gt;.&lt;/span&gt;set_yticklabels([])
plt&lt;span style="color: #666666"&gt;.&lt;/span&gt;matshow(cm, fignum&lt;span style="color: #666666"&gt;=1&lt;/span&gt;, cmap&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;gray&amp;#39;&lt;/span&gt;)
plt&lt;span style="color: #666666"&gt;.&lt;/span&gt;colorbar()
plt&lt;span style="color: #666666"&gt;.&lt;/span&gt;show()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在笔者电脑上的输出如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="混淆矩阵" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ch09.02_confusion_matrix.png" /&gt;&lt;/p&gt;
&lt;p&gt;除对角线外，其他地方颜色越浅，说明此处错误越多。通过这些数据，我们可以详细分析样本数据，找出为什么某种类别会被错误地分类到另外一种类别里，从而进一步优化模型。&lt;/p&gt;
&lt;h2 id="5"&gt;5 参数选择&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MultinomialNB&lt;/code&gt; 有一个重要的参数是 alpha ，用来控制模型拟合时的平滑度。我们选择了 0.0001 这个值。实际上，有一个更科学的方法，是利用 scikit-learn 的 &lt;code&gt;sklearn.model_selection.GridSearchCV&lt;/code&gt; 来进行自动选择。即我们可以设置一个 alpha 参数的范围，然后让用代码选择出一个在这个范围内最优的参数值。感兴趣的朋友可以阅读 &lt;a href="http://scikit-learn.org/stable/modules/generated/sklearn.grid_search.GridSearchCV.html"&gt;GridSearchCV&lt;/a&gt; 的文档偿试一下。&lt;/p&gt;
&lt;p&gt;(完)&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>零基础学习朴素贝叶斯算法</title><link href="http://blog.kamidox.com/naive-bayes.html" rel="alternate"></link><updated>2017-04-30T23:43:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2017-04-30:naive-bayes.html</id><summary type="html">&lt;h2 id="_1"&gt;朴素贝叶斯&lt;/h2&gt;
&lt;p&gt;朴素贝叶斯 (Naive Bayers) 是一种基于概率统计的分类方法，它在条件独立假设的基础上，使用贝叶斯定理构建算法，在文本处理领域有广泛的应用。&lt;/p&gt;
&lt;h3 id="1"&gt;1 算法原理&lt;/h3&gt;
&lt;p&gt;要讲清楚算法原理，我们需要先搞清楚贝叶斯定理，它是一个条件概率公式。&lt;/p&gt;
&lt;h4 id="11"&gt;1.1 贝叶斯定理&lt;/h4&gt;
&lt;p&gt;我们来看一下维基百科上一个有意思的例子。警察使用一个假冒伪劣的呼气测试仪来测试司机是否醉驾。假设这个仪器有 5% 的概率会把一个正常的司机判断为醉驾，但对真正醉驾的司机，则其测试结果是 100% 准确的。从过往的统计得知，大概有 0.1% 的司机为醉驾。假设，警察随机拦下一个司机，让他 (她) 做呼气测试，仪器测试结果为醉驾。仅凭这一结果判断，这位倒霉的司机真的醉驾的概率是多高？&lt;/p&gt;
&lt;p&gt;90% ？50% ？真实的结果是不到 2% 。对，你没看错，如果我们没有通过其他的方法（比如闻司机身上的酒味），单单凭这个仪器的测试结果来判断，其实准确性是非常低的。&lt;/p&gt;
&lt;p&gt;假设，我们的样本里有 1000 人，根据过往的统计数据，这 1000 位司机里有 0.1% 的概率为真正醉驾，即有 1 位真正醉驾的司机，999 位正常。这 1000 位司机均拿这个劣质呼气测试仪来测试，则有多少人会被判断为醉驾？对这位真正醉驾的司机，他 (她) 无法蒙混过关，而对 999 位正常的司机，有 5% 的概率会被误测，所以总共有 1 + 999 x 5% 个倒霉蛋会被仪器判断为醉驾。由此可得，所有被仪器判断为醉驾的司机里面，真正醉驾的概率是 1 / (1 + 999 x 5%) = 1.96% 。&lt;/p&gt;
&lt;p&gt;实际上，贝叶斯定理是计算这类&lt;strong&gt;条件概率&lt;/strong&gt;问题的绝佳方法。我们记 P(A|B) 表示观察到事件 B 发生时，事件 A 发生的概率，则贝叶斯定理的数学表达为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
P(A|B) = \frac {P(A) P(B|A)} {P(B)}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;回到我们的例子里，我们记事件 A 为司机真正醉驾，事件 B 为仪器显示司机醉驾。则我们的例子里要求解的问题即为 P(A|B)，即观察到仪器显示司机醉驾（事件 B 发生）时，司机真正醉驾（事件 A 发生）的概率是多少。P(A) 表示司机真正醉驾的概率，这是&lt;strong&gt;先验概率&lt;/strong&gt;，例子里的数值是 0.1% 。P(B|A) 表示当司机真正醉驾时（事件 A 发生），仪器显示司机醉驾（事件 B 发生）的概率是多少，从例子里的数据得知是 100% 。P(B) 表示仪器显示司机醉驾的概率，这里有两部分的数据，针对真正醉驾的司机 (0.1%)，仪器能 100% 检测出来，故这部分的数值上 0.1% x 100%；针对正常的司机 (1 - 0.1%) ，仪器显示醉驾的概率为 (1 - 0.1%) * 5%。代入贝叶斯定理即可得：&lt;/p&gt;
&lt;p&gt;P(A|B) =  0.1% x 100% / [0.1% x 100% + (1 - 0.1%) * 5%] = 1.96%&lt;/p&gt;
&lt;h4 id="12"&gt;1.2 朴素贝叶斯分类法&lt;/h4&gt;
&lt;p&gt;假设我们有一个己标记的数据集 $[x^{(i)}, y^{(i)}]$ ，其中 $y^{(i)} \in [C_1, C_2,&amp;hellip;, C_b]$，即数据集总共有 b 个类别；$x^{(i)} = [x_1, x_2,&amp;hellip;, x_n]$，即总共有 n 个输入特征。针对一个新的样本 $x$ ，我们要预测 $y$ 的值，即对 $x$ 进行分类。这是个典型的机器学习里的分类问题。&lt;/p&gt;
&lt;p&gt;我们要求解的问题，使用统计学的语言，可以描述为，当观察到输入样本是 $x$ 时，其所属于的类别 $y = C_k$ 的概率，使用条件概率公式可以写成：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(C_k|x)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 $C_k \in [C_1, C_2,&amp;hellip;, C_b]$ ，我们只需要分别求出所有 b 个类别的概率，然后取&lt;strong&gt;概率最大&lt;/strong&gt;的那个 $C_k$ 即是 $x$ 所属的类别。直接求解上述公式比较困难，我们应用贝叶斯定理进行一次变换：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(C_k|x) = \frac {p(C_k) P(x|C_k)} {P(x)}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;针对不同的 $C_k$ ，$P(x)$ 都是固定的值。故，我们只需要求解，针对不同的 $C_k \in [C_1, C_2,&amp;hellip;, C_b]$ 的情况下，$p(C_k) P(x|C_k)$ 的最大值即可知道，$x$ 属于哪个类别。即：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(C_k|x) \varpropto p(C_k) P(x|C_k)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 $\varpropto$ 表示成正比的意思。根据&lt;strong&gt;联合概率&lt;/strong&gt;公式，可得：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(C_k) P(x|C_k) = P(C_k, x)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;对概率统计陌生的同学不要被专有术语吓到了，联合概率表示的是一种概率叠加。比如，你走在路上遇到美女是一个随机事件，美女对你一见钟情是另外一个随机事件，那么你在路上遇到美女，且对你一见钟情的概率要怎么计算呢？即 P(美女，对你一见钟情) 的值是多少呢？使用概率叠加来计算，遇到美女的概率，乘以是个美女，且对你一见钟情的概率（条件概率）。即：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
P(美女，对你一见钟情) = P(美女) P(对你一见钟情|美女)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;我们从白日梦回到枯燥的数学。又因为，$x$ 是有 n 个特征向量，即 $x = [x_1, x_2,&amp;hellip;, x_n]$ ，可得：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(C_k) P(x|C_k) = P(C_k, x) = P(C_k, x_1, x_2,&amp;hellip;, x_n)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;根据链式法则以及条件概率的定义，我们可以进一步推导公式：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
P(C_k, x_1, x_2,&amp;hellip;, x_n) = P(x_1, x_2,&amp;hellip;, x_n, C_k)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
P(x_1, x_2,&amp;hellip;, x_n, C_k) = P(x_1 | x_2,&amp;hellip;, x_n, C_k) P(x_2,&amp;hellip;, x_n, C_k)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
P(x_1, x_2,&amp;hellip;, x_n, C_k) = P(x_1 | x_2,&amp;hellip;, x_n, C_k) P(x_2 | x_3,&amp;hellip;, x_n, C_k) &amp;hellip; P(x_n | C_k) P(C_k)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;咦，好像越推导越复杂了。是时候用上我们的法宝了。上述推导里，我们只用了贝叶斯定理，我们的法宝就是前面的定语&lt;strong&gt;朴素&lt;/strong&gt;。朴素指的是条件独立假设，即事件之间没有关联关系。比如，掷一个质地均匀的骰子两次，前后之间出现的数字是独立的，不相关的，我们称这两个事件是条件独立的。朴素贝叶斯算法的前提是，输入特征需要满足条件独立假设。即，当 $i \neq j$ 时，$x_i$ 和 $x_j$ 是不相关的，用大白话说，就是 $x_i$ 事件是否发生和 $x_j$ 没关系。根据条件独立的原则：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
P(x_i | x_{i+1},&amp;hellip;, x_n, C_k) = P(x_i | C_k)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;有了这个公式，我们就可以简化为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
P(x_1, x_2,&amp;hellip;, x_n, C_k) = P(x_1 | C_k) P(x_2 | C_k) &amp;hellip; P(x_n | C_k) P(C_k)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这样我们的最终推导结果就是：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(C_k|x) \varpropto P(C_k) \prod_{i=1}^n P(x_i | C_k)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 $\prod$ 是连乘符号。$P(C_k)$ 表示每种类别出现的概率，这个值很容易从数据集里统计出来。$P(x_i | C_k)$ 表示当类别为 $C_k$ 时，特征 $x_i$ 出现的概率，这个也可以从数据集中统计出来。这就是朴素贝叶斯分类法的数学原理。&lt;/p&gt;
&lt;h3 id="2"&gt;2 一个简单的例子&lt;/h3&gt;
&lt;p&gt;我们先通过一个简单的例子，来看怎么样应用朴素贝叶斯分类法。假设我们有以下的关于驾龄，平均车速和性别的统计数据：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;驾龄&lt;/th&gt;
&lt;th&gt;平均车速&lt;/th&gt;
&lt;th&gt;性别&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;现在观察到一个驾龄为 2 年的人，平均车速为 80，问：这个人的性别是什么？&lt;/p&gt;
&lt;p&gt;假设 $C_0$ 表示女，$C_1$ 表示男，$x_0$ 表示驾龄，$x_1$ 表示平均车速。我们先来计算这个人为女性的概率相对值。根据统计数据，女性司机的概率 $P(C_0) = 5 / 10 = 0.5$。根据统计数据，驾龄为 2 年的女性司机的概率，即 $P(x_0 | C_0) = 1 / 10 = 0.1$。平均车速为 80 的女性司机的概率 $P(x_1 | C_0) = 1 / 10 = 0.1$。根据朴素贝叶斯分类法的数学公式：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
P(C_0) \prod_{i=1}^n P(x_i | C_0) = 0.5 \times 0.1 \times 0.1 = 0.005&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;接着，我们来计算这个人为男性的概率相对值。根据统计数据，不难得出男性司机的概率 $P(C_1) = 5 / 10 = 0.5$。驾龄为 2 年的男性司机的概率 $P(x_0 | C_1) = 2 / 10 = 0.2$。平均车速为 80 的男性司机的概率 $P(x_1 | C_1) = 3 / 10 = 0.3$。根据朴素贝叶斯分类法的数学公式：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
P(C_1) \prod_{i=1}^n P(x_i | C_0) = 0.5 \times 0.2 \times 0.3 = 0.03&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;从相对概率来看，这个人是男性的概率，是这个人是女性的概率的 6 倍，据此我们判断这个人是男性。我们也可以从相对概率里算出绝对概率，即这个人是男性的概率是 $0.03 / (0.03 + 0.005) = 0.857$ 。&lt;/p&gt;
&lt;h3 id="3"&gt;3 概率分布&lt;/h3&gt;
&lt;p&gt;到目前为止，我们介绍的朴素贝叶斯分类法，是根据数据集里数据，计算出绝对概率来进行求解。再看一遍朴素贝叶斯分类法的数学公式：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(C_k|x) \varpropto P(C_k) \prod_{i=1}^n P(x_i | C_k)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，$P(x_i | C_k)$ 表示在类别 $C_k$ 里，特征 $x_i$ 出现的概率。这里面有个最大的问题，如果数据集太小，那么从数据集里计算出来的概率偏差将非常严重。举个例子，你观察到一个质地均匀的骰子投掷 6 次的结果是 [1, 3, 1, 5, 3, 3]。质地均匀的骰子，每个点出现的概率都是 1/6 ，如果你根据我们观察到的数据集，去计算每个点的概率，和真实的概率相差将是非常大的。&lt;/p&gt;
&lt;p&gt;怎么解决这个问题呢？答案是使用概率分布来计算概率，而不从数据集里计算概率。为了介绍清楚这个问题，需要从概率统计的基本概念谈起，那些对概率统计比较熟悉的读者可以直接跳过本节内容。&lt;/p&gt;
&lt;h4 id="31"&gt;3.1 概率统计的基本概念&lt;/h4&gt;
&lt;p&gt;人的身高是一个&lt;strong&gt;连续随机变量&lt;/strong&gt;，而投掷一个骰子得到的点数则是一个&lt;strong&gt;离散随机变量&lt;/strong&gt;。我们闭着眼睛在地球上随便抓一个人，问：这个人身高是 170 cm 的可能性是多大呢？如果有一个函数 $f(x)$，能描述人类身高的可能性，那么直接把 170 cm 代入即可求出这个可能性。这个函数就是&lt;strong&gt;概率密度函数&lt;/strong&gt;，也称为 PDF (Probability Density Function)。典型的概率密度函数是高斯分布函数，比如人类的身高，就满足高斯分布的规律，我们在下文会详细介绍。&lt;/p&gt;
&lt;p&gt;再比如，投掷一个质地均匀的骰子，得到 6 的概率是多少？大家应该都知道答案是 1/6 。假如有一个函数 $f(x)$，能描述骰子出现 x 点数（$x \in [1, 6]$）的概率，那么把 x 代入即可得到概率，这个函数称为&lt;strong&gt;概率质量函数&lt;/strong&gt;，即 PMF (Probability Mass Function)。为什么要费力使用概率质量函数呢？一是在数学追求统一性，二是并不是所有的离散随机变量的概率分布，都像投掷一次骰子这么直观。比如投掷 6 次质地均匀的骰子，得到 4 个 4 的概率是多少？相信好学的你会限入无限的沉思，并感叹一下：这个问题不好算啊。这个时候如果有概率质量函数，就可轻松求解啦。&lt;/p&gt;
&lt;p&gt;总结一下，&lt;strong&gt;随机变量&lt;/strong&gt;分成两种，一种是连续随机变量，另外一种是离散随机变量。概率密度函数描述的是连续随机变量在某个特定值的可能性，概率质量函数描述的是离散随机变量在某个特定值的可能性。而&lt;strong&gt;概率分布&lt;/strong&gt;则是描述随机变量取值的概率规律。&lt;/p&gt;
&lt;h4 id="32"&gt;3.2 多项式分布&lt;/h4&gt;
&lt;p&gt;抛一枚硬币，要么出现正面，要么出现反面（我们假设硬币不会立起来）。假如出现正面的概率是 p ，则出现反面的概率就是 1 - p 。符合这种规律的概率分布，称为&lt;strong&gt;伯努利分布&lt;/strong&gt; (Bernoulli Distribution)。其概率质量函数为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(k ; p) = p^k (1-p)^{1-k}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，$k \in [0, 1]$，p 是出现 1 的概率。比如，抛一次质地均匀的硬币，得到正面的概率为 0.5，这是众所周知的答案。我们代入上述公式，也可以得到相同的结果，即 $f(1 ; 0.5) = 0.5$。&lt;/p&gt;
&lt;p&gt;更一般的情况，即不止两种可能性时，假设每种可能性是 $p_i$，则满足 $\sum_i^n p_i = 1$ 条件的概率分布，我们称为&lt;strong&gt;类别分布&lt;/strong&gt; (Categorical Distribution)。比如我们投掷一个骰子，则会出现 6 种可能性，所有的可能性加起来概率为 1。类别分布的概率质量函数为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(x | p) = \prod_{i=1}^k p_i^{x_i}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$\prod$ 是我们见过的连乘符号。其中，$k$ 是类别的数量，$p_i$ 是第 i 种类别的概率，$x_i$ 当且仅当类别 x 为类别 i 时，其值为 1，其他情况其值为 0。比如，针对质地均匀的骰子，$k$ 的值为 6，$p_i$ 的值为 1/6 。问，投掷这个骰子得到 3 的概率是多少？傻子都知道，答案是 1/6 啊。我们代入概率质量函数验算一下，$f(3 | p) = \prod_{i=1}^6 p_i^{x_i}$，针对所有 $i \neq 3$ 的情况，$x_i = 0$，针对 $i = 3$ 的情况，$x_i = 1$，所以容易算出 $f(3 | p) = 1/6$。&lt;/p&gt;
&lt;p&gt;停停停，你都快把我绕晕了，这么简单的问题为什么要弄得这么复杂呢？笔者仿佛听到读者在报怨了。前面都是铺垫，接下来介绍的内容才是精华。再往下看，你就就能知道我们把问题复杂化的原因，也能看到数学之美。&lt;/p&gt;
&lt;p&gt;那我们开始吧，问：抛一枚质地均匀的硬币 10 次，出现 3 次正面的概率是多少？这是个典型的&lt;strong&gt;二项式分布&lt;/strong&gt;问题。二项式分布，指的是把符合伯努利分布的实验做了 n 次，结果 1 出现 0 次，1 次，2 次 &amp;hellip; n 次的概率分别是多少，它的概率质量函数为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(k; n, p) = \frac {n!}{k! (n-k)!} p^k (1 - p)^{n-k}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，k 是结果 1 出现的次数，$k \in [0, 1, &amp;hellip;, n]$，n 是实验的总次数，p 是在一次实验中结果 1 出现的概率。怎么理解这个公式呢？我们总共进行了 n 次实验，那么出现 k 次结果 1 的概率为 $p^k$ ，剩下的必定是结果 0 的次数，即出现了 n - k 次，其概率为 $(1 - p)^{n-k}$，公式前面的系数表示的是组合，即 k 次结果 1 可以是任意的组合，比如可能是前 k 次是结果 1，也可能是最后 k 次出现的是结果 1。回到最初的问题：抛一枚质地均匀的硬币 10 次，出现 3 次正面的概率是多少？代入二项式分布的概率质量函数，得到：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(3; 10, 0.5) = \frac {10!} {3! \times (10 - 3)!} \times 0.5^3 \times (1 - 0.5)^{10 - 3} = 0.1171875&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;我们再看一个更简单的例子，问：抛一枚质地均匀的硬币 1 次，出现 0 次正面的概率是多少？代入二项式分布的概率质量函数，得到：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(0; 1, 0.5) = \frac {1!} {0! \times (1 - 0)!} \times 0.5^0 \times (1 - 0.5)^{1 - 0} = 0.5&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，零的阶乘为 1，即 $0! = 1$。结果跟我们预期的相符，当实验只做一次时，二项式分布退化为伯努利分布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多项式分布&lt;/strong&gt;是指满足类别分布的实验，连续做 n 次后，每种类别出现的特定次数组合的概率分布情况。假设，$x_i$ 表示类别 i 出现的次数，$p_i$ 表示类别 i 在单次实验中出现的概率。当满足前提条件 $\sum_{i=1}^k x_i = n$ 时，由随机变量 $x_i$ 构成的&lt;strong&gt;随机向量&lt;/strong&gt; $X = [x_1,&amp;hellip;,x_k]$ 满足以下分布函数：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(X,n,P) = \frac {n!}{\prod_{i=1}^k x_i!} \prod_{i=1}^k p_i^{x_i}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，P 是由各个类别的概率构成的向量，即 $P = [p_1,&amp;hellip;,p_k]$，k 表示类别的总数，n 表示实验进行的总次数。理解这个公式也比较简单，可以把 $\prod_{i=1}^k p_i^{x_k}$ 理解为，按照特定顺序，所有类别出现的某个特定的次数组合的概率，比如投掷骰子 6 次，出现 (1, 2, 3, 4, 5, 6) 这样特定顺序组合的概率。前面的系数，表示组合的个数，比如，投掷骰子 6 次，每个点数都出现一次，可以是 (1, 2, 3, 4, 5, 6) ，也可以是 (1, 3, 2, 4, 5, 6) 。&lt;/p&gt;
&lt;p&gt;我们看一个例子，同时投掷 6 个质地均匀的骰子，出现 (1, 2, 3, 4, 5, 6) 这种组合的概率是多少？我们可以把这个问题转换成，连续投掷 6 次质地均匀的骰子，每个类别都出现 1 次的概率。这是个典型的&lt;strong&gt;多项式分布&lt;/strong&gt;问题，其中随机向量 $X = [1, 1, 1, 1, 1, 1]$，代入多项式分布的概率质量函数可得：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(X,n,P) = \frac {6!}{\prod_{i=1}^6 1!} \prod_{i=1}^6 (1/6) = 0.015432099&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;好了，是时候解决之前那个让你挠耳抓腮的问题了：投掷 6 次质地均匀的骰子，得到 4 个 4 的概率是多少？我们需要把这个问题转换为&lt;strong&gt;二项式分布&lt;/strong&gt;问题。投掷 1 次骰子时，得到 4 的概率是 1/6，得到其他点数 (非 4) 的概率是 5/6。现在需要计算投掷 6 次骰子，得到 4 个 4 的概率，代入二项式分布的概率质量函数可得：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(4; 6, 1/6) = \frac {6!}{4! \times (6 - 4)!} (1/6)^4 \times (1 - 1/6)^{6 - 4} = 0.008037551&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;我们再来算一下，同时投掷 6 个质地均匀的骰子，出现 5 个 1 的概率是多少？还是转换为二项式分布问题：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(5; 6, 1/6) = \frac {6!}{5! \times (6 - 5)!} (1/6)^5 \times (1 - 1/6)^{6 - 5} = 0.000643004&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;在厦门和台湾，中秋博饼是一个盛大的传统活动，相传是郑成功为了缓解士兵的中秋思乡之情，发明的一种游戏。很多公司在中秋节都会组织员工博饼，奖品从牙膏，牙刷，洗衣粉，食用油到洗发水，购物卡，生活用品样样俱有。往往这个时候员工都会玩得很开心。其规则是，所有参与的玩家轮流，同时投掷 6 个骰子，根据掷出的不同点数组合，发放对应奖项的奖品。游戏设有一个状元，两个对堂，以及其他数量不等的不同名目的奖项。状元的点数组合是 4 个 4 或者 6 个 4 或者 5 个相同点数的骰子组合，如 5 个 1，5 个 2 等。如果是顺子，即 (1, 2, 3, 4, 5, 6) 的组合，则为对堂。玩过中秋博饼的读者经常会有这样的体会，状元奖品早就被博走了，可是对堂奖品却还有，今天我们从概率的角度来看看为什么会出现这个现象。根据上文例子的计算结果，出现对堂的概率是 0.015432099，而出现状元的概率是 0.008037551 + 6 x 0.000643004 = 0.011895575（我们忽略 6 个 4 的超级状元组合）。说明古人在发明这种游戏时，还是充分考虑过概率的，即博出状元的概率还是比对堂要低。不过，由于对堂有两份奖品，算起来，虽然对堂出现的概率比状元高，但需要出现两次才能把全部对堂的奖品消耗完，而其概率又不足状元的两倍。这就解释了，为什么往往状元已经被博走了，可是还有对堂奖品的原因。&lt;/p&gt;
&lt;p&gt;简单总结一下，二项式分布，描述的是，多次伯努利实验中，某个结果出现次数的概率。多项式分布，描述的是，多次进行满足类别分布的实验，所有类别出现的次数组合的分布。&lt;/p&gt;
&lt;p&gt;二项式分布和多项式分布，结合朴素贝叶斯算法，经常被用来实现文章分类算法。比如，有一个论坛需要对用户的评论进行过滤，屏蔽掉不文明的评论。首先，我们需要有一个经过标记的数据集，我们称为语料库。假设，我们使用人工标记的方法，对评论进行人工标记，标记为 1 表示包含不文明用语的评论，标记为 0 表示正常评论。&lt;/p&gt;
&lt;p&gt;假设我们的词库大小为 k ，则文章里出现的某个词，可以看成是一次满足 k 个类别的类别分布实验。我们知道，一篇评论是由 n 个词组成的，故一篇文章可以看成是进行 n 次符合类别分布的实验后的产物。由此得知，一篇评论文章服从多项式分布，它是词库里的所有词语出现的次数组合构成的&lt;strong&gt;随机向量&lt;/strong&gt;。一般情况下，词库比较大，评论文章只是由少量词组成，所以这个随机向量是很稀疏的，即大部分元素为零。通过分析语料库，我们容易统计出每个词出现不文明评论以及正常评论文章里的概率，即 $p_i$ 的值。同时，针对待预测的评论文章，我们可以统计出词库里的所有词在这篇文章里的出现次数，即 $x_i$ 的值；以及评论文章的词语个数 n 。代入多项式分布的概率质量函数：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(X,n,P) = \frac {n!}{\prod_{i=1}^k x_i!} \prod_{i=1}^k p_i^{x_i}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;我们可以求出，待预测的评论文章构成的随机向量 X ，其为不文明评论的相对概率。同理也可求出其为正常评论的相对概率，通过比较两个相对概率，就可以对这篇文章输出一个预测值。当然，实际应用中，涉及到大量的自然语言处理的手段，包括中文分词技术，词的数学表示等。在此不一一展开。&lt;/p&gt;
&lt;h4 id="33"&gt;3.3 高斯分布&lt;/h4&gt;
&lt;p&gt;在车速和性别预测的例子里，我们的平均车速，笔者故意给出了离散值，实际上它是一个连续值。这个时候怎么用朴素贝叶斯算法来处理呢？答案是，可以用区间来把连续值转换为离散值。比如，我们把 [0, 40] 之间的平均车速作为一个级别，把 [40, 80] 之间的平均车速作为另外一个级别，此外再把 80 以上的车速作为另外一个级别。这样就可以把连续的值变成离散的值，从而使用朴素贝叶斯分类法进行处理。另外一个方法，是使用连续随机变量的概率密度函数，把数值转换为一个相对概率。本节介绍的高斯分布就是这样的方法。&lt;/p&gt;
&lt;p&gt;高斯分布 (Gaussian Distribution) 也称为正态分布 (Normal Distribution)，是自然界最常见的一种概率密度函数。人的身高满足高斯分布，特别高和特别矮的人出现的相对概率都比较低。人的智商也符合高斯分布，特别聪明的天才和特别笨的人出现的相对概率都比较低。高斯分布的概率密度函数为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f(x) = \frac {1} {\sqrt {2 \pi \sigma^2}} \exp \left( - \frac {(x - \mu)^2} {2 \sigma^2} \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 x 为随机变量的值，$f(x)$ 为随机变量的相对概率，$\mu$ 为样本的平均值，其决定了高斯分布曲线的位置，$\sigma$ 为标准差，其决定了高斯分布的幅度，其值越大，分布越分散，值越小，分布越集中。典型的高斯分布如图 9-1 所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="高斯分布" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ch09.01_gaussian_distribution.png" /&gt;&lt;/p&gt;
&lt;p&gt;这里需要提醒读者注意，高斯分布的概率密度函数和支持向量机里的高斯核函数的区别。二者的核心数学模型是相同的，但目的不同。&lt;/p&gt;
&lt;h3 id="4"&gt;4 连续值的处理&lt;/h3&gt;
&lt;p&gt;我们来看一个来自&lt;a href="http://en.wikipedia.org/wiki/Naive_Bayes#Sex_classification"&gt;维基百科的例子&lt;/a&gt;。假设，我们有一组人类身体特征的统计数据如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;性别&lt;/th&gt;
&lt;th&gt;身高（英尺）&lt;/th&gt;
&lt;th&gt;体重（磅）&lt;/th&gt;
&lt;th&gt;脚掌（英寸）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;180&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;td&gt;5.92&lt;/td&gt;
&lt;td&gt;190&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;td&gt;5.58&lt;/td&gt;
&lt;td&gt;170&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;男&lt;/td&gt;
&lt;td&gt;5.92&lt;/td&gt;
&lt;td&gt;165&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;td&gt;5.5&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;td&gt;5.42&lt;/td&gt;
&lt;td&gt;130&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;女&lt;/td&gt;
&lt;td&gt;5.75&lt;/td&gt;
&lt;td&gt;150&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;假设某人身高 6 英尺、体重 130 磅、脚掌 8 英寸，请问此人的性别是什么？&lt;/p&gt;
&lt;p&gt;根据朴素贝叶斯公式：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(C_k|x) \varpropto P(C_k) \prod_{i=1}^n P(x_i | C_k)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;针对待预测的这个人的数据 x，我们只需要分别求出男性和女性的相对概率：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(性别) \times p(身高|性别) \times p(体重|性别) \times p(脚掌|性别)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;然后取相对概率较高的性别为预测值即可。这里的困难在于，所有的特征都是离散变量，无法根据统计数据计算概率。当然，这里我们可以用区间法，把连续变量转换为离散变量，然后再计算概率。由于数据量较小，这显然不是个好方法。由于人类身高，体重，脚掌尺寸满足高斯分布，故一个更好的办法，是使用高斯分布的概率密度函数来求相对概率。&lt;/p&gt;
&lt;p&gt;首先，针对男性和女性，分别求出每个特征的平均值和方差：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;性别&lt;/th&gt;
&lt;th&gt;身高均值&lt;/th&gt;
&lt;th&gt;身高方差&lt;/th&gt;
&lt;th&gt;体重均值&lt;/th&gt;
&lt;th&gt;体重方差&lt;/th&gt;
&lt;th&gt;脚掌均值&lt;/th&gt;
&lt;th&gt;脚掌方差&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;男性&lt;/td&gt;
&lt;td&gt;5.855&lt;/td&gt;
&lt;td&gt;3.5033e-02&lt;/td&gt;
&lt;td&gt;176.25&lt;/td&gt;
&lt;td&gt;1.2292e+02&lt;/td&gt;
&lt;td&gt;11.25&lt;/td&gt;
&lt;td&gt;9.1667e-01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;女性&lt;/td&gt;
&lt;td&gt;5.4175&lt;/td&gt;
&lt;td&gt;9.7225e-02&lt;/td&gt;
&lt;td&gt;132.5&lt;/td&gt;
&lt;td&gt;5.5833e+02&lt;/td&gt;
&lt;td&gt;7.5&lt;/td&gt;
&lt;td&gt;1.6667e+00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;接着，我们利用高斯分布的概率密度函数，来求解男性身高为 6 英尺的相对概率：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(身高=6|男性) = \frac {1} {\sqrt {2 \pi \times 3.5033e-02}} \exp \left( - \frac {(6 - 5.855)^2} {2 \times 3.5033e-02^2} \right) \approx 1.5789&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这里的关键是，把连续值（身高）作为输入，通过高斯分布的概率密度函数的处理，直接转换为相对概率。注意，这里是相对概率，所以其值大于 1 并未违反概率论规则。&lt;/p&gt;
&lt;p&gt;我们使用相同的方法，容易算出以下数值：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(体重=130|男性) = 5.9881 \times 10^{-6}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(脚掌=8|男性) = 1.3112 \times 10^{-3}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;由于 $p(男性) = 0.5$ ，故这个人是男性的相对概率为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
0.5 \times 1.5789 \times 5.9881 \times 10^{-6} \times 1.3112 \times 10^{-3} = 6.1984 \times 10^{-9}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;使用相同的方法，可以算出这个人为女性的相对概率为 $5.3778 \times 10^{-4}$。从数据可知，这个人为女性的概率比男性的概率高了 5 个数量级，故我们判断这个人为女性。&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>微信小程序离线开发文档</title><link href="http://blog.kamidox.com/weapp-doc.html" rel="alternate"></link><updated>2017-02-01T14:52:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2017-02-01:weapp-doc.html</id><summary type="html">&lt;h2 id="_1"&gt;写在前面&lt;/h2&gt;
&lt;p&gt;程序员开发过程中离不开开发文档，微信小程序也不例外。开发微信小程序的常规姿势是边写代码，边开着微信小程序开发文档的网页，来回切换。这里有一个更优雅的解决方案。&lt;/p&gt;
&lt;h2 id="_2"&gt;微信小程序离线开发文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安装 &lt;a href="https://kapeli.com/dash"&gt;Dash&lt;/a&gt;。如果你不知道 Dash，是时候了解一下了，绝对会有相见恨晚的感觉。&lt;/li&gt;
&lt;li&gt;下载 &lt;a href="https://github.com/kamidox/html2Dash/releases/download/minapp-docset-V0.1/minapp.docset.v0.1.tar.gz"&gt;minapp-docset&lt;/a&gt;，导入 Dash 即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Windows 用户可以使用 &lt;a href="http://velocity.silverlakesoftware.com/"&gt;velocity&lt;/a&gt;，Linux 用户可以使用 &lt;a href="http://zealdocs.org/"&gt;Zeal&lt;/a&gt; 作为 Dash 的替代品。&lt;/p&gt;
&lt;p&gt;最后的效果图长这样：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Dash 效果图" src="http://upload-images.jianshu.io/upload_images/184896-d08314fbc56d99f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /&gt;&lt;/p&gt;
&lt;h2 id="_3"&gt;背后的原理&lt;/h2&gt;
&lt;p&gt;知其然知其所以然。背后的原理其实不复杂。先使用 wget 把整个微信小程序的开发文档全部下载下来，再用一个 Python 脚本生成 Dash 格式的 docset。感兴趣的同学可以看看 &lt;a href="https://github.com/kamidox/html2Dash"&gt;html2Dash&lt;/a&gt;，我分享到 Github 上了。&lt;/p&gt;
&lt;p&gt;话说 wget 简直逆天，一个命令可以把一个网站全下载下来。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;wget -r -p -k -np http://www.jianshu.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;不要乱试哦，小心你的硬盘撑破肚子。&lt;/strong&gt;&lt;/p&gt;</summary><category term="weapp"></category></entry><entry><title>微信小程序兼容性问题</title><link href="http://blog.kamidox.com/weapp-capability.html" rel="alternate"></link><updated>2017-01-19T22:52:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2017-01-19:weapp-capability.html</id><summary type="html">&lt;h2 id="_1"&gt;微信小程序兼容性问题&lt;/h2&gt;
&lt;p&gt;微信小程序发布一周多了，兼容性问题，特别是 Android 平台兼容性问题特别严重。据我观察，好多小程序掉到兼容性的坑里。掉坑里不要紧，更让人捉急的是，从坑里爬上来的时候，手刚抓到坑沿，又被微信官方踩到（紧急修复兼容性的版本没审核通过，被微信打回重审），再次跌落坑底，然后眼睁睁地看着后台用户在破口大骂“什么东西都没有啊~，什么破小程序”。&lt;/p&gt;
&lt;p&gt;微信小程序的兼容性问题除了微信本身的 Bug 外，大部分是目标平台对 JavaScript 标准库支持程度不同造成的。&lt;/p&gt;
&lt;h3 id="bug"&gt;微信本身的 Bug 引起的&lt;/h3&gt;
&lt;p&gt;微信本身的 Bug 引发的兼容性问题有个现成的例子，就是 &lt;code&gt;wx.request()&lt;/code&gt; 返回的状态码 &lt;code&gt;res.statusCode&lt;/code&gt; 的值在 iOS 下是 int 型数据，而在 Android 6.0.1 上却是 String 型数据。如果你判断服务器的返回状态码方法不当，可能就踩到坑里了。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;wx.request({
    url&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;http://api.example.com&amp;#39;&lt;/span&gt;,
    success&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;function&lt;/span&gt; (res) {
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; (res.statusCode &lt;span style="color: #666666"&gt;===&lt;/span&gt; &lt;span style="color: #666666"&gt;200&lt;/span&gt;) {
            &lt;span style="color: #008800; font-style: italic"&gt;// success&lt;/span&gt;
        } &lt;span style="color: #AA22FF; font-weight: bold"&gt;else&lt;/span&gt; {
            &lt;span style="color: #008800; font-style: italic"&gt;// server failure&lt;/span&gt;
        }
    }
})
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码就踩坑了，正确的做法是使用 &lt;code&gt;==&lt;/code&gt; 而不是使用 &lt;code&gt;===&lt;/code&gt; 来判断。另外一个更规范的方法是使用 &lt;code&gt;parseInt(res.statusCode) === 200&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;h3 id="javascript"&gt;Javascript 标准库兼容性问题&lt;/h3&gt;
&lt;p&gt;比如 &lt;code&gt;Array.find()&lt;/code&gt; 方法在 iOS 10.2/Android 7.0 上完美支持，但在 Android 6.0.1 上却不支持。如果代码里用到了这个接口，就会导致在 Android 6.0.1 上无法正常工作。通过对比发现，这类接口不支持的个数还是比较多的。特别是 Android 平台版本众多，兼容性问题就更严重，可能一不小小心就掉到坑里。&lt;/p&gt;
&lt;h2 id="_2"&gt;解决方法&lt;/h2&gt;
&lt;p&gt;微信本身 Bug 只能绕过去，但对 JavaScript 引擎的兼容性，可以有更优雅的解决方法。比如，我们可以打补丁，使用 polyfill 来实现这些不支持的标准库方法。比如，修复 Android 6.0.1 平台不支持 &lt;code&gt;String.startsWith()&lt;/code&gt; 的问题，可以使用下面的 polyfill 代码：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; (&lt;span style="color: #666666"&gt;!&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;String&lt;/span&gt;.prototype.startsWith) {
    console.warn(&lt;span style="color: #BB4444"&gt;&amp;#39;define polyfill for Array.prototype.startsWith&amp;#39;&lt;/span&gt;);
    &lt;span style="color: #AA22FF"&gt;String&lt;/span&gt;.prototype.startsWith &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;function&lt;/span&gt; (searchString, position) {
      position &lt;span style="color: #666666"&gt;=&lt;/span&gt; position &lt;span style="color: #666666"&gt;||&lt;/span&gt; &lt;span style="color: #666666"&gt;0&lt;/span&gt;;
      &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;this&lt;/span&gt;.substr(position, searchString.length) &lt;span style="color: #666666"&gt;===&lt;/span&gt; searchString;
  };
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;推而广之，我们可以把平台不支持的标准库方法，使用 polyfill 实现。这就是 &lt;a href="https://github.com/kamidox/minapp-polyfill"&gt;minapp-polyfill&lt;/a&gt; 这个项目的目的。&lt;/p&gt;
&lt;p&gt;使用方法很简单，把 &lt;a href="https://github.com/kamidox/minapp-polyfill"&gt;minapp-polyfill&lt;/a&gt; 项目里的 &lt;code&gt;polyfill.js&lt;/code&gt; 拷贝到小程序源码目录下，在需要打补丁的 JavaScript 源文件头部引入如下代码即可：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;path/to/polyfill.js&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;目前这个项目只是搭了个骨架，还需要很多方法需要实现。PR is welcome。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="javascript_1"&gt;各个平台对 JavaScript 标准库支持情况&lt;/h2&gt;
&lt;p&gt;条件限制，这里统计了四个平台对 JavaScript 标准库的支持情况，分别是 iOS 10.2, Android 6.0.1, Android 7.0, 微信开发者工具，具体数据如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Component.apiName&lt;/th&gt;
&lt;th&gt;iOS 10.2&lt;/th&gt;
&lt;th&gt;Android 6.0.1&lt;/th&gt;
&lt;th&gt;Android 7.0&lt;/th&gt;
&lt;th&gt;devtool&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Array.toString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.values&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.toLocaleString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.concat&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.fill&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.join&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.pop&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.push&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.reverse&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.shift&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.slice&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.sort&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.splice&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.unshift&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.every&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.forEach&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.some&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.indexOf&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.lastIndexOf&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.filter&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.reduce&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.reduceRight&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.map&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.entries&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.keys&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.find&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.findIndex&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.includes&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.copyWithin&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Buffer&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.getInt8&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.getUint8&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.getInt16&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.getUint16&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.getInt32&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.getUint32&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.getFloat32&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.getFloat64&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.setInt8&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.setUint8&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.setInt16&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.setUint16&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.setInt32&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.setUint32&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.setFloat32&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.setFloat64&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DataView.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.toString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.toISOString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.toDateString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.toTimeString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.toLocaleString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.toLocaleDateString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.toLocaleTimeString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.valueOf&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getTime&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getFullYear&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getUTCFullYear&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getMonth&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getUTCMonth&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getDate&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getUTCDate&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getDay&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getUTCDay&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getHours&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getUTCHours&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getMinutes&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getUTCMinutes&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getSeconds&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getUTCSeconds&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getMilliseconds&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getUTCMilliseconds&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getTimezoneOffset&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setTime&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setMilliseconds&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setUTCMilliseconds&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setSeconds&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setUTCSeconds&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setMinutes&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setUTCMinutes&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setHours&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setUTCHours&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setDate&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setUTCDate&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setMonth&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setUTCMonth&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setFullYear&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setUTCFullYear&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.setYear&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.getYear&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.toJSON&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.toUTCString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.toGMTString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Error.toString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Error.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Float32Array.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Float64Array.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Function.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Int16Array.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Int32Array.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Int8Array.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Map.forEach&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Map.clear&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Map.delete&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Map.get&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Map.has&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Map.set&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Map.keys&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Map.values&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Map.entries&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Map.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.abs&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.acos&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.asin&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.atan&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.acosh&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.asinh&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.atanh&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.atan2&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.cbrt&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.ceil&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.clz32&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.cos&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.cosh&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.exp&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.expm1&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.floor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.fround&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.hypot&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.log&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.log10&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.log1p&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.log2&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.max&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.min&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.pow&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.random&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.round&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.sign&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.sin&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.sinh&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.sqrt&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.tan&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.tanh&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.trunc&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Math.imul&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.toString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.toLocaleString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.valueOf&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.hasOwnProperty&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.propertyIsEnumerable&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.isPrototypeOf&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.__defineGetter__&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.__defineSetter__&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.__lookupGetter__&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.__lookupSetter__&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Promise.then&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Promise.catch&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Promise.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RegExp.compile&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RegExp.exec&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RegExp.toString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RegExp.test&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RegExp.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set.forEach&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set.add&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set.clear&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set.delete&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set.has&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set.entries&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set.values&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set.keys&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.match&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.padStart&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.padEnd&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.repeat&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.replace&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.search&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.split&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.toString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.valueOf&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.charAt&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.charCodeAt&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.codePointAt&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.concat&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.indexOf&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.lastIndexOf&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.slice&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.substr&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.substring&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.toLowerCase&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.toUpperCase&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.localeCompare&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.toLocaleLowerCase&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.toLocaleUpperCase&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.big&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.small&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.blink&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.bold&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.fixed&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.italics&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.strike&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.sub&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.sup&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.fontcolor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.fontsize&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.anchor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.link&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.trim&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.trimLeft&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.trimRight&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.startsWith&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.endsWith&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.includes&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.normalize&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Symbol.toString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Symbol.valueOf&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Symbol.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TypeError.toString&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TypeError.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Uint16Array.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Uint32Array.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Uint8Array.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Uint8ClampedArray.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WeakMap.delete&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WeakMap.get&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WeakMap.has&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WeakMap.set&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WeakMap.constructor&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;N/A 表示这个标准库方法在平台上不支持&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q: 这些数据是怎么来的，靠谱吗？&lt;/strong&gt;&lt;br /&gt;
A: 这些数据是在真实小程序运行环境下运行，然后把 API 支持情况发送到服务器后台，再写个脚本把数据整理汇总后得来的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q: 其他平台，比如 Android 5.0 的支持情况怎么样？&lt;/strong&gt;&lt;br /&gt;
A: 由于条件限制，手上没有 Android 5.0 的手机，有愿意配合收集数据的，私信留言。配合的方法很简单，用指定型号的手机打开一个微信小程序，按一个按钮即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q: 为什么不使用 &lt;a href="https://github.com/lodash/lodash"&gt;lodash&lt;/a&gt; 之类效率更高的库，而使用的标准库？&lt;/strong&gt;&lt;br /&gt;
A: 使用 lodash 之类的确实效率更高，兼容性也更好。基于两个原因没有使用，一是 lodash 太大，而微信小程序限制在 1MB 以内。当然，可以用 lodash 模块化的版本来解决，但还有第二个原因，即 lodash 的一些 API 也有兼容性问题，比如我试过 &lt;a href="https://www.npmjs.com/package/lodash.findindex"&gt;lodash.findIndex&lt;/a&gt; 这个包，结果在 Android 6.0.1 上也无法成功运行 (这一点未做深入验证，感兴趣的同学可以验证一下)。&lt;/p&gt;
&lt;h2 id="_3"&gt;总结&lt;/h2&gt;
&lt;p&gt;从后台数据来看，小程序刚发布的前三天，确实带来了非常可观的流量红利，但这部分偿鲜的用户，很快就消失了。三天过后，基本上保持了平衡的访问量。流量红利和广告一样，是催化剂，真正有价值的还是要做用户需要的产品。&lt;/p&gt;
&lt;p&gt;在此顺手安利一下开发的两个小程序 &lt;a href="https://minapp.com/miniapp/90/"&gt;360好书推荐&lt;/a&gt; 和 &lt;a href="https://minapp.com/miniapp/89/"&gt;51经典电影&lt;/a&gt;，偶尔想用的时候打开，可能会偶遇一些小惊喜。但坦白讲，这两个小程序都和微信倡导的小程序价值观不符。微信还是希望通过小程序把线下低频的，服务成本高（这里应该主要是时间成本，即便利性）的场景，转化为线上快捷的使用方式。&lt;/p&gt;</summary><category term="weapp"></category></entry><entry><title>macOS Sierra 上安装 mysqlclient 问题</title><link href="http://blog.kamidox.com/mysqlclient.html" rel="alternate"></link><updated>2016-12-22T23:23:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-12-22:mysqlclient.html</id><summary type="html">&lt;h2 id="_1"&gt;写在前面&lt;/h2&gt;
&lt;p&gt;好久没有写这种类型的文章了，记录遇到的具体问题。&lt;/p&gt;
&lt;p&gt;随着搜索水平的提高，特别是英文搜索水平的提高，这种类型的文章感觉越来越没有价值，因为一搜索就找到了答案。难怪大家说，现在的程序员 = 搜索引擎 + Ctrl+C + Ctrl+V 。&lt;/p&gt;
&lt;p&gt;今天写这个文章是因为花了吃奶的力气仍然搜索不到答案，最后还是靠经验和基础知识解决。问题是这样，在 macOS Sierra 上使用 pip 安装 mysqlclient 时遇到错误，无法链接到 libssl 库，系统上明明安装了 openssl 可是就是链接不到。&lt;/p&gt;
&lt;p&gt;看到这里，99% 的读者可以关掉这个页面走人了。&lt;/p&gt;
&lt;h2 id="_2"&gt;问题现象&lt;/h2&gt;
&lt;p&gt;系统安装了 mysql ，使用 &lt;code&gt;pip install mysqlclient&lt;/code&gt; 时出错，错误信息如下：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;building &amp;#39;_mysql&amp;#39; extension
creating build/temp.macosx-10.6-intel-3.5
/usr/bin/clang -fno-strict-aliasing -Wsign-compare -fno-common -dynamic -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -arch i386 -arch x86_64 -g -Dversion_info=(1,3,9,&amp;#39;final&amp;#39;,1) -D__version__=1.3.9 -I/usr/local/Cellar/mysql/5.7.16/include/mysql -I/Library/Frameworks/Python.framework/Versions/3.5/include/python3.5m -c _mysql.c -o build/temp.macosx-10.6-intel-3.5/_mysql.o -fno-omit-frame-pointer
/usr/bin/clang -bundle -undefined dynamic_lookup -arch i386 -arch x86_64 -g build/temp.macosx-10.6-intel-3.5/_mysql.o -L/usr/local/Cellar/mysql/5.7.16/lib -lmysqlclient -lssl -lcrypto -o build/lib.macosx-10.6-intel-3.5/_mysql.cpython-35m-darwin.so
ld: library not found for -lssl
clang: error: linker command failed with exit code 1 (use -v to see invocation)
error: command &amp;#39;/usr/bin/clang&amp;#39; failed with exit status 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;错误出现的系统是 macOS Sierra, 在 EI Capitan 上安装没有遇到这个问题。&lt;/p&gt;
&lt;h2 id="_3"&gt;问题分析&lt;/h2&gt;
&lt;p&gt;系统上明明装了 openssl 库，可是为什么找不到 libssl 呢？找了一堆答案都是教大家用 &lt;code&gt;brew link --force openssl&lt;/code&gt; ，可是这个方法对 macOS Sierra 无效。原因是苹果现在不用 openssl 了，而是使用自己维护的加密算法库。为什么要这样做，不得而知，或许是被 openssl 经常爆出的滴血漏洞伤透了心吧。&lt;/p&gt;
&lt;p&gt;所以，要在 mac 上链接 ssl 库，需要指定库的路径，即加上 &lt;code&gt;-L/usr/local/opt/openssl&lt;/code&gt;，把这个目录加进库的搜索路径即可。&lt;/p&gt;
&lt;p&gt;细心的人在用 &lt;code&gt;brew install openssl&lt;/code&gt; 时会注意到下面的信息：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;This formula is keg-only, which means it was not symlinked into /usr/local.

Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries

Generally there are no consequences of this for you. If you build your
own software and it requires this formula, you’ll need to add to your
build variables:

LDFLAGS: -L/usr/local/opt/openssl/lib
CPPFLAGS: -I/usr/local/opt/openssl/include
PKG_CONFIG_PATH: /usr/local/opt/openssl/lib/pkgconfig
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_4"&gt;解决方案&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从 Github 上下载 &lt;a href="https://github.com/PyMySQL/mysqlclient-python/archive/1.3.9.tar.gz"&gt;mysqlclient 源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;进入项目的 virtualenv 环境。为什么要这一步，因为我们希望把 mysqlclient 安装到项目所在的 python 运行环境中&lt;/li&gt;
&lt;li&gt;运行 &lt;code&gt;python setup.py install&lt;/code&gt;，这个时候肯定还是报错的&lt;/li&gt;
&lt;li&gt;拷贝命令台上的最后一个报错的命令，在 &lt;code&gt;-L/usr/local/Cellar/mysql/5.7.16/lib&lt;/code&gt; 后面增加如下内容 &lt;code&gt;-L/usr/local/opt/openssl&lt;/code&gt;，然后回车再执行一遍这个命令&lt;/li&gt;
&lt;li&gt;再次运行 &lt;code&gt;python setup.py install&lt;/code&gt; 即可成功安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，这个做法是偷懒的做法。真正优雅一点的是修改 mysqlclient 的编译脚本，直接把 ssl 库增加进去。或许还可以向开发者提个 PR 来解决这个问题。&lt;/p&gt;</summary><category term="python"></category></entry><entry><title>白话网站架构演进</title><link href="http://blog.kamidox.com/web-arch-evolution.html" rel="alternate"></link><updated>2016-12-02T23:52:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-12-02:web-arch-evolution.html</id><summary type="html">&lt;p&gt;这是白话 IT 系列的文章。白话的意思是，争取用最简单直白的语言描述复杂的 IT 技术。&lt;/p&gt;
&lt;p&gt;网站架构的演进不外乎两个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户越来越多，意味着并发要求越来越高&lt;/li&gt;
&lt;li&gt;数据越来越多，意味着存储挑战越来越大&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_1"&gt;上古时代&lt;/h2&gt;
&lt;p&gt;实际上，上古时代并遥远，大概在 30 年前吧，甚至更近。那个时候上网的人很少，网站架构简单地一踏糊涂。&lt;/p&gt;
&lt;p&gt;&lt;img alt="上古时代" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/web_arch_the_ancient_times.png" /&gt;&lt;/p&gt;
&lt;p&gt;就一个数据库加一个应用服务器，应用服务器直接开门迎客。有时候，数据库和应用服务器还运行在同一台主机上，简洁得一踏糊涂。如果你认为这种架构只能做简单的事情，那就错了。这种架构也不泛一些大型的应用场景，典型的如银行的信息系统。只是，主机要用 IBM 的大型机，数据库用 Oracle，存储器要用 EMC 。这种架构还有一个特点是贵，死贵。多年之后，一场轰轰烈烈地去 IOE 运行席卷神州大地，前期就是为了解决贵的问题，当然这是后话了。&lt;/p&gt;
&lt;h2 id="_2"&gt;读写分离&lt;/h2&gt;
&lt;p&gt;数据库在执行写操作时，需要锁定数据表，这是为了保持数据一致性。想像一下，数据库写了一半，有人读取了数据，它读出来的数据可能是不完整的。&lt;/p&gt;
&lt;p&gt;这带来的一个问题，当数据库写得比较频繁，读往往得不到执行，因为数据库老是被锁住。表现在用户层面，网速很快的情况下，一个网页显示得好久都显示不出来，这是因为数据库的读操作得不到执行。&lt;/p&gt;
&lt;p&gt;读写分离就是为了解决这个问题的，核心要点是一个 Master 数据库负责数据写入，另外有一到多个 Slave 数据库负责数据读取。Master 和 Slave 之间的数据会自动同步。&lt;/p&gt;
&lt;p&gt;&lt;img alt="读写分离" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/web_arch_rw_sep.png" /&gt;&lt;/p&gt;
&lt;h2 id="_3"&gt;负载均衡&lt;/h2&gt;
&lt;p&gt;随着用户量越来越多，应用服务器开始忙不过来了。假设一个应用服务器可以运行 10 个 worker 线程，每个 worker 线程给用户提供服务的时间需要 10 毫秒，那么一个应用服务器只能满足 1000 次/秒的服务请求。超过了这个量级，就需要增加应用服务器，这个时候就引入了负载均衡服务器。&lt;/p&gt;
&lt;p&gt;负载均衡服务器负责接收用户发过来的请求，然后看哪个应用服务器比较有空闲，就把请求发送给相应的应用服务器执行。就像部门领导一样，本身自己不做事，只负责把任务分配给空闲的工程师。&lt;/p&gt;
&lt;p&gt;&lt;img alt="负载均衡" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/web_arch_work_balance.png" /&gt;&lt;/p&gt;
&lt;h2 id="_4"&gt;动静分离&lt;/h2&gt;
&lt;p&gt;网站有静态内容和动态内容之分，比如我们上新浪微博网站，网站上的 Logo 就属于静态内容，它是不变的 (这里是指用户无法改变它，实际上微博的开发工程师是可以，也会改变它的)，而用户发的微博属于动态内容，它是频繁改变的。用更专业的术语讲，JavaScript，CSS，网站图片属于静态内容。&lt;/p&gt;
&lt;p&gt;为了进一步提高性能，可以把静态的内容和动态的内容分离，分别放在不同的服务器上。毕竟，静态的内容不需要读数据库，也不需要经过应用服务器的逻辑运算，可以直接把静态内容发送给用户。这样可以减少中间交互环节，从而提高效率。&lt;/p&gt;
&lt;p&gt;&lt;img alt="动静分离" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/web_arch_static_dynamic_sep.png" /&gt;&lt;/p&gt;
&lt;h2 id="_5"&gt;内容分发网络&lt;/h2&gt;
&lt;p&gt;当用户进一步增长，一个负载均衡服务器搞不定了。更要命的是，北方的用户访问速度还可以，南方的用户访问起来奇慢无比。这个时候，CDN 闪亮登场了。&lt;/p&gt;
&lt;p&gt;CDN 全称是内容分发网络 (Content Delivery Network)，它的原理很简单，让一个区域的用户访问那个区域的服务器。比如北方用户从青岛服务器获取数据，华南用户从杭州服务器获取数据，西南用户从广州服务器获取数据。这种分而治之的策略特别适用于静态内容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="内容分发网络" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/web_arch_cdn.png" /&gt;&lt;/p&gt;
&lt;p&gt;这里有一个问题，怎么样让一部分用户从 &lt;code&gt;负载均衡服务器 1&lt;/code&gt; 访问，另外一部分从 &lt;code&gt;负载均衡服务器 2&lt;/code&gt; 访问？&lt;/p&gt;
&lt;p&gt;这里就涉及到&lt;strong&gt;动态 DNS 解析&lt;/strong&gt;的技术，我们知道普通的 DNS 解析就是从一个域名获得一个或多个对应的 IP 地址信息，这个信息是不变的，即不管是北方用户还是南方用户，获取到的信息是一样的。而动态 DNS 解析，会根据用户的 IP 地址所在的地理位置以及所处的网络运营商的拓扑结构中的位置，返回最靠近的一个 IP 地址给用户。这样就实现了用户的分流，而且实现就近访问原则，从而提高效率。&lt;/p&gt;
&lt;h2 id="_6"&gt;数据库集群&lt;/h2&gt;
&lt;p&gt;大家看到上面的架构图，是不是有点头重脚轻的感觉？没错，单纯的读写分享已经无法满足海量数据和海量并发的需求了。这个时候，就需要大容量的分布式数据库登场了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="分布式数据库" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/web_arch_dist_db.png" /&gt;&lt;/p&gt;
&lt;p&gt;分布式数据库的优点是，可以有多个数据中心，在每个数据中心都可以支持读写，后台会自动完成数据同步工作。这个在持续不间断服务领域也是个良好的应用，因为即使一个数据中心损坏了（着火，烧掉了），也可以从另外一个数据中心恢复出数据。&lt;/p&gt;
&lt;p&gt;还有一个优点，当数据容量增大，需要扩容时，可以无缝扩容。即应用服务器不受影响。应用服务器只和数据库路由打交道，扩容可以在背后进行。&lt;/p&gt;
&lt;h2 id="_7"&gt;缓存&lt;/h2&gt;
&lt;p&gt;从数据库里读数据还是慢，有没有办法把经常读的数据放在缓存里来提高效率呢？这就是 memcached, Redis 干的事情。这样演进后的架构变成了这样：&lt;/p&gt;
&lt;p&gt;&lt;img alt="缓存" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/web_arch_cached.png" /&gt;&lt;/p&gt;
&lt;h1 id="_8"&gt;总结&lt;/h1&gt;
&lt;p&gt;看起来很简单，很自然的演进，都是 IT 技术人员数十年努力的结果，绝不简单，绝不容易。如果和研发的开会，你要是说，不是很简单吗，加个分布式数据库不就可以解决问题么？我敢保证程序员们会在内心鄙视你，如果你不是发工资的那个人，鄙视还可能溢于言表。&lt;/p&gt;</summary><category term="web"></category></entry><entry><title>React 最佳实践示例项目</title><link href="http://blog.kamidox.com/react-best-practise-demo.html" rel="alternate"></link><updated>2016-11-09T22:52:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-11-09:react-best-practise-demo.html</id><summary type="html">&lt;p&gt;这一个是用 React 实现的 &lt;a href="https://news.ycombinator.com"&gt;HackerNews&lt;/a&gt; 客户端，项目地址在这 &lt;a href="https://github.com/kamidox/react-hacker-news"&gt;react-hacker-news&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="_1"&gt;写在前面&lt;/h2&gt;
&lt;p&gt;GitHub 上已经有一堆基于 React 的 HackerNews 客户端，为什么还需要写一个新的？&lt;/p&gt;
&lt;p&gt;原因是前端技术发展太快了。如果你看过&lt;a href="https://segmentfault.com/a/1190000007083024"&gt;《2016年里做前端是怎样一种体验》&lt;/a&gt;，除了一笑而过之外，还想了解文章里的那些把人搞晕的名词和术语，那么这篇文章会有一些有用的信息。&lt;/p&gt;
&lt;p&gt;另外一个原因是，GitHub 上很多项目代码都有点过时，比如广为传播且 star 数最多的 &lt;a href="https://github.com/insin/react-hn"&gt;insin/react-hn&lt;/a&gt; 使用 ES5 编写，且没有单元测试。&lt;/p&gt;
&lt;p&gt;最后，我决定厚着脸皮，抛个砖，引个玉。这个 demo 项目是我学习 React 框架时做的第一个较完整的项目。我决定献丑写出来，可能对一些初学者有帮助。如果有幸有人指点一二，纠正我的错误观念，那就更好了。&lt;/p&gt;
&lt;p&gt;项目部署在 GitHub Pages 上，正式开始之前，可以体验一下项目的成果：&lt;a href="https://kamidox.github.io/react-hacker-news/"&gt;react-hacker-news&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="_2"&gt;最佳实践&lt;/h2&gt;
&lt;p&gt;哪些可以算得上 React 开发的最佳实践？我们展开看看。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ES6: 绝大部分代码使用 ES6 代码编写。特别是 React Component 相关的代码也使用 ES6 语法。除了少敲点字外，最大的好处是整洁。&lt;/li&gt;
&lt;li&gt;eslint-config-airbnb: 这是一个 eslint 扩展。用完这个插件，真正体会到站在巨人的肩膀上的感觉。这个插件可能会帮助你纠正很多你平时根本没意识到的不良编码习惯。&lt;/li&gt;
&lt;li&gt;webpack/babel: 使用 babel 把 ES6/React 代码编译成浏览器广泛支持的 ES5 代码，使用 webpack 打包以及开发环境/生产环境管理。&lt;/li&gt;
&lt;li&gt;持续集成：使用 &lt;code&gt;ghooks&lt;/code&gt; 实现提交前的代码静态分析，以及 git commit msg 的格式检查。当然，还可以配置，在提交前自动执行单元测试。&lt;/li&gt;
&lt;li&gt;提交记录规范: 有的人会在 git commit message 里骂人，有的会在里面写微型小说，程序员这个群体总是不缺创意。但这里，我们借助 &lt;a href="https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#-git-commit-guidelines"&gt;AngularJS 的规范&lt;/a&gt;。如果没有按照规范写 commit message 提交前无法通过自动检查。还有一个好处是，可以直接使用一个命令生成 change log。&lt;/li&gt;
&lt;li&gt;单元测试：使用 Mocha/Enzyme/chai/sinon 来做 React 的单元测试。多数情况下，单元测试往往得不到重视。但从工程的角度，单元测试是质量保证的最重要工具之一。完备的单元测试可以让代码取得别人天然的信任。&lt;/li&gt;
&lt;li&gt;Log 系统: 使用轻量级的 &lt;code&gt;loglevel&lt;/code&gt; 来打印应用的调试信息。如果你还在使用 &lt;code&gt;console.log()&lt;/code&gt; 来打印 Log，是时候规范一点了。&lt;/li&gt;
&lt;li&gt;一键部署到 GitHub Pages：辛辛苦苦开发的应用，想和小伙伴们分享一下。没问题，一键即可部署到 GitHub Pages 上。要使用这个功能，你需要有 Python 环境，并且使用 &lt;code&gt;pip install ghp-import&lt;/code&gt; 安装一个 &lt;code&gt;ghp-import&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;总结&lt;/h2&gt;
&lt;p&gt;荣耀属于&lt;a href="http://www.ruanyifeng.com"&gt;阮一峰&lt;/a&gt;，只要你没有恐高症，站在巨人的肩膀上是个很好的提高效率的方式。这个项目以 &lt;a href="https://github.com/ruanyf/react-babel-webpack-boilerplate"&gt;ruanyf/react-babel-webpack-boilerplate&lt;/a&gt; 作为起点开发的。远不止于此，阮一峰还在他博客上写下&lt;a href="http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html"&gt;React 技术栈系列教程&lt;/a&gt;，推荐初学者阅读。&lt;/p&gt;
&lt;p&gt;我 Fork 阮一峰的 boilerplate 项目，增加了几个 Feature:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把静态文件移到 &lt;code&gt;public&lt;/code&gt; 目录下&lt;/li&gt;
&lt;li&gt;增加单元测试工具集&lt;/li&gt;
&lt;li&gt;增加一键部署到 GitHub Pages 功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目地址是 &lt;a href="https://github.com/kamidox/react-babel-webpack-boilerplate"&gt;kamidox/react-babel-webpack-boilerplate&lt;/a&gt;，如果你认同这里阐述的开发理念，可以作为 React 项目的开发起点。&lt;/p&gt;</summary><category term="react"></category></entry><entry><title>微信小程序原理</title><link href="http://blog.kamidox.com/weapp-principle.html" rel="alternate"></link><updated>2016-11-05T07:52:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-11-05:weapp-principle.html</id><summary type="html">&lt;h2 id="_1"&gt;写在前面&lt;/h2&gt;
&lt;p&gt;微信小程序使用了前端技术栈 JavaScript/WXML/WXSS。但和常规的前端开发又有一些区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript: 微信小程序的 JavaScript 运行环境即不是 Browser 也不是 Node.js。它运行在微信 App 的上下文中，不能操作 Browser context 下的 DOM，也不能通过 Node.js 相关接口访问操作系统 API。所以，严格意义来讲，微信小程序并不是 Html5，虽然开发过程和用到的技术栈和 Html5 是相通的。&lt;/li&gt;
&lt;li&gt;WXML: 作为微信小程序的展示层，并不是使用 Html，而是自己发明的基于 XML 语法的描述。&lt;/li&gt;
&lt;li&gt;WXSS: 用来修饰展示层的样式。官方的描述是 “ WXSS (WeiXin Style Sheets) 是一套样式语言，用于描述 WXML 的组件样式。WXSS 用来决定 WXML 的组件应该怎么显示。” “我们的 WXSS 具有 CSS 大部分特性&amp;hellip;我们对 CSS 进行了扩充以及修改。”基于 CSS2 还是 CSS3？大部分是哪些部分？是否支持 CSS3 里的动画？不得而知。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在微信小程序官方文档上，有下面这段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微信小程序运行在三端：iOS、Android 和 用于调试的开发者工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中&lt;/li&gt;
&lt;li&gt;在 Android 上，小程序的 javascript 代码是通过 X5 内核来解析&lt;/li&gt;
&lt;li&gt;在 开发工具上， 小程序的 javascript 代码是运行在 nwjs（chrome内核） 中&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先从开发工具谈起。&lt;/p&gt;
&lt;h2 id="_2"&gt;开发工具&lt;/h2&gt;
&lt;p&gt;小程序的 javascript 代码运行在 nwjs 中。nwjs 是什么鬼呢？官方介绍是这样写的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NW.js (previously known as node-webkit) lets you call all Node.js modules directly from DOM and enables a new way of writing applications with all Web technologies.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://nwjs.io"&gt;nwjs&lt;/a&gt; 合并 Browser 和 Node.js 的运行时，可以使用前端开发技术来开发跨平台的应用程序。借助 Node.js 访问操作系统原生 API 的能力，可以开发中跨平台的应用程序。微信小程序开发工具就是使用 nwjs 开发的。如果你是 Mac 用户，进入目录 &lt;code&gt;/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/app&lt;/code&gt; 可以看到开发工具的实现代码，当然代码是经过混淆的。网上流行的破解版本开发工具原理上就是修改这里面的代码。&lt;/p&gt;
&lt;p&gt;与此类似的，一个更火的项目是 &lt;a href="http://electron.atom.io"&gt;Electron&lt;/a&gt;，由 GitHub 推出的，它也是把 Browser 和 Node.js 结合，用来开发跨平台的应用程序。程序员们应该听说过 &lt;a href="https://atom.io"&gt;Atom&lt;/a&gt; 这个编辑器界的后起之秀。包括微软拥抱开源社区的编辑器 &lt;a href="http://code.visualstudio.com"&gt;vscode&lt;/a&gt; 也是使用 Electron 开发的。&lt;/p&gt;
&lt;h3 id="electron-vs-nwjs"&gt;Electron vs nwjs&lt;/h3&gt;
&lt;p&gt;这两个平台有什么区别？为什么微信选择 nwjs 呢？我们不妨猜一猜。&lt;/p&gt;
&lt;p&gt;从技术角度来讲：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序入口不同：Electron 入口是一个 javascript 脚本，脚本里要自己负责创建浏览器窗口，加载 html 页面。而 nwjs 的入口就是一个 html 页面，框架自己会创建浏览器窗口来显示这个 html 页面。&lt;/li&gt;
&lt;li&gt;Node.js 集成方式不同：Electron 直接使用 Node.js 的共享库，不需要修改 Chromium 代码。而 nwjs 为了集成 Node.js ，需要修改 Chromium 代码，以便在浏览器里能通过 Node.js 访问系统原生 API。&lt;/li&gt;
&lt;li&gt;Multi-Context: nwjs 有多个上下文，一个是浏览器的上下文，用来访问 Browser 相关 API，比如操作 DOM ，另外一个是 Node 上下文，用来访问操作系统 API。Electron 没有使用多个上下文，对开发者更友好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从应用角度来讲：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打包后的文件大小：Electron 打包后文件会比 nwjs 小不少。一个 18M 的程序，使用 Electron 打包后是 117M，而使用 nwjs 打包后的程序是 220M。微信小程序开发工具打包后是 219M (v0.10.102800)。没有亲测，评价来源参考文档。&lt;/li&gt;
&lt;li&gt;代码保护：Electron 只支持代码混淆来保护，而 nwjs 把核心代码放在 V8 引擎里，不但可以保护代码，还可以提高执行效率。&lt;/li&gt;
&lt;li&gt;开源社区活跃度：Electron 应该是完胜的。看看&lt;a href="http://electron.atom.io/apps/"&gt;使用 Electron 构建的应用程序&lt;/a&gt;就知道了。而据说 nwjs 的开发文档有些都没有及时更新。&lt;/li&gt;
&lt;li&gt;应用程序启动时间：Electron 会稍微快一点。没有亲测，评价来源参考文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这个分析猜测，微信选择 nwjs 的原因可能是出于代码保护。毕竟开发工具可以上传小程序，有些接口和数据需要比较严密的保护。哪位大牛可以挖挖看哪些代码被保护起来了。&lt;/p&gt;
&lt;h2 id="_3"&gt;真机运行环境&lt;/h2&gt;
&lt;p&gt;下面内容完全是猜测的，如有言中，实属运气。&lt;/p&gt;
&lt;p&gt;微信小程序的运行环境应该更类似 ReactNative 之类，而不是纯 Html5。两者最大的不同在于，ReactNative 的界面是由原生控件渲染出来的，而 Html5 的界面是由浏览器内核渲染出来的。两者在性能上有较大的差异，感兴趣的可以参阅我的另外一篇文章&lt;a href="http://www.jianshu.com/p/2b4926fa45df"&gt;《跨平台 App 开发技术方案汇总》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;原理上，小程序是如何在微信 App 里运行的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微信 App 里包含 javascript 运行引擎。&lt;/li&gt;
&lt;li&gt;微信 App 里包含了 WXML/WXSS 处理引擎，最终会把界面翻译成系统原生的控件，并展示出来。这样做的目的是为了提供和原生 App 性能相当的用户体验。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来意淫一下小程序加载运行的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户点击打开一个小程序&lt;/li&gt;
&lt;li&gt;微信 App 从微信服务器下载这个小程序&lt;/li&gt;
&lt;li&gt;分析 &lt;code&gt;app.json&lt;/code&gt; 得到应用程序的配置信息（导航栏，窗口样式，包含的页面列表等）&lt;/li&gt;
&lt;li&gt;加载并运行 &lt;code&gt;app.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加载并显示在 &lt;code&gt;app.json&lt;/code&gt; 里配置的第一个页面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个只是从开发者眼中看到的一个简化版的过程，实际过程应该比这要复杂得多，涉及到浏览器线程（就是运行我们的逻辑层代码 app.js 等的线程）和 AppService 线程之间的交互。从官方网站上的一个图片可以看出端倪：&lt;/p&gt;
&lt;p&gt;&lt;img alt="生命周期" src="https://mp.weixin.qq.com/debug/wxadoc/dev/image/mina-lifecycle.png" /&gt;&lt;/p&gt;
&lt;p&gt;至于微信 App 是如何与小程序的逻辑层 javascript 交互的呢？可以简单地归纳如下：&lt;/p&gt;
&lt;p&gt;JavaScript 是脚本语言，可以在运行时解释并执行。微信 App 里包含了一个 JavaScript 引擎，由它来负责执行逻辑层的 JavaScript 代码。那么 JavaScript 调用的小程序相关 API 怎么实现的呢？答案是最终会被翻译成实现在微信 App 里的原生接口。比如开发者调用 &lt;code&gt;wx.getLocation(OBJECT)&lt;/code&gt; 获取当前地理位置，微信 App 里的 JavaScript 引擎在执行这个代码时，会去调用微信 App 里实现的原生接口来获取地理位置坐标。&lt;/p&gt;
&lt;p&gt;感兴趣的朋友可以阅读我之前推荐过的一篇文章&lt;a href="http://www.jianshu.com/p/978c4bd3a759"&gt;《React Native 从入门到原理》&lt;/a&gt;。文章分析的虽然是 ReactNative，但实际上原理是相通的。&lt;/p&gt;
&lt;h2 id="_4"&gt;总结&lt;/h2&gt;
&lt;p&gt;微信小程序最大的好处是不需要做设备适配，只要微信能运行，小程序就能运行。小程序虽然是一个封闭形态下的前端开发技术，但借助微信的巨大影响力，几乎所有人都在往里面冲。微信小程序太火了，内测火，公测更火。内测刚出来，就有人用微信小程序实现了商城，并开源。感叹一下：你的热情，就像一把火，燃烧了整个沙漠。&lt;/p&gt;
&lt;p&gt;作为开发者，提几个不足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不支持从 node_modules 中加载模块。这样无形中就把 npm 排除在外了。从开发生态角度，这个应该是微信小程序下一步要重点解决的问题吧。&lt;/li&gt;
&lt;li&gt;开发工具自带的代码编辑器还是太简陋了。不知道为什么微信要重复发明轮子。理论上，给流行的代码编辑器 (sublime/atom/vscode etc.) 开发个插件。然后用户直接到小程序后台上传提交审核就好了。程序员是挑剔到近乎偏执的物种，代码编辑器又是程序员时刻打交道的工具，要做好实属不易。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_5"&gt;参考文档&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;https://github.com/electron/electron/blob/master/docs/development/atom-shell-vs-node-webkit.md&lt;/li&gt;
&lt;li&gt;https://www.akawebdesign.com/2015/05/06/electron-vs-nwjs/&lt;/li&gt;
&lt;li&gt;https://www.akawebdesign.com/2015/11/02/electron-vs-nwjs-part-2/&lt;/li&gt;
&lt;/ol&gt;</summary><category term="weapp"></category></entry><entry><title>step-by-step 构建 IPSec/IKEv2 VPN</title><link href="http://blog.kamidox.com/ipsec-ikev2-vpn.html" rel="alternate"></link><updated>2016-11-01T23:22:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-11-01:ipsec-ikev2-vpn.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;升级到 iOS 10 和 macOS Sierra 后，发现原来的 pptp vpn 没了。那是因为 Apple 因为安全原因，禁用的 pptp vpn ，这里可以查阅到 &lt;a href="https://support.apple.com/en-us/HT206844"&gt;Apple 官方声明&lt;/a&gt;。你需要搭建一个支持 IPSec/IKEv2 的 VPN 服务器。本文使用 AWS 的 Ubuntu 服务器搭建一个支持 IPSec/IKEv2 的 VPN 服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_1"&gt;写在前面&lt;/h2&gt;
&lt;p&gt;你需要一个 AWS Ubuntu 服务器。国内访问的话，建议申请日本的服务器，速度最快。如果不知道怎么申请 AWS 服务器，请用 Baidu Google 一下。&lt;/p&gt;
&lt;p&gt;搭建支持 IPSec/IKEv2 的 VPN 服务器总共分几步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你需要有一台运行 ubuntu 的海外主机，本文使用 aws ubuntu 主机&lt;/li&gt;
&lt;li&gt;在 AWS ubuntu 主机上运行一个脚本安装并配置 VPN 服务器&lt;/li&gt;
&lt;li&gt;启动 VPN 服务&lt;/li&gt;
&lt;li&gt;客户端配置 VPN&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文重点描述后面三个步骤。&lt;/p&gt;
&lt;h2 id="vpn"&gt;安装并配置 VPN 服务器&lt;/h2&gt;
&lt;p&gt;这本来是一个很繁琐的步骤，具体可参阅 &lt;a href="https://hjc.im/shi-yong-strongswanda-jian-ipsecikev2-vpn/"&gt;使用 Strongswan 搭建 IPSec/IKEv2 VPN&lt;/a&gt;。有心人把文章里描述的步骤写了个 &lt;a href="https://github.com/magic282/One-Key-L2TP-IKEV2-Setup"&gt;shell 脚本&lt;/a&gt;并放在了 github 上。这样我们执行脚本即可完成软件安装以及配置工作。&lt;/p&gt;
&lt;h3 id="step-1"&gt;STEP 1 下载脚本&lt;/h3&gt;
&lt;p&gt;使用 ssh 登录 aws ubuntu 主机，执行下面命令下载脚本：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;wget https://raw.githubusercontent.com/magic282/One-Key-L2TP-IKEV2-Setup/master/l2tp_setup.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="step-2"&gt;STEP 2 添加可执行权限&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;chmod a+x l2tp_setup.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="step-3"&gt;STEP 3 安装软件&lt;/h3&gt;
&lt;p&gt;运行脚本，需要注意，需要使用 root 用户运行这个脚本。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;sudo ./l2tp_setup.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;出现下面的提示时，输入 1&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&amp;quot;#################################&amp;quot;
&amp;quot;What do you want to do:&amp;quot;
&amp;quot;1) Install l2tp&amp;quot;
&amp;quot;2) Add an account&amp;quot;
&amp;quot;#################################&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;出现下面的提示时，输入 PSK 密码，&lt;strong&gt;这个密码后面客户端登录时要用到&lt;/strong&gt;，注意保管好：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Please &lt;span style="color: #AA22FF"&gt;set &lt;/span&gt;the secretkey&lt;span style="color: #666666"&gt;(&lt;/span&gt;Pre Shared Key&lt;span style="color: #666666"&gt;)&lt;/span&gt;:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;出现下面提示时，输入 2&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&amp;quot;##################&amp;quot;
&amp;quot;What type is your VPS?&amp;quot;
&amp;quot;1) OpenVZ&amp;quot;
&amp;quot;2) others&amp;quot;
##################&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;特别注意&lt;/strong&gt;：这里需要确认一下你的主机是 OpenVZ 还是其他，如 xen 。然后做出相应的选择。一个简单的方法是运行 &lt;code&gt;ls /proc | grep vz&lt;/code&gt; ，如果输出 &lt;code&gt;vz&lt;/code&gt; 就选择 1，否则就选择 2。针对 AWS 上的 ubuntu 选择 2 即可。&lt;/p&gt;
&lt;p&gt;接下来，脚本会下载 Strongswan 软件包，并编译安装。过程可能要几分钟时间。如果没有错误的话，脚本接着会输出如下内容：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;##################&lt;/span&gt;
Please &lt;span style="color: #AA22FF"&gt;set &lt;/span&gt;a password to &lt;span style="color: #AA22FF"&gt;export &lt;/span&gt;the key
&lt;span style="color: #008800; font-style: italic"&gt;##################&lt;/span&gt;
Enter Export Password:
Verifying - Enter Export Password:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以直接按两个回车，即使用空的密钥导出密码。不出意外的话，最终会安装成功，并输出下面的成功信息：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;################################################&lt;/span&gt;
Success!
Use this to connect your L2TP service.
IP: xxx.xxx.xxx.xxx &lt;span style="color: #666666"&gt;(&lt;/span&gt;你的虚拟主机的 IP 地址&lt;span style="color: #666666"&gt;)&lt;/span&gt;
Secretkey: xxxxxx &lt;span style="color: #666666"&gt;(&lt;/span&gt;你的 PSK 密码&lt;span style="color: #666666"&gt;)&lt;/span&gt;
CA cert: /root/l2tpInstall/ca.cert.pem
Don&lt;span style="border: 1px solid #FF0000"&gt;&amp;#39;&lt;/span&gt;t forget to add a new user later, LOL.
&lt;span style="color: #008800; font-style: italic"&gt;################################################&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="step-4"&gt;STEP 4 添加用户&lt;/h3&gt;
&lt;p&gt;运行脚本&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;sudo ./l2tp_setup.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;出现下面的提示时，输入 2&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&amp;quot;#################################&amp;quot;
&amp;quot;What do you want to do:&amp;quot;
&amp;quot;1) Install l2tp&amp;quot;
&amp;quot;2) Add an account&amp;quot;
&amp;quot;#################################&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着在相应的提示下输入用户名和密码：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Please input an new username:
&amp;lt;在这里输入用户名&amp;gt;
Please input the password:
&amp;lt;在这里输入密码&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就成功添加了一个用户。我们可以在客户端使用这个用户和密码以及 PSK 来登录了。&lt;/p&gt;
&lt;h3 id="step-5"&gt;STEP 5 配置数据包转发&lt;/h3&gt;
&lt;p&gt;编辑 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;，将 &lt;code&gt;net.ipv4.ip_forward=1&lt;/code&gt; 一行前面的 &lt;code&gt;#&lt;/code&gt; 号去掉，保存后执行 &lt;code&gt;sysctl -p&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="vpn_1"&gt;启动 VPN 服务&lt;/h2&gt;
&lt;p&gt;这一步不注意就会漏掉，如果漏掉这一步，不会有出错信息，但客户端就是连接不上。即，我们需要手动启动 VPN 服务：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;sudo ipsec start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以使用 &lt;code&gt;ps&lt;/code&gt; 命令确认服务是否正常运行起来了&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;ps -ax | grep ipsec
 &lt;span style="color: #666666"&gt;1861&lt;/span&gt; ?        Ss     0:00 /usr/local/libexec/ipsec/starter --daemon charon
 &lt;span style="color: #666666"&gt;1862&lt;/span&gt; ?        Ssl    0:00 /usr/local/libexec/ipsec/charon --use-syslog
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="vpn_2"&gt;客户端配置 VPN&lt;/h2&gt;
&lt;p&gt;在 macOS 上，新建一个 VPN，&lt;code&gt;VPN Type&lt;/code&gt; 选择 &lt;code&gt;Cisco IPSec&lt;/code&gt;。输入 VPN 服务器地址或域名，以及用户名和密码 (STEP 4 里添加的用户名和密码)。点击 &lt;code&gt;Authentication Settings ...&lt;/code&gt; ，在弹出的窗口里的 &lt;code&gt;Shared Secret&lt;/code&gt; 里输出 PSK (STEP 3 里设置的密码)。这样就可以上网了。&lt;/p&gt;
&lt;p&gt;在 iOS 上，进入 &lt;code&gt;设置 -&amp;gt; 通用 -&amp;gt; VPN -&amp;gt; 添加 VPN 配置...&lt;/code&gt;，类型选择 &lt;code&gt;IPSec&lt;/code&gt;，输入用户名密码以及 PSK 即可完成配置。&lt;/p&gt;
&lt;h2 id="_2"&gt;尽情冲浪吧~~~&lt;/h2&gt;</summary><category term="tools"></category></entry><entry><title>跨平台 App 开发技术方案汇总</title><link href="http://blog.kamidox.com/cross-platform-app-dev.html" rel="alternate"></link><updated>2016-10-23T01:13:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-10-23:cross-platform-app-dev.html</id><summary type="html">&lt;h2 id="hybrid"&gt;Hybrid 技术&lt;/h2&gt;
&lt;p&gt;这类技术，使用 HTML/CSS/JavaScript 等前端技术来构建 App。利用 JSBridge 获取部分访问原生 API 的能力。最有代表性的是 &lt;a href="http://phonegap.com"&gt;PhoneGap&lt;/a&gt;，它是 Adobe 收购一家开源创业公司后推出的平台。&lt;a href="http://blog.ionic.io/what-is-cordova-phonegap/"&gt;这个链接&lt;/a&gt;有 PhoneGap 的一些历史信息。&lt;/p&gt;
&lt;p&gt;这类平台的目标是保持大部分代码跨平台共用，涉及到平台不共用的 API （比如 GPS 接口，iOS 和 Android 肯定是不一样的），则由 PhoneGap 平台通过 JSBridge 提供。除此之外，还有一些明显的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发效率较高：使用 HTML/CSS/JavaScript 构建界面的效率要比原生 App 速度快很多。而且前端开发有一堆现成的框架和开源库可以直接使用。&lt;/li&gt;
&lt;li&gt;即时更新：有 Bug 可以快速更新，不需要发布新 App，只需要更新服务器上更新相关的 HTML/CSS/JavaScript 即可。可以绕过 AppStore 的上架认证时间。&lt;/li&gt;
&lt;li&gt;开发门槛低：对于前端开发工程师，可以快速转岗，开发出可用的 App，不需要对 iOS 平台和 Android 平台有太深入的了解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这类平台的硬伤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单线程：JavaScript 在 WebView 里执行时是单线程的。对系统并发能力有较大的影响。&lt;/li&gt;
&lt;li&gt;性能低：大概只能达到原生 App 70% 的流畅度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/pzhtpf/article/details/25326397"&gt;这篇文章&lt;/a&gt;对几个热门的 Hybrid 平台进行了对比和介绍。&lt;/p&gt;
&lt;p&gt;为了克服 Hybrid 的缺点，目前工程应用上典型的做法是，以原生 App 为主，把易变的逻辑，以及界面，不涉及性能瓶颈的部分使用基于 WebView 的 Hybrid 技术来开发。&lt;/p&gt;
&lt;h2 id="_1"&gt;准原生平台&lt;/h2&gt;
&lt;p&gt;为了解决 Hybrid 的问题，一些其他的方案逐步流行起来，最火的要算 &lt;a href="https://facebook.github.io/react-native/"&gt;React-Native&lt;/a&gt;，它是 Facebook 基于其前端框架 &lt;a href="https://facebook.github.io/react/index.html"&gt;React&lt;/a&gt; 之上构建的跨平台 App 开发构架。&lt;/p&gt;
&lt;p&gt;这类平台的特点是，只使用 JavaScript 来构建界面，但实际上构建出来的所有界面都是系统原生控件。这是和 Hybrid 平台最大的区别。在 Hybrid 平台，一个按钮就是 HTML 构建出来的，但在 React-Native 平台，一个按钮是在各自的平台 (Android/iOS) 上以原生控件的形式渲染出来的。&lt;/p&gt;
&lt;p&gt;这类平台最大的优势是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨平台开发界面及业务逻辑：以前端工程师熟悉的构架和技术，以一致的方式构建界面和业务逻辑。&lt;/li&gt;
&lt;li&gt;即时更新：可以把业务逻辑放在 JavaScript 里，这样就可以直接在线更新功能。&lt;/li&gt;
&lt;li&gt;性能较高：比 Hybrid 性能高，大概能达到原生 App 90% 的流畅度。&lt;/li&gt;
&lt;li&gt;开发效率较高：可以使用前端技术快速构建界面。比如，熟悉 React 框架的人，可以无障碍地在 React-Native 下构建界面和业务逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这类平台和 Hybrid 相比，跟原生平台靠得更近一些，更多地依赖原生平台的一些知识。比如，很多机制，其实还是要分 iOS 平台和 Android 平台的。即无法做到真正的跨平台开发，在利用 React-Native 这类构架时，还是需要对目标平台有较深入的理解。&lt;/p&gt;
&lt;p&gt;除了 React-Native 之外，比较著名的还有 &lt;a href="http://alibaba.github.io/weex/"&gt;Weex&lt;/a&gt; 这是 alibaba 出品的一个构架，它是基于最近火热的前端构架 Vue.js 的。另外一个是 &lt;a href="https://www.nativescript.org/"&gt;NativeScript&lt;/a&gt;，这是基于老牌的前端构架 Angular&lt;br /&gt;
之上构建的。&lt;/p&gt;
&lt;p&gt;大家注意到，这些热门平台都是基于一个热门的前端构架来构建的。从这一点也可以看到这种类型的构架的目标，就是&lt;strong&gt;让前端开发人员可以在其原有知识体系里，快速开发 App ，并且使用自己熟悉的语言 JavaScript 来处理业务逻辑&lt;/strong&gt;。至于核心的代码以及性能相关的代码，还是需要使用原生编程语言 (OC for iOS, Java for Android) 来编写，不同的平台最终向上层提供一致接口。这样，上面界面部分代码，甚至一些逻辑代码就可以跨平台共用了。&lt;/p&gt;
&lt;p&gt;原理上，JavaScript 怎么样和原生平台交互呢？&lt;/p&gt;
&lt;p&gt;JavaScript 是脚本语言，可以在运行时解释并执行。这类平台上写出来的 JavaScript 代码最终是由原生平台里面的 JavaScript 引擎来负责执行的。那么 JavaScript 如何调用原生代码呢？答案是利用语言的元编程能力，OC 和 Java 都具备一定的元编程能力，这样 JavaScript 只要知道原生平台的类名称，函数名称，就可以调用到原生平台的这个函数了。&lt;/p&gt;
&lt;p&gt;关于这个课题，&lt;a href="http://www.jianshu.com/p/978c4bd3a759"&gt;这里有篇文章&lt;/a&gt;写得深入浅出。想要理解原理的同学，推荐阅读。&lt;/p&gt;
&lt;p&gt;关于这几类平台的性能对比，&lt;a href="https://my.oschina.net/vczero/blog/597980?fromerr=FY2e0zCC"&gt;这篇文章&lt;/a&gt;有非常详细的数据。&lt;/p&gt;
&lt;h2 id="_2"&gt;总结&lt;/h2&gt;
&lt;p&gt;Hybrid 技术的愿景是真正达到一次开发，跨平台运行，但其性能是其最大的瓶颈。准原生平台的目标是让前端开发人员，基于其熟悉的前端框架，快速开发 App 的&lt;strong&gt;界面和业务逻辑&lt;/strong&gt;，且其性能和原生 App 很接近。当使用准原生平台开发 App 时，除非你是全栈工程师，或者大体了解 iOS/Android 平台的一些开发知识，否则很大概率需要 iOS/Android 原生平台的开发人员配合。&lt;/p&gt;
&lt;p&gt;以下几个场景可以考虑使用 React-Native 之类的准原生架构来开发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;熟悉前端技术构架：比如熟悉 React ，则可以考虑使用 React-Native 来进行开发。如果熟悉 Vue.js ，可以考虑选择 Weex 来进行开发。&lt;/li&gt;
&lt;li&gt;对开发效率有较高的要求：特别是那些互联网创业公司，如果刚好又是个全栈工程师，可以考虑用这种技术来来提高整体开发效率，有可能一个人把 iOS/Android App 全包圆了。&lt;/li&gt;
&lt;li&gt;应用非常频繁地更新：不管是修复严重 Bug 的 HotFix ，还是业务场景快速变化，我们在等待 AppStore 审核的时候，感觉是度日如年。如果这个痛点让你痛不欲生，不仿考虑一下准原生平台方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反过来，如果你对前端开发和构架不熟，切换到任何类型的跨平台技术方案上来，成本都将是巨大的。从头学习和适应全新的开发模式，虽然最后可能提高了效率，但学习时间成本可能会是不可承受这重。至少短期来看，性价比不高。&lt;/p&gt;</summary><category term="tools"></category></entry><entry><title>瞎忙是一种福分</title><link href="http://blog.kamidox.com/busy-without-purpose.html" rel="alternate"></link><updated>2016-09-29T00:13:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-09-29:busy-without-purpose.html</id><summary type="html">&lt;p&gt;一句被广泛传播的话：选择比努力重要。还有一个说法更令人焦虑：很多时候你只是瞎忙。一下子否定了所有的努力，焦虑感油然而生。我的方向对不对？做这个事情有没有意义？做这个事情能不能对未来的成功有帮助？&lt;/p&gt;
&lt;p&gt;一个残酷的现实是，意识到选择的重要性后，并不能提高你的选择能力。反而会让你更焦虑，从而无法沉浸在你的志趣里。&lt;/p&gt;
&lt;p&gt;1985 年乔布斯离开苹果公司，创建 NeXT，收购皮克斯，他能预见到皮克斯的成功？能预见到回归苹果，把 NeXT 软件和苹果操作系统结合，从而产生 Mac/iOS 系列软件生态系统？&lt;/p&gt;
&lt;p&gt;未来不可预测。我们需要偶尔布个闲棋，就像 AlphaGo 在胶着状态下，索性到脚落里下个闲棋，最后这个闲棋还真发挥了巨大的威力。乔布斯早年痴迷字体设计，他根本无法预见有朝一日这个技能会大大提高苹果软件的颜值。&lt;/p&gt;
&lt;p&gt;刚参加工作那会儿，对 Linux 极度感兴趣，特别是 ubuntu 操作系统问世的时候，索性把家用电脑主操作系统装成了 ubuntu 。夜深人静之时，细细把玩一个个命令，醉心于 ubuntu 的紫色，阅读 GTK 源码，研究 vim ，甚至还向 GWget 提交过了一个 patch 。所有的这些，在当时看来，都是在瞎忙，跟工作毫无关系，也不知道有什么价值。仅仅是好奇，对未知世界的好奇。&lt;/p&gt;
&lt;p&gt;多年之后，接到一个任务，在嵌入式平台开发一套图形系统。之前阅读 GTK 源码，对 GUI 系统设计以及 event loop, poll 等机制了然于胸，根本没有想到这个事情的价值是通过这个契机发挥出来。由于对 ubuntu 的熟悉，让我无压力地过渡到了 macOS 系统，从而发现了一个更大，更美的世界。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;生命里的每一个点都会最终连成线。&amp;mdash;乔布斯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里的点，在当时的情境下，可能都是瞎忙。&lt;/p&gt;
&lt;p&gt;我们在公司里上着班，做着不痛不痒的工作。为什么不利用闲暇时间瞎忙一下呢？人工智能很有神奇，为什么不了解一下机器学习的算法和原理呢？前端开发技术一日千里，为什么不花点时间看看这些层出不穷的前端框架有什么区别，如何解决开发过程中的问题？后端开发怎么解决海量并发问题的？海量数据是怎么存储和检索的？甚至可以花点时间学学画画，我们的画画水平和 10 岁的小孩基本没有差别，想想都觉得有点惭愧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但行好事，莫问前程。愿好奇心不泯，愿有时间瞎忙&lt;/strong&gt;。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>跑者蓝调</title><link href="http://blog.kamidox.com/running.html" rel="alternate"></link><updated>2016-03-26T21:22:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-03-26:running.html</id><summary type="html">&lt;p&gt;不知不觉已经坚持慢跑一年有余，大概因为觉得主动长期坚持一件枯燥的事情，总会有点感悟，总觉得应该写点什么，可似乎又无从谈起。看完村上春树的《当我谈跑步时我谈些什么》，似乎找到了一些知音的感觉，还是决定写点什么吧。&lt;/p&gt;
&lt;p&gt;我们常说，真理掌握在少数人手上，大概是真理太少了的缘故。有些时候，我们手握真理，却没有足够的自信臣服于她，非得等自带光环的人说出同样的话来，我们才恍然大悟，原来这就是真理。跑步是枯燥的，跑步是痛苦的，至少对肉体而言。这一近乎真理的结论，我们大部分时间都不愿意承认它。跑步怎么这么枯燥，这么痛苦，一定是哪里出了问题，这么痛苦的事情怎么会有人坚持下去？我刚开始跑步的时候经常这么反问自己。幸好由于一些别的原因，虽然痛苦，但还是咬着牙坚持了下来。读完《当我谈跑步时我谈些什么》后，突然豁然开朗，跑步大概就是痛苦的。某种意义上，正是因为有了痛苦和枯燥，才让跑步更迷人。就像辣椒，辣椒素会刺激口腔细胞，引起灼烧般的痛感，多少人沉迷于这种痛感啊。&lt;/p&gt;
&lt;p&gt;最近一年，我认真地跑着。跑量没有村上春树那么大，但基本符合他所定义的认真二字。除了天气原因，跑步计划雷打不动，至今己累积 1300 多公里的跑量。有一次穿完跑鞋，到楼下才发现下大雨了，索性就改为跑着爬楼梯，爬了 20 趟八层楼。接下来的整整一星期，小腿肌肉都在罢工，基本无法走路，但很奇怪的是可以慢跑。大概是因为平时慢跑训练出来的肌肉群承受力足够强，但爬楼梯用到的肌肉群毕竟和跑步用到的不一样，那些养尊处优的肌肉群冷不丁经历了这么大的运动量，不罢工才怪。以前要是有人跟我说，他没办法走路，但可以慢跑，我大概是无法相信的。在小腿肌肉罢工无法走路的一星期里，我还是坚持跑了两次六公里。&lt;/p&gt;
&lt;p&gt;另外一次，我原想跑十公里，结果跑了六公里就下起了小雨。纠结了一下，突然想起一直以来想体验一下雨中狂奔的感觉，就索性继续跑下去了。清凉的雨水砸在脸上，身体慢慢地冷却了下来。可能是本能想要躲雨，速度也慢慢地提了上去。大口吸进湿润又清新的空气，肺像大脚油门轰下去的发动机，持续地输出氧气到全身细胞。注意力慢慢地从涣散状态集中到雨滴和脚步上，内心憋着一口气，想要快点结束战斗，回到温暖的家中。周遭的环境突然变得模糊起来，所有的意念只有雨滴和脚步，所有的愿力，都是想办法用最快的速度跑到前方的三米的地方。就这么机械地跑着，世界变得简单明了，只剩脸上的雨滴和脚下的步伐，世间的纷扰，得以暂时褪去。耳机里响起十公里的距离播报时，突然松了一口气，终于不用再跑啦。做完拉伸，回到家中，跟妻子说刚才跑着跑着感觉进入了深度冥想状态。妻子嘲笑着说，你跑步还能跑出高潮来。&lt;/p&gt;
&lt;p&gt;对于怎么样把枯燥而又痛苦的跑步坚持下来这件事，我也说不准。大概是为了享受跑完步后的轻松感觉。心里庆幸，终于不用再跑下去了。和跑步过程中和肌肉，心肺进行艰苦斗争相比，不用再跑下去了大概是最轻松，最让人高兴的事情了。这种经历痛苦后的轻松和常态的轻松是不可同日而语的。就像大病初愈的人，会感叹原来没有生病的日子是这么的美好，而且往往会感慨之前没生病时怎么就体会不到这种美好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只想将身体感受到的愉悦尽量维持到第二天。&amp;mdash;村上春树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对我来讲，这大概是跑步的最大动力来源了。为了快乐，我们先要经历痛苦，这样的痛苦也就显得没那么难熬了。就像凤凰涅槃一样，每一次竭尽全力地长跑过后，都感觉重生了一次。这大概也是那么多人痴迷马拉松的原因之一吧。&lt;/p&gt;
&lt;p&gt;我有个习惯，每次跑步之前拉伸时，都会宗教仪式般虔诚地在心里设定本次跑步的距离。然后每次都竭尽全力达成目标。有一次，本来只想跑六公里，跑完后感觉体力还富余很多，就想着要不跑十公里吧。结果最后的四公里跑起来异常痛苦，本来只需要集中精力好好地哄骗肌肉就好，这回还要和内心的愿力纠缠：本来跑完六公里就轻松了，这回还要再跑这么久。一旦愿力不足，执行起来就容易走样，被哄骗的肌肉就会起来造反。所幸最后的底线还是坚持住了：在承认错误之前，说到的一定做到。跑完十公里，那种轻松感比一开始就发愿跑十公里的轻松感更为强烈。成就和高度总是有代价的，而且往往和磨难成正比。&lt;/p&gt;
&lt;p&gt;跑步过程中，我一般会听着歌，但其实只是把它当背景音乐而已，没有进入音乐所要表达的情感里。伴随着机械的脚步，大脑基本处于游离状态，不停地窜出各种思绪，然后一个个地飘然而去。有时候会认真地构思一篇文章，默默地遣词造句。有时候会反思过往，就像老牛反刍，偶有所得，但也仅限于此，该忘却的一刻都强留不住。更多的时候在思考人生，这种和自己赤身祼体地对话，谈不上多喜欢，但实在是没别的可做了。偶尔还会把注意力集中在前方一米远的地板上，数着脚步前进。偶尔会听着耳边呼呼的风，偶尔会注意自己的呼吸节奏和深度，偶尔哄哄哀鸣的肌肉。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我心中滋生的新东西究竟是什么？我寻觅不到恰如其分的表达，不过，许是近乎“心灰意冷”的东西。说得夸张些，由于跑完了一百公里，我似乎一脚踏进了“稍稍不同的场所”。跑过七十五公里，疲劳感突然销声匿迹后，那段意识的空白之中，甚至存有某种哲学或宗教的妙趣。其中有强迫我内省的东西。&amp;mdash;村上春树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;村上春树所描述的“跑者蓝调”的东西，大概就是这样的吧。我不知道为什么起了这么个名字，大概和蓝调爵士一样，你沉浸其中，轻松惬意，偶有所感，时而轻吟，偶尔高吭，但你竟找不到恰当地词来准确地描述它。&lt;/p&gt;
&lt;p&gt;如果硬要问我为什么喜欢跑步，大概就是这个叫跑者蓝调的东西吧。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>用 kitabu 制作高颜值的电子书</title><link href="http://blog.kamidox.com/export-ebook-by-kitabu.html" rel="alternate"></link><updated>2017-02-26T23:15:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-03-20:export-ebook-by-kitabu.html</id><summary type="html">&lt;p&gt;辛辛苦苦用 markdown 写就了一系列文章，怎么样导出制作成一本高颜值的电子书呢？本文介绍一种在 Mac 下使用 kitabu + princexml 导出高颜值电子书的方法。&lt;/p&gt;
&lt;p&gt;本文还介绍了字体定制，排版定制，代码高亮，使用 MathJax 渲染 LaTex 数学公式等方法。&lt;/p&gt;
&lt;h2 id="_1"&gt;安装软件&lt;/h2&gt;
&lt;p&gt;首先安装 &lt;a href="https://github.com/fnando/kitabu"&gt;kitabu&lt;/a&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;gem install kitabu
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是个开源的 Ruby 包，主要提供电子书模板和制作过程自动化的功能。如果你没使用过 ruby ，可能在使用 &lt;code&gt;gem install kitabu&lt;/code&gt; 时报错 &lt;code&gt;Errno::ECONNRESET: Connection reset by peer&lt;/code&gt;，可以试试切换 taobao 的 &lt;a href="https://ruby.taobao.org"&gt;RubyGems 镜像&lt;/a&gt;：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/
$ gem sources -l
*** CURRENT SOURCES ***

https://ruby.taobao.org
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果发现无法编译 kitabu extension：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;ERROR: Failed to build gem native extension.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以试试安装命令行的 xcode 工具：&lt;code&gt;xcode-select --install&lt;/code&gt;，安装完成后，再用 &lt;code&gt;gem install kitabu&lt;/code&gt; 来安装 kitabu。需要注意的事，当升级 ruby 版本时，需要重新安装 kitabu 工具。或者切换到旧版本的 ruby 运行环境中运行。&lt;/p&gt;
&lt;p&gt;接着安装 &lt;a href="http://princexml.com"&gt;princexml&lt;/a&gt;，可以从官网 princexml.com 下载免费的安装包。princexml 会完成从 html 转为为 pdf 功能。安装完这两个工具后，可以用 &lt;code&gt;kitabu check&lt;/code&gt; 命令检查一下是否安装成功：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;bogon:~ kamidox&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;kitabu check

Prince XML: Converts HTML files into PDF files.
Installed.

KindleGen: Converts ePub e-books into .mobi files.
Installed.

html2text: Converts HTML documents into plain text.
Not installed.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我的环境里多安装了 KindleGen ，如果你需要制作 .mobi 格式的电子书，可以使用 &lt;code&gt;brew install kindlegen&lt;/code&gt; 来安装。不过这一步不是必须的。&lt;/p&gt;
&lt;h2 id="_2"&gt;制作电子书&lt;/h2&gt;
&lt;p&gt;接着在工作目录执行 &lt;code&gt;kitabu new mybook&lt;/code&gt; 即可创建 kitabu 电子书的模板：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;mybook/
├── Gemfile
├── Guardfile
├── config
│   ├── helper.rb
│   └── kitabu.yml
├── fonts
├── images
│   ├── kitabu-icon.png
│   ├── kitabu-icon.svg
│   ├── kitabu-word.png
│   ├── kitabu-word.svg
│   ├── kitabu.png
│   └── kitabu.svg
├── output
├── templates
│   ├── epub
│   │   ├── cover.erb
│   │   ├── cover.png
│   │   └── page.erb
│   ├── html
│   │   └── layout.erb
│   └── styles
│       ├── epub.scss
│       ├── files
│       │   └── _normalize.scss
│       ├── html.scss
│       ├── pdf.scss
│       └── print.scss
└── text
    ├── 01_Getting_Started.md
    ├── 02_Creating_Chapters.md
    ├── 03_Syntax_Highlighting.erb
    ├── 04_Dynamic_Content.erb
    └── 05_Exporting_Files.md
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后在 &lt;code&gt;mybook&lt;/code&gt; 目录运行 &lt;code&gt;kitabu export&lt;/code&gt; 即可在 &lt;code&gt;output&lt;/code&gt; 目录下生成电子书了。默认情况下，会生成 &lt;a href="https://github.com/fnando/kitabu/raw/master/attachments/kitabu.pdf"&gt;kitabu 使用说明文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="_3"&gt;基础配置&lt;/h2&gt;
&lt;p&gt;要制作自己的电子书，需要做些简单的配置。先把 kitabu 模板的 &lt;code&gt;text&lt;/code&gt; 目录清空，然后把自己的 markdown 文件拷贝到这个目录下，需要注意的是 kitabu 是使用文件名排序生成电子书，并且会自动把 2-6 级标题自动生成书籍的目录。如果你的 markdown 文件是以 1 级标题开始，则需要把所有的标题降一个等级。&lt;/p&gt;
&lt;p&gt;接着修改 &lt;code&gt;config/kitabu.yml&lt;/code&gt; 把书箱的作者，版权声明，出版商的信息补充完整。然后修改 &lt;code&gt;templates&lt;/code&gt; 目录下的 css 文件，让生成的电子书更漂亮。&lt;/p&gt;
&lt;p&gt;我自己主要修改两处。一是修改 &lt;code&gt;templates/styles/pdf.scss&lt;/code&gt;，在所有的 &lt;code&gt;font-family&lt;/code&gt; 字段里添加 &lt;code&gt;PingFang SC&lt;/code&gt;，以便使用 Mac 的苹方字体来显示中文，默认字体中文效果比较差。比如：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;body {
  font-family: Caslon, serif;
  font-size: 14px;
  line-height: 1.5;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改成&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;body {
  font-family: PingFang SC, Caslon, serif;
  font-size: 14px;
  line-height: 1.5;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;二是修改图片的宽度，以便电子书里的图片能自动缩放，避免大图片显示不全的问题。这个主要是修改 &lt;code&gt;templates/styles/files/_normalize.scss&lt;/code&gt;：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;img {
  border: 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改成：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;img {
  border: 0;
  width: 100%;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样生成的电子书颜值就很高了。如果你是前端工程师，折腾一下 css 可以做出更精美的电子书。&lt;/p&gt;
&lt;h2 id="_4"&gt;在电子书中插入图片&lt;/h2&gt;
&lt;p&gt;另外，我自己写作过程中，直接把图片放在本地目录，然后使用相对路径在 markdown 里生成图片，比如：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;![正弦曲线](images/ch02.01.png)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;否则就得找图床，生成电子书时还会从图床下载图片。所以直接放在本地，用相对路径引用是个相对经济的方案。默认情况下，kitabu 是不认本地相对路径的图片的。这时需要 hack 一下 kitabu，因为默认情况下，kitabu 启用了安全链接的功能，我们可以把这个功能关闭掉。&lt;/p&gt;
&lt;p&gt;首先找到 kitabu 包的安装目录，可以使用 &lt;code&gt;gem help install&lt;/code&gt; 命令，然后在输出中找 &lt;code&gt;--install-dir&lt;/code&gt; 字段，比如我的机器上有这样的输出：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;$ gem help install
  ... ...
  Defaults:
    --both --version &amp;#39;&amp;gt;= 0&amp;#39; --document --no-force
    --install-dir /usr/local/lib/ruby/gems/2.3.0 --lock
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后进入 &lt;code&gt;/usr/local/lib/ruby/gems/2.3.0/gems/kitabu-2.0.4/&lt;/code&gt; 目录，打开 &lt;code&gt;lib/kitabu/markdown.rb&lt;/code&gt; 文件，把&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;renderer &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #880000"&gt;Renderer&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;new(&lt;span style="color: #B8860B"&gt;hard_wrap&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;, &lt;span style="color: #B8860B"&gt;safe_links_only&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改为&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;renderer &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #880000"&gt;Renderer&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;new(&lt;span style="color: #B8860B"&gt;hard_wrap&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;, &lt;span style="color: #B8860B"&gt;safe_links_only&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;false&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="latex"&gt;支持 LaTex 公式&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.mathjax.org/"&gt;MathJax&lt;/a&gt; 是一个 JavaScript 库，用来渲染 LaTex 格式的数学公式。如果你想了解怎么样在 Markdown 里书写数学公式，可以参考我之前的一篇博客 &lt;a href="http://blog.kamidox.com/write-math-formula-with-mathjax.html"&gt;《使用 Markdown + MathJax 在博客里插入数学公式》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;默认情况下，kitabu 无法在渲染使用 MathJax 在 markdown 里书写的数学公式。其原因是 princexml 不支持 Window 等对象，所以 MathJax 的 JavaScript 脚本无法执行。&lt;/p&gt;
&lt;p&gt;解决这个问题的思路是，使用 &lt;a href="http://phantomjs.org"&gt;Phantomjs&lt;/a&gt; 来渲染包含 LaTex 数学公式的 html 页面，由于 Phantomjs 可以正确地执行 MathJax 的 JavaScript 脚本，所以能正确地渲染出数学公式。接着再使用 princexml 来生成 PDF 格式的电子书就可以正确地渲染出数学公式了。思路很简单，操作起来还是有点麻烦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，安装 Phantomjs 工具，可以在&lt;a href="http://phantomjs.org/download.html"&gt;官网下载&lt;/a&gt;安装适合你的操作系统的版本。在 macOS 上，下载下来的是一个绿色安装包，我把它放在硬盘的合适位置后，把 &lt;code&gt;/bin/phantomjs&lt;/code&gt; 加入到 PATH 变量里，以便在命令行中能直接执行这个命令。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;tree ~/tools/phantomjs/
~/tools/phantomjs/
├── ChangeLog
├── LICENSE.BSD
├── README.md
├── bin
│   └── phantomjs
├── examples
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;接着&lt;/strong&gt;，安装 MathJax ，方法是把 &lt;a href="https://github.com/mathjax/MathJax/archive/2.7.0.zip"&gt;MathJax&lt;/a&gt; 下载到电子书的目录。比如，你使用 &lt;code&gt;kitabu new mybook&lt;/code&gt; 时，则把 MathJax 下载后解压到 &lt;code&gt;mybook&lt;/code&gt; 目录下，我使用的是 MathJax 2.7.0 版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着&lt;/strong&gt;，再把 &lt;a href="https://raw.githubusercontent.com/kamidox/blogs/master/images/MathJaxRender.js"&gt;MathJaxRender.js&lt;/a&gt; 和 &lt;a href="https://raw.githubusercontent.com/kamidox/blogs/master/images/MathJaxConfig.js"&gt;MathJaxConfig.js&lt;/a&gt; 也下载到 &lt;code&gt;mybook&lt;/code&gt; 目录下。这两个分别是 phantomjs 渲染脚本和 MathJax 配置文件。需要&lt;strong&gt;特别注意&lt;/strong&gt;，MathJaxConfig.js 不要修改文件名，如果修改了文件名，很多引用的地方也要跟着同步修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着&lt;/strong&gt;，还要 hack 一下 kitabu，其目的是配置 Redcarpet (这是把 markdown 转成 html 的 ruby 库)，关闭智能脚本渲染，即把 &lt;code&gt;superscript&lt;/code&gt; 改为 &lt;code&gt;false&lt;/code&gt; ，否则会和 MathJax 冲突。&lt;/p&gt;
&lt;p&gt;方法是进入 &lt;code&gt;/usr/local/lib/ruby/gems/2.3.0/gems/kitabu-2.0.4/&lt;/code&gt; 目录，打开 &lt;code&gt;lib/kitabu/markdown.rb&lt;/code&gt; 文件，把&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;processor &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #880000"&gt;Redcarpet&lt;/span&gt;&lt;span style="color: #666666"&gt;::&lt;/span&gt;&lt;span style="color: #880000"&gt;Markdown&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;new(renderer, {
      &lt;span style="color: #B8860B"&gt;tables&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;footnotes&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;space_after_headers&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;superscript&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;highlight&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;strikethrough&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;autolink&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;fenced_code_blocks&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;no_intra_emphasis&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;
    })
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改为&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;processor &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #880000"&gt;Redcarpet&lt;/span&gt;&lt;span style="color: #666666"&gt;::&lt;/span&gt;&lt;span style="color: #880000"&gt;Markdown&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;new(renderer, {
      &lt;span style="color: #B8860B"&gt;tables&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;footnotes&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;space_after_headers&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;superscript&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;false&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;highlight&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;strikethrough&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;autolink&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;fenced_code_blocks&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;,
      &lt;span style="color: #B8860B"&gt;no_intra_emphasis&lt;/span&gt;: &lt;span style="color: #AA22FF"&gt;true&lt;/span&gt;
    })
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;，修改 &lt;code&gt;mybook/templates/html/layout.erb&lt;/code&gt; 文件，以便在模板里引入 MathJax 及其配置文件，方法是在其 &lt;code&gt;head&lt;/code&gt; 标签下插入如下内容，&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    &lt;span style="color: #008800; font-style: italic"&gt;&amp;lt;!-- add LaTeX support by MathJax --&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;script &lt;/span&gt;&lt;span style="color: #BB4444"&gt;type=&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;src=&amp;quot;../MathJax/MathJax.js&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;script &lt;/span&gt;&lt;span style="color: #BB4444"&gt;type=&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;src=&amp;quot;../MathJaxConfig.js&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;即，把&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;  &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;&lt;span style="border: 1px solid #FF0000"&gt;&amp;lt;&lt;/span&gt;%= title %&amp;gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;meta&lt;/span&gt; &lt;span style="color: #BB4444"&gt;http-equiv=&amp;quot;Content-type&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;content=&amp;quot;text/html; charset=utf-8&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;link&lt;/span&gt; &lt;span style="color: #BB4444"&gt;name=&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;rel=&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;type=&amp;quot;text/css&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;href=&amp;quot;styles/html.css&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;meta&lt;/span&gt; &lt;span style="color: #BB4444"&gt;name=&amp;quot;author&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;content=&amp;quot;&amp;lt;%= authors.join(&amp;#39;, &amp;#39;) %&amp;gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;meta&lt;/span&gt; &lt;span style="color: #BB4444"&gt;name=&amp;quot;subject&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;content=&amp;quot;&amp;lt;%= subject %&amp;gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;meta&lt;/span&gt; &lt;span style="color: #BB4444"&gt;name=&amp;quot;keywords&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;content=&amp;quot;&amp;lt;%= keywords %&amp;gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;meta&lt;/span&gt; &lt;span style="color: #BB4444"&gt;name=&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;content=&amp;quot;&amp;lt;%= published_at %&amp;gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;

    &lt;span style="border: 1px solid #FF0000"&gt;&amp;lt;&lt;/span&gt;%= highlight_theme %&amp;gt;
  &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改成&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;  &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;&lt;span style="border: 1px solid #FF0000"&gt;&amp;lt;&lt;/span&gt;%= title %&amp;gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;meta&lt;/span&gt; &lt;span style="color: #BB4444"&gt;http-equiv=&amp;quot;Content-type&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;content=&amp;quot;text/html; charset=utf-8&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;link&lt;/span&gt; &lt;span style="color: #BB4444"&gt;name=&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;rel=&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;type=&amp;quot;text/css&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;href=&amp;quot;styles/html.css&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;meta&lt;/span&gt; &lt;span style="color: #BB4444"&gt;name=&amp;quot;author&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;content=&amp;quot;&amp;lt;%= authors.join(&amp;#39;, &amp;#39;) %&amp;gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;meta&lt;/span&gt; &lt;span style="color: #BB4444"&gt;name=&amp;quot;subject&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;content=&amp;quot;&amp;lt;%= subject %&amp;gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;meta&lt;/span&gt; &lt;span style="color: #BB4444"&gt;name=&amp;quot;keywords&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;content=&amp;quot;&amp;lt;%= keywords %&amp;gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;meta&lt;/span&gt; &lt;span style="color: #BB4444"&gt;name=&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;content=&amp;quot;&amp;lt;%= published_at %&amp;gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008800; font-style: italic"&gt;&amp;lt;!-- add LaTeX support by MathJax --&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;script &lt;/span&gt;&lt;span style="color: #BB4444"&gt;type=&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;src=&amp;quot;../MathJax/MathJax.js&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;script &lt;/span&gt;&lt;span style="color: #BB4444"&gt;type=&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;src=&amp;quot;../MathJaxConfig.js&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;

    &lt;span style="border: 1px solid #FF0000"&gt;&amp;lt;&lt;/span&gt;%= highlight_theme %&amp;gt;
  &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完成这些步骤后，我的电子书目录看起来像这样：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;mybook/
├── Gemfile
├── Guardfile
├── MathJax
│   └── MathJax.js
├── MathJaxConfig.js
├── MathJaxRender.js
├── build-ebook.sh
├── config
├── fonts
├── images
├── output
├── templates
└── text
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;build-ebook.sh&lt;/code&gt; 的内容是这样的：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;kitabu &lt;span style="color: #AA22FF"&gt;export&lt;/span&gt; --only&lt;span style="color: #666666"&gt;=&lt;/span&gt;pdf
&lt;span style="color: #AA22FF"&gt;cd &lt;/span&gt;output
phantomjs ../MathJaxRender.js kitabu-ebook.pdf.html | prince --javascript -o ml-scikit-learn.pdf -
&lt;span style="color: #AA22FF"&gt;cd&lt;/span&gt; ..
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中调用 &lt;code&gt;phantomjs&lt;/code&gt; 的那行命令就是用来生成带数学公式的电子书的。不要忘记了这个命令最后还有一个 &lt;code&gt;-&lt;/code&gt; 字符，意思是从 stdin 里读取输入来转换为 PDF。&lt;/p&gt;
&lt;p&gt;参考文档： &lt;a href="http://www.princexml.com/forum/topic/2971/using-mathjax-with-princexml"&gt;Using MathJax with PrinceXML&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="_5"&gt;结语&lt;/h2&gt;
&lt;p&gt;差不多就这些。奋力写作吧，只为自己成为自己的出版商。&lt;/p&gt;</summary><category term="markdown"></category><category term="ebook"></category></entry><entry><title>如何写出高质量的技术博客</title><link href="http://blog.kamidox.com/thought.html" rel="alternate"></link><updated>2016-02-22T22:23:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-02-22:thought.html</id><summary type="html">&lt;p&gt;如何写出高质量的技术博客？答案是：如果你想，就一定能写出高质量的技术博客。看起来很唯心，但这就是事实。有足够愿力去做一件目标明确，有良好反馈系统的事情往往很简单。就是不停地训练，慢慢地，你自己就能找出规律和技巧。所以，要写出高质量的技术博客，首先要解决为什么要写的问题。&lt;/p&gt;
&lt;h2 id="_1"&gt;为什么要写&lt;/h2&gt;
&lt;p&gt;我一直很喜欢的一个学习方法是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Learning by teaching&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一个课题，如果你能给不懂的人解释清楚，说明你对这个课题的理解足够深入&lt;/strong&gt;。把一个课题展开来写，你可能会发现某些方面你还写不清楚，这往往说明你对这个课题的某些方面理解还不够透彻，这样从侧面会给我们一个机会去把这部分补上。所以，写出来实际上是帮助我们发现我们对知识理解的偏差，纠正我们以为自己真的已经掌握了的假象。写的目的不是为了教，而是帮助自己学习。本质上讲，写只是学习的一种手段，本质上是利己的，顺便利他而已。&lt;/p&gt;
&lt;p&gt;写带来的另外一个好处是可以让我们&lt;strong&gt;有意识地减慢学习速度&lt;/strong&gt;。减慢学习速度是为了长远意义上的快，即真正地掌握一个课题。我们在看一本书，或研究某个技术的时候，很容易有个错觉：原来是这样，我懂了。但实际上，在遇到一个类似甚至相同的问题，需要用我们学过的一个方案来解决的时候，你就会发现原来这里有一些细节没搞懂，原来只有在某个前提下，这个解决方案才是有效的。这个时候我们不得不倒回去重新研究一遍问题，然而由于上次没有研究透，所以这次研究本质上省不了多少时间。这无形中让学习的效率降低了。所以，有时候慢是为了提高效率。就象不是所有的文章都需要精读一样，不是所有的问题都需要研究透，策略选择的问题是另外一个话题了。&lt;/p&gt;
&lt;p&gt;刚学 C 语言的时候，看到书上的 hello world 程序感觉好简单。可真上机在 Turbo C 上写的时候，感觉脑袋一片空白，最典型的就是连 include 怎么写都忘记了。第一次学一门编程语言的人一定对这样的体验印象深刻。&lt;/p&gt;
&lt;p&gt;写还有一个好处就是打开了一扇与外界连接的窗户。很多人喜欢程序员这个职业的一个重要原因是人际关系简单。但这带来的一个弊端是社交关系链太少。价值往往都在一些弱连接上碰撞产生的。而写是广泛产生弱连接的一个有效的途径。很多人通过高质量的技术博客，通过 GitHub 上的写出来的一些高质量的开源代码，与更大的世界，更好的平台建立了连接。&lt;/p&gt;
&lt;h2 id="_2"&gt;怎么写&lt;/h2&gt;
&lt;p&gt;战略问题想清楚之后，战术问题相对就比较简单了：就是不停地练，不停地写。写得多了，自然就写得好了。&lt;/p&gt;
&lt;h3 id="_3"&gt;假想读者群&lt;/h3&gt;
&lt;p&gt;每篇文章都应该有个假想的读者群体。假想一个读者群体有两个好处，一是让你写的时候有的放矢，可以很容易决定哪些详细写，哪些一笔带过。另外一个好处是，增加成就感。因为你内心认可，总会有一群人认为这篇文章有价值，这会带来长期激励。&lt;/p&gt;
&lt;p&gt;不少人写的博客，看得云里雾里，象流水帐一样，只有他自己看得懂。为什么会这样？一个简单的原因是没有假想读者群，人家就根本不想写高质量的技术博客，而只是在记技术流水账和技术备忘录而已。假想读者群要求写作者清晰地定义哪些是看懂这篇技术博客所需要的基础知识。虽然这个前置条件不一定写出来，但在写作过程中一定是牢记在心里的。&lt;/p&gt;
&lt;p&gt;还有不少人不想写，觉得这个东西写出来没人看。这个想法的错误在于，写的目的不是给人看，而是让自己更有效地学习。换个角度来看，你分享的任何一个知识点，几乎都有读者。因为这个世界上总有人还不懂，需要阅读这样的东西。而总会有另外一群人已经懂了这个东西，所以他们只是不是你的假想读者群而已。还有一些人不敢写，觉得自己文笔太差。我想这就是技术博客的好处，你不需要华丽的词藻依然可以写出高质量的技术博客。&lt;/p&gt;
&lt;h3 id="_4"&gt;选题&lt;/h3&gt;
&lt;p&gt;理论上讲，技术博客不需要选题，只要你认为对你的学习有帮助就可以写。但并不是每一个课题都适合写一篇&lt;strong&gt;高质量&lt;/strong&gt;的技术博客。高质量是个外在属性，意味着高价值。什么样的课题价值高呢？有一个很简单的判断标准：你花的时间精力越多，说明价值越高，越值得写一篇博客。这也容易理解，因为别人如果也来学习这个课题，也要花很多时间精力，如果你的博客能帮助假想读者群节省学习时间，就创造了价值。&lt;/p&gt;
&lt;p&gt;当你研究了大量的资料才搞懂的一个课题，做一个高质量的参考资料索引就是一篇有价值的博客。但这个方式不利于自己学习。如果把资料消化后，通过自己的语言描述出来。再在适当的地方引用原资料。这就不但有资料索引价值，还帮助自己学习。在哪些地方重点着墨呢？把你学习过程中最难理解的点解释清楚，解释透了，价值自然就出来了。&lt;/p&gt;
&lt;h3 id="_5"&gt;模仿&lt;/h3&gt;
&lt;p&gt;另一个技巧是模仿。找到高质量的技术博客，分析它的结构，基础知识铺垫，重点着墨点，然后模仿它写出一篇相同课题的博客，回过头再对比，看哪些方面没模仿到位。怎么判断一个技术博客的质量？一个简单的原则是，你在研究某个课题，搜索后发现某一篇博客把这个课题的所有内容都解释得很清楚。这就是一篇高质量的技术博客，因为它包含足够多的资料，足够合理的解释，让研究这一课题的你看懂了。&lt;/p&gt;
&lt;h2 id="_6"&gt;结论&lt;/h2&gt;
&lt;p&gt;有一个结论，说的是在网络上，只有 1% 的用户贡献了内容，10% 的用户比较活跃，会评论和点赞，剩下的都是网络透明人，他们只是默默地在看，即不贡献内容，也不点赞。我无法对这一比例数据进行求证，但从我的简书文章的阅读/评论/点赞数据的统计来看，大致符合这一结论。&lt;/p&gt;
&lt;p&gt;这篇文章希望能让你成为网络上贡献内容的 TOP 1%。如果暂时做不到，那就先点个赞吧，成为活跃的 10%。&lt;/p&gt;</summary></entry><entry><title>词典的存储和搜索</title><link href="http://blog.kamidox.com/trie.html" rel="alternate"></link><updated>2016-02-20T22:48:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-02-20:trie.html</id><summary type="html">&lt;p&gt;在自然语言处理领域，分词是最基本的任务。不管是传统的基于词典的分词算法还是现代的基于统计语言模型的分词算法，都需要词典作为输入。本文介绍 Trie 算法，用来存储词典，并提供高效的搜索功能。&lt;/p&gt;
&lt;h2 id="_1"&gt;词典的格式&lt;/h2&gt;
&lt;p&gt;这里的词典比你书架上的现代汉语词典要简单很多，因为没有释义，只有光溜溜的一个词在那。这也好理解，释义是给人看的，而计算机根本就看不懂释义。计算机顶多只会“算”，但它算的真的很快很快，快到让人感觉它真的有智能。比如下面就是一个分词时用到的词典：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;阿
阿巴丹
阿爸
...
...
...
做贼心虚
做主
做作
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，基于现代的统计语言模型的分词算法，还需要存储词的常用程度。所以需要对词典里的词做一些标注，比如：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;反   1205
作战股 1
先人后己    1
传媒者 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由此可见，词典的数据其实是很简单的，就是一个词加上与这个词对应的一个整形数值。在实际应用中，需要非常频繁地查找词典，比如在分词算法里，我们找到两个字后，需要判断这两个字是否在词典里，如果在，就说明这是一个整体的词，如果不在，那么就不能组成一个词。所以词典的格式应该要满足&lt;strong&gt;快速查找&lt;/strong&gt;的要求。那么怎么样保存词典以便查找速度最快呢？直接把词典按照线性放在数组里显然是不行的。&lt;/p&gt;
&lt;h2 id="trie"&gt;Trie 数据结构&lt;/h2&gt;
&lt;p&gt;Trie 的读音和 Tree 相同，也有人读作 Try ，是为了和 Tree 区分开。因为在 Tree 也是数据结构的一种，容易让人误解。&lt;/p&gt;
&lt;p&gt;话说，怎么样存储词典呢？科学家们发明了一种叫做叫 Trie 的数据结构来保存词典：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Trie" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/400px-Trie_example.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图一：图片来自 wikipedia&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上图展示了 &amp;ldquo;A&amp;rdquo;, &amp;ldquo;t&amp;rdquo;, &amp;ldquo;to&amp;rdquo;, &amp;ldquo;tea&amp;rdquo;, &amp;ldquo;ted&amp;rdquo;, &amp;ldquo;ten&amp;rdquo;, &amp;ldquo;i&amp;rdquo;, &amp;ldquo;in&amp;rdquo;, &amp;ldquo;inn&amp;rdquo;。在这样的数据结构里，要查找某个词时，基本上和词典的大小无关，而只与要查找的词的大小有关。查找的速度基本上达到 O(1)。比如，我们要找 &amp;ldquo;tea&amp;rdquo; 这个词，从开始状态起步，我们的第一个字母是 &amp;ldquo;t&amp;rdquo; 则沿着根节点最左边的子树上前进到达其对应的子节点，接着是字母 &amp;ldquo;e&amp;rdquo; ，找到对应的子节点，再接着字母 &amp;ldquo;a&amp;rdquo; 找到 &amp;ldquo;tea&amp;rdquo; 这个单词。再如，我们要找 &amp;ldquo;too&amp;rdquo; 这个单词，在到达 &amp;ldquo;to&amp;rdquo; 这个节点时，还剩下一个 &amp;ldquo;o&amp;rdquo; 没有消化掉。所以 &amp;ldquo;too&amp;rdquo; 这个单词就不在上图表示的词典里。&lt;/p&gt;
&lt;p&gt;从另外一个角度看这个图，实际上这也是个&lt;strong&gt;确定有限状态机&lt;/strong&gt;(DFA - Deterministic Finite Automaton)。实际上针对 Trie 算法的实现，就是基于 DFA 的的原理进行的，所以要理解 Trie 算法，本质上需要先理解 DFA。&lt;/p&gt;
&lt;h2 id="_2"&gt;确定有限状态机&lt;/h2&gt;
&lt;p&gt;有限状态机的定义是非常严谨的，它包含一个五元组 (Q, Σ, δ, q0, F)，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Q 是一个&lt;strong&gt;有限&lt;/strong&gt;的状态&lt;strong&gt;集合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Σ 是一个有限的输入事件集合&lt;/li&gt;
&lt;li&gt;δ 是一个状态转移函数，当某个&lt;strong&gt;状态&lt;/strong&gt;遇到某个&lt;strong&gt;事件&lt;/strong&gt;时，会引起状态转换，跳到另外一个状态 (δ : Q × Σ → Q)&lt;/li&gt;
&lt;li&gt;q0 是一个起始状态 (q0 ∈ Q)&lt;/li&gt;
&lt;li&gt;F 是一组可接受的终止状态 (F ⊆ Q)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不得不说，数学家这个群体还是很令人佩服的。他们把很好理解的概念抽象抽象再抽象，抽象到我等智商平平的人看不懂的程度。当然，数学家的本意并非让我等看不懂，而是为了计算方便。另外一些人和数学家干的事正好相反，他们把很复杂的数学原理和算法，解释得通俗易懂，让大部分资质平平，没经过专业训练的人也能感受到数学之美。比如吴军老师的&lt;a href="http://book.douban.com/subject/10750155/"&gt;《数学之美》&lt;/a&gt;就是这类的典范。&lt;/p&gt;
&lt;p&gt;跑题结束，我们说回 DFA。上文讲过，我们可以把 Trie 数据结构看成是一个 DFA 。那么词典和数学家定义的 DFA 有什么关系呢？&lt;/p&gt;
&lt;p&gt;还是以图一为例，我们看一下对应关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Q 是有限状态集合。上图所有的圆圈构成了一个有限状态集合&lt;/li&gt;
&lt;li&gt;Σ 是有限的输入事件集合。上图中，引起状态转移，标注在状态转移线段上的字母就是输入事件集合，t, o, e, a, d, n, A, i, n 构成输入事件集合&lt;/li&gt;
&lt;li&gt;q0 是一个起始状态。上图中，根节点就是起始状态。&lt;/li&gt;
&lt;li&gt;F 是一组可接受的终止状态。上图中，有标注数字的圆圈就代表一个可接受的终止状态，to, tea, ted, ten, A, i, in, inn。从词典的角度考虑，所有构成合法单词的状态就是可接受的终止状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述对应关系里，我们漏了状态转移函数。&lt;strong&gt;确定有限状态机&lt;/strong&gt;的关键点在&lt;strong&gt;状态转移&lt;/strong&gt;上，如果当前状态遇到一个确定的事件时，&lt;strong&gt;最多&lt;/strong&gt;只能转移到&lt;strong&gt;一个确定的状态&lt;/strong&gt;上，那么这就是一个&lt;strong&gt;确定有限状态机&lt;/strong&gt;，简称 DFA。为什么有&lt;strong&gt;最多一个确定状态&lt;/strong&gt;这一说法？因为可能没有下一个状态，对词典的例子来说，如果没有下一个状态，就说明要查找的词不在词典里。比如我们要查找 &amp;ldquo;too&amp;rdquo; 这个单词，当消耗完 &amp;ldquo;t&amp;rdquo;, &amp;ldquo;o&amp;rdquo; 两个字母后，还剩下一个 &amp;ldquo;o&amp;rdquo; ，这个时候应该还要有下一个由 &amp;ldquo;o&amp;rdquo; 触发的确定的状态才对，但在上图中找不到，说明 &amp;ldquo;too&amp;rdquo; 这个单词不在上图表示的词典里。&lt;/p&gt;
&lt;p&gt;聪明的你可能会问，如果一个输入事件，导致可能转移到不同的状态去，每种状态有不同的概率，这是什么？答案是&lt;strong&gt;不确定有限状态机&lt;/strong&gt;。感兴趣的搜索一下马尔可夫链。等你研究完马尔可夫链会发现，下一步要看隐马尔可夫模型了。咳咳，这段文字纯属装逼，我们还是就此打住，继续今天的课题吧。&lt;/p&gt;
&lt;h2 id="_3"&gt;状态转移表&lt;/h2&gt;
&lt;p&gt;我们终于把 Trie 和 DFA 联系起来了。在 DFA 里，状态转移函数一般使用&lt;strong&gt;状态转移表&lt;/strong&gt;来描述。这是个二维的表格，行用来表示所有的状态集合，列用来表示输入事件集合。&lt;/p&gt;
&lt;p&gt;我们来看一个最简单的使用 Trie 描述的词典：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;           t        o
begin(0) ---&amp;gt; t(1) ---&amp;gt; to(2:F)
                   |
                   | e          a
                   ----&amp;gt; te(3) ---&amp;gt; tea(4:F)
                               |
                               | d
                               ---&amp;gt; ted(5:F)
                               |
                               | n
                               ---&amp;gt; ten(6:F)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是本文示例图片的一小部分，这个词典只包含四个单词，分别是 to, tea, ted, ten。从 DFA 的角度来看，它总共有 7 个状态，包含一个状态为 0 的起始状态。输入事件集合是 [t, o, e, a, d, n]。可接受的终止状态集合就是上图中标注着 &amp;ldquo;:F&amp;rdquo; 字样的状态，就是四个有效的单词。那么上述词典所代表的 DFA 的的状态转移表长什么样呢？&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;state&lt;/th&gt;
&lt;th&gt;t&lt;/th&gt;
&lt;th&gt;o&lt;/th&gt;
&lt;th&gt;e&lt;/th&gt;
&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;d&lt;/th&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;表一：状态转移表&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这就是上述 DFA 的状态转移表。从表中，我们可以清晰地看到。[0, 1, 2, 3, 4, 5, 6] 表示我们的 DFA 中的 7 个状态。而 [t, o, e, a, d, n] 表示我们的输入事件。表格中的数字表示当前状态遇到输入事件后能正确转移的下一个状态，其中 x 表示出错，即无法转移到下一个有效状态。比如当状态为 0 时，遇到 t 即可转移到状态 1，而遇到其他的输入事件，则无法转移到有效状态。聪明如你，试着画一下图一的状态转移表吧。&lt;/p&gt;
&lt;h2 id="trie_1"&gt;双数组 Trie&lt;/h2&gt;
&lt;p&gt;状态转移表很好很强大，可以实现 O(1) 的搜索速度。但其不足非常明显，如表一所示，表中 x 非常多。即针对词典来说，其 DFA 的状态转移表中，有效的状态转移只占少数，大部分都是无效的状态转移。聪明的科学家们哪能放过这个扬名立万的机会？特别是在计算机的早期，内存非常宝贵，往往以字节计算价格，哪像现在，各位的手机动不动就有几个 G 的内存。&lt;/p&gt;
&lt;p&gt;在 1985 年科学家发明了一个压缩算法，可以用三个数组即可表达状态转移表。1989 年更进一步压缩到只用两个数组即可表达状态转移表。详细信息可以阅读 &lt;a href="http://linux.thai.net/~thep/datrie/datrie.html"&gt;An Implementation of Double-Array Trie&lt;/a&gt;。这个页面里包含两个实现，一个是早期的使用 C++ 模板类的实现，称为 midatrie ，网上比较著名的开源分词算法库 &lt;a href="http://www.coreseek.cn/opensource/mmseg/"&gt;LibMMSeg&lt;/a&gt; 就使用这一实现。另外一个实现是使用 C 语言重写的，称为 libdatrie，它更通用，可读性也比较强。&lt;/p&gt;
&lt;p&gt;要使用两个数组实现 Tire 并非简单的事情，要理解这一过程没有烧些脑细胞估计很难做到，除非你是个天才。除此之外，还有一些细节需要了解，对理解代码不无益处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上文讨论中，我们都使用英文作为词典保存对象。输入事件集合就是一个个字母。实际上，中文的处理方法类似，如果是 utf-8 编码，中文会把一个字拆成三个字节，然后以字节为单位，作为输入事件集合中的一个元素。比如“中文”这两个字的 utf-8 编码是 E4 B8 AD E6 96 87，其实际上被解读为 6 个输入事件。由此可见，对任何语言，输入事件总数不会超过 255 个。可以使用一个字节来表示。&lt;/li&gt;
&lt;li&gt;输入事件并非连续的，所以在实现 Tire 时，一般会有个映射关系，比如把 a 映射到 1，把 b 映射到 2 等。这是为了更进一步节省空调。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_4"&gt;应用场景&lt;/h2&gt;
&lt;p&gt;Trie 构造的词典除了在分词算法里使用外，在自动完成 Auto Complete，拼写纠正等领域都有非常广泛的应用。&lt;/p&gt;</summary><category term="nlp"></category></entry><entry><title>《十二公民》观后感</title><link href="http://blog.kamidox.com/twelve-citizen.html" rel="alternate"></link><updated>2016-01-12T23:22:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-01-12:twelve-citizen.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;独立思考是终极目标，如果做不到，至少保持客观理智。&amp;mdash; 《十二公民》观后感&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;前方剧透，不想破坏观看体验的请绕道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为看过《十二怒汉》的人，坦白讲电影情节没有什么惊喜。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十二公民的剧情简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;某高校模拟法庭，正就社会上不久前发生的一起真实案件展开辩论。案件的嫌疑人是某房地产商收养的富二代，其生父是来自河南的务工人员。案发当晚，有人听到富二代和其生父发生激烈争吵，随后生父被人在家中杀害。学生们围绕嫌疑人是否有罪展开激烈辩论，而他们的父亲作为陪审团观摩整个法庭的审判过程。休庭期间，12名陪审员被带到另一个房间展开讨论，他们必须在一个小时内得出结论，而且需要全票通过嫌疑人是否有罪。这些人来自各行各业，有着不同的背景。大家普遍希望尽快敷衍了事，谁知第一轮投票过后，只有8号陪审员（何冰 饰）认为嫌疑人无罪。有的人暴跳如雷、有的人奚落戏谑、有的人摇摆不定、有的则固执己见。这是一场关于良心和道义的鏖战……&lt;br /&gt;
本片根据经典影片《十二怒汉》改编。&amp;mdash; 豆瓣&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结合国情的二次创作还是有很多可圈可点的地方。特别是二次创作的台词很接地气。看完感触良多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理性沟通是通往真理的唯一道路&lt;/li&gt;
&lt;li&gt;很多时候，我们反对某个观点，仅仅是因为那个观点是别人的，仅此而已&lt;/li&gt;
&lt;li&gt;这是一场最成功的头脑风暴，团队里的大部分成员都在通往真相的道路上贡献了自己的力量&lt;/li&gt;
&lt;li&gt;即使和蛮不讲理的人沟通，也需要维护他们说话的权利。这会带来两个惊喜，一是他们的观点讲出来后，会有更多的人对这个观点乃至这个人的思维模式产生怀疑。无形中，蛮不讲理的人的看似在表达自己的观点，其实是帮助我们拉到更多的支持者。二是他们蛮不讲理可能仅仅只是一种情绪的积累，他们需要宣泄，宣泄过后可能他们就会回归理性。&lt;/li&gt;
&lt;li&gt;事情的发展往往会出乎意料。8 号陪审员在刚开始质疑的时候，其实也没有完全想通怎么去质疑整个证据链，但众人拾柴火焰高，所有的关键证据都逐个被一一击破了。&lt;strong&gt;深思熟虑是好的，但最好用在大方向上&lt;/strong&gt;，千万不要用在细节上。一旦陷入细节，就无法抽身。普通人连 735 x 382 这样的三位数相乘都无法心算，哪来那么大的“内存”去为现实世界里的复杂问题进行“心算”？有时候特别佩服那些创业者，想清楚大方向后，就甩开膀子开干，边干边想对策，逐个解决问题。而更多的人是夜里想想千万条路，早上醒来走老路。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4 号陪审员戏份不多，但却给我留下了非常深的映像，不是因为他有钱，或泡了奶茶。他是&lt;strong&gt;倒数第二个&lt;/strong&gt;赞成无罪的陪审员。也只有他，在&lt;strong&gt;关键证据&lt;/strong&gt;被有效地质疑前，始终保持客观理智地坚持有罪论断。当关键证据被成功质疑之后，他说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;向真理低头是个幸福的事&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="向真理低头是个幸福的事" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/12_citizen.png" /&gt;&lt;/p&gt;
&lt;p&gt;除了 9 号陪审员赞成无罪只是想让大家能继续讨论这个案子外，其他人立场都不够坚定。都在关键证据（女目击主人的证据）被有效质疑前，就早早地缴械投降了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;独立思考是终极目标，如果做不到，至少保持客观理智&lt;/strong&gt;。这是 9 号陪审员给我的最深的触动。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>文艺地解读贝叶斯定理</title><link href="http://blog.kamidox.com/bayes-theorem.html" rel="alternate"></link><updated>2016-01-06T23:43:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2016-01-06:bayes-theorem.html</id><summary type="html">&lt;p&gt;小李年方二八，身强力壮。参加单位组织的体检时，被检出 AIDS 呈阳性。这惊雷轰得小李不省人事：自己明明生活检点，从没做过可能感染 AIDS 的不良行为，这闹的是哪出啊！&lt;/p&gt;
&lt;p&gt;假设整个人群 AIDS 发病率是 0.08%。这家医院使用的检测方法对已经确诊的 AIDS 病人检测出阳性的概率是 99% (true positive rate)，对没有携带 AIDS 病毒的人检测呈阴性的概率是 99% (true negative rate)。聪明如你，帮小李算算他确实携带 AIDS 病毒的概率是多少？&lt;/p&gt;
&lt;p&gt;不着急，再想 5 分钟 ......&lt;/p&gt;
&lt;p&gt;答案是 7.34%。&lt;/p&gt;
&lt;p&gt;一个简单而自然的算法是假设总共有 10000 人，由于 AIDS 发病率是 0.08%，所以总共有 8 个人携带 AIDS 病毒。由于没有携带 AIDS 病毒的人检测呈阴性的概率是 99% ，所以这家医院使用的检测方法有 1% 的概率会导致没有携带 AIDS 病毒的人被检测呈阳性，即 10000 人中总共会有 (10000 - 8) * 1% = 99.92 人实际上没有携带 AIDS 病毒，但检测出了阳性。针对己确诊患病的 8 人中，会有 8 * 99% = 7.92 人检测呈阳性。所以，小李携带 AIDS 病毒的概率是 7.92 / (99.92 + 7.92) = 7.34%。嗯，虽如晴天惊雷，但其实概率也没那么高嘛，特别是小李生活检点，不吸毒的前提下，误诊的概率极大。&lt;/p&gt;
&lt;p&gt;wikipedia 上有个&lt;a href="https://en.wikipedia.org/w/index.php?title=Base_rate_fallacy&amp;amp;redirect=no"&gt;专门的条目&lt;/a&gt;讨论这种忽视基础概率问题的页面。&lt;/p&gt;
&lt;h2 id="_1"&gt;贝叶斯定理&lt;/h2&gt;
&lt;p&gt;贝叶斯定理是关于条件概率的定理，其公式如下：&lt;/p&gt;
&lt;p&gt;P(A|B) = P(A) P(B|A) / P(B)&lt;/p&gt;
&lt;p&gt;解释一下公式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P(A), P(B) 表示事件 A 和事件 B 的独立发生概率&lt;/li&gt;
&lt;li&gt;P(A|B) 是个条件概率，表示当事件 B 发生的情况下，事件 A 发生的概率&lt;/li&gt;
&lt;li&gt;P(B|A) 也是个条件概率，表示当事件 A 发生的情况下，事件 B 发生的概率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们用贝叶斯定理再算一下小李的患病概率，假设 A 表示携带 AIDS 病毒事件，B 表示检测结果呈阳性事件，那么我们要求解的就是在检测结果呈阳性的情况下的真实患病概率，即 P(A|B)。P(A) 表示患病概率，在我们的例子里是 0.08%。P(B|A) 表示如果一个人己确诊患病，检测呈阳性的概率是多少，从例子里知道 P(B|A) = 99%。P(B) 表示随机一个人被检测呈阳性的概率是多少，这包括两部分的数据，一部分是患病且被检测呈阳性的概率，它的数值是 0.08% * 99%，另一部分没患病但被检测呈阳性的概率，它的数值是 (1 - 0.08%) * (1 - 99%)。根据贝叶斯定理：&lt;/p&gt;
&lt;p&gt;P(A|B) = P(A) P(B|A) / P(B) = 0.08% * 99% / ((0.08% * 99%) + (1 - 0.08%) * (1 - 99%)) = 7.34%&lt;/p&gt;
&lt;p&gt;看来和我们的土办法算出来的数值是相同的。&lt;/p&gt;
&lt;h2 id="_2"&gt;解读贝叶斯定理&lt;/h2&gt;
&lt;p&gt;就象解读这个千疮百孔的世界一样，很多人选择把眼睛闭起来，选择对它视而不见。而一些人选择热爱这个千疮百孔的世界，努力前行，让这个世界变得美好一点点。&lt;/p&gt;
&lt;p&gt;文艺地解读贝叶斯定理是可能的。P(A) 是基础概率，每个人刚来到这个世界上时，对这个世界的美好感受都有一个初始值，随着他的不断成长，碰到了事件 B ，而 B 刚好是这个世界美好的一面，比如一个学渣被女神鼓励，然后奋发图强，变成学霸，那么事件 B 的发生无疑会增加这个人对这个世界的美好程度的感知，所以 P(A|B) 增加了。身体发肤，受之父母。有些人的颜值就是比较高，高颜值的你如果是学渣的话，被女神鼓励的概率应该也是会比较高的，不知不觉，你的先天优势让 P(B|A) 更高。&lt;/p&gt;
&lt;p&gt;这是对贝叶斯定理最文艺的解读，没有之一。&lt;/p&gt;
&lt;p&gt;然并卵。除了看完感觉有道理之外，你还是不理解贝叶斯定理定理的本质。一个事物的本质往往是朴素的，朴素到没有女神，颜值也处在正态分布的正中间。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Bayesian interpretation" src="https://upload.wikimedia.org/wikipedia/commons/b/bf/Bayes_theorem_visualisation.svg" /&gt;&lt;/p&gt;
&lt;p&gt;维基百科上的这张图包含了简易的推导贝叶斯定理的过程，简洁，朴素。&lt;/p&gt;
&lt;p&gt;而从事件发生频率角度解读贝叶斯定理的的另外一张图片，让我们和贝叶斯走得更近。&lt;/p&gt;
&lt;p&gt;&lt;img alt="frequentist interpretation" src="https://upload.wikimedia.org/wikipedia/commons/6/61/Bayes_theorem_tree_diagrams.svg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学点概率，用更朴素的视角去看这个世界。&lt;/strong&gt;&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>我的时间去哪儿了</title><link href="http://blog.kamidox.com/time-event-log.html" rel="alternate"></link><updated>2021-12-15T23:36:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-12-21:time-event-log.html</id><summary type="html">&lt;p&gt;我的时间去哪儿了？李笑来在他的《把时间当朋友》里提到时间事件日志的方法，可以帮助发现这个问题的答案。本文介绍一种更简洁更直观的方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间就是生命。&amp;mdash;鲁迅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解并践行这句话比我们想象得要难得多。今天我准备用数据来回答这个问题：我的时间去了哪儿？&lt;/p&gt;
&lt;h2 id="_1"&gt;效果预览&lt;/h2&gt;
&lt;h3 id="_2"&gt;时间总览&lt;/h3&gt;
&lt;p&gt;&lt;img alt="时间总览" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/dida365_pie_chart.png" /&gt;&lt;/p&gt;
&lt;p&gt;从这个图表可以清晰地看到 dida365 里面各个顶层类别事件的时间分配。看看那个&lt;strong&gt;时间黑洞&lt;/strong&gt;，那些就是被偷走的时间。&lt;/p&gt;
&lt;h3 id="_3"&gt;工作负荷&lt;/h3&gt;
&lt;p&gt;&lt;img alt="工作负荷" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/dida365_workload_chart.png" /&gt;&lt;/p&gt;
&lt;p&gt;从时间维度查看我们的工作负荷。一目了然。&lt;/p&gt;
&lt;h3 id="_4"&gt;精力分配&lt;/h3&gt;
&lt;p&gt;&lt;img alt="工作负荷" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/dida365_pie_chart_sec.png" /&gt;&lt;/p&gt;
&lt;p&gt;顶层事件类型下可以有事件子类别，从精力分配图可以清晰地看出来我们的时间花在哪些事情上了。&lt;/p&gt;
&lt;h3 id="_5"&gt;持续行动&lt;/h3&gt;
&lt;p&gt;&lt;img alt="持续行动" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/dida365_pa_chart.png" /&gt;&lt;/p&gt;
&lt;p&gt;选定我们感兴趣的事件类型，我们可以查看一定周期内，我们的精力投入情况。监督自己持续行动。&lt;/p&gt;
&lt;h2 id="_6"&gt;需要的工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GTD 工具&lt;br /&gt;
&lt;a href="https://www.dida365.com"&gt;dida365.com&lt;/a&gt;是个良心产品。如果你不了解 GTD 方法论，可以在 &lt;a href="http://baike.baidu.com/view/406078.htm"&gt;百度百科&lt;/a&gt; 上了解一下。&lt;/li&gt;
&lt;li&gt;统计脚本&lt;br /&gt;
  使用 pandas 实现的一个 &lt;a href="https://github.com/kamidox/utils"&gt;Python 统计脚本&lt;/a&gt;。目前没有做成 Web 产品，对非程序员可能会有点门槛。目前的脚本只适配 dida365 的数据格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_7"&gt;使用说明&lt;/h2&gt;
&lt;h3 id="dida365"&gt;步骤一：利用 dida365 记录时间事件日志&lt;/h3&gt;
&lt;p&gt;像平常一样在 dida365 上完成 GTD 工作，在记录事件时注意以下规则，用来增加子类别和记录事件的时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dida365 上的&lt;code&gt;清单&lt;/code&gt;就是我们事件的主类别，可以建立多个清单&lt;/li&gt;
&lt;li&gt;每个清单的事件标题按照 &lt;code&gt;[子类别] 事件标题 [时长]&lt;/code&gt; 这样的格式来记录。比如&lt;code&gt;[写作] 博客《时间事件日志》[1.2h]&lt;/code&gt;。时长支持 &lt;code&gt;h&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt; ，分别表示小时和分钟&lt;/li&gt;
&lt;li&gt;给任务分配预期完成时间。统计脚本在统计一个工作在什么时候完成的，是根据预期完成时间来算的，而不是根据点击完成复选框的时间来算的。理由是点击完成的时间是不能变的，比如某个事情忘了记录，过了两天才记录，这个时候点完成，则完成时间是点击完成的那个时间点，而预期完成时间我们可以设置在两天前，这样这项工作就会记录在两天前。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_8"&gt;步骤二：导出数据&lt;/h3&gt;
&lt;p&gt;进入 dida365 的用户&lt;code&gt;设置&lt;/code&gt;界面，点击&lt;code&gt;数据备份&lt;/code&gt;，再点击&lt;code&gt;生成备份&lt;/code&gt;。这一动作会在电脑端保存一份所有你记录在 dida365 上的时间事件日志，这是个 csv 格式的文件。&lt;/p&gt;
&lt;h3 id="_9"&gt;步骤三：生成统计图表&lt;/h3&gt;
&lt;p&gt;下载 &lt;a href="https://github.com/kamidox/utils"&gt;Python 统计脚本&lt;/a&gt;。安装 matplotlib, pandas 等必要的库。参考下面的 demo 代码。注释已经把用法写清楚了。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# dida_20151220.csv 是从 dida365.com 上导出的你的时间事件日志，可以取任意你喜欢的文件名&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# 用这个文件作为输入，创建时间事件日志对象&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# 参数 routine_duration 为每天固定的例行公事时间长度（吃，喝，拉，撒，睡，行，发呆），单位为小时&lt;/span&gt;
log &lt;span style="color: #666666"&gt;=&lt;/span&gt; DidaEventLog(&lt;span style="color: #BB4444"&gt;&amp;#39;dida_20151220.csv&amp;#39;&lt;/span&gt;, routine_duration&lt;span style="color: #666666"&gt;=14&lt;/span&gt;)
&lt;span style="color: #008800; font-style: italic"&gt;# 设定要统计的时间周期&lt;/span&gt;
period &lt;span style="color: #666666"&gt;=&lt;/span&gt; (&lt;span style="color: #BB4444"&gt;&amp;#39;2015-12-1&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;2015-12-20&amp;#39;&lt;/span&gt;)
&lt;span style="color: #008800; font-style: italic"&gt;# 生成时间总览饼图&lt;/span&gt;
log&lt;span style="color: #666666"&gt;.&lt;/span&gt;pie_chart(period&lt;span style="color: #666666"&gt;=&lt;/span&gt;period, display_routine&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
&lt;span style="color: #008800; font-style: italic"&gt;# 生成工作负荷图表&lt;/span&gt;
log&lt;span style="color: #666666"&gt;.&lt;/span&gt;workload_chart(period&lt;span style="color: #666666"&gt;=&lt;/span&gt;period)
&lt;span style="color: #008800; font-style: italic"&gt;# 生成某个主类别下的子类别的精力分配情况&lt;/span&gt;
log&lt;span style="color: #666666"&gt;.&lt;/span&gt;pie_chart_secondary(&lt;span style="color: #BB4444"&gt;&amp;#39;自我成长&amp;#39;&lt;/span&gt;, period&lt;span style="color: #666666"&gt;=&lt;/span&gt;period)
&lt;span style="color: #008800; font-style: italic"&gt;# 生成某个类别的时间投入情况，fields 参数可以是主类别也可以是子类别&lt;/span&gt;
log&lt;span style="color: #666666"&gt;.&lt;/span&gt;permanent_action_chart(fields&lt;span style="color: #666666"&gt;=&lt;/span&gt;[&lt;span style="color: #BB4444"&gt;&amp;#39;机器学习&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;写作&amp;#39;&lt;/span&gt;], period&lt;span style="color: #666666"&gt;=&lt;/span&gt;period)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_10"&gt;参数说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时间黑洞&lt;/strong&gt;&lt;br /&gt;
  那些发呆走神，刷微博微信的时间就是黑洞时间。我们要想办法把时间黑洞降到 20% 以下。那些为自己理想打着鸡血，走在万众创业路上的同学，估计时间黑洞会为负数。为什么呢？因为他们牺牲了吃喝拉撒睡等例行公事的时间，想着每天要睡够 7 小时，结果只有 5 小时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例行公事&lt;/strong&gt;&lt;br /&gt;
  我们要睡觉，交通也要花时间，吃饭也要花时间。这部分我们称为例行公事，每天相对比较固定，简单起见，统计时，我们就取个固定值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_11"&gt;总结&lt;/h2&gt;
&lt;p&gt;行动起来吧，和我们的时间作朋友，管理我们自己。当你持续记录一个星期，一个月，一年后，再回过头看这些数据时，你一定会吓一跳。最终，我们才能慢慢理解并践行&lt;code&gt;时间就是生命&lt;/code&gt;这句话的真正内涵。&lt;/p&gt;</summary><category term="tools"></category></entry><entry><title>基于协同过滤算法的推荐系统</title><link href="http://blog.kamidox.com/recommend-system.html" rel="alternate"></link><updated>2015-12-19T22:36:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-12-19:recommend-system.html</id><summary type="html">&lt;h2 id="_1"&gt;推荐系统的描述&lt;/h2&gt;
&lt;p&gt;我们以电影推荐系统来看一下怎么样以机器学习的角度来描述推荐系统。我们记 $n_u$ 为用户的数量，$n_m$ 为电影的数量，$r(i,j) = 1$ 表示用户 j 对电影 i 进行过了评价，$y^{(i,j)}$ 就是它的分数。$r(i,j) = 0$ 表示用户还没观看过这个电影，也没评分过。我们假设用户看过电影后，一定会给电影一个评分，如果没有给，默认评分为零。这样，我们的电影推荐系统的任务，就是根据用户的评分，预测出那些用户还未观看的电影的评分，从而把那些用户可能会给出较高评分的电影推荐给用户。&lt;/p&gt;
&lt;h2 id="_2"&gt;基于内容的推荐算法&lt;/h2&gt;
&lt;p&gt;我们依然以电影推荐系统为例，我们假设 $\theta^{(j)}$ 表示用户 j 的参数，$x^{(i)}$ 为电影 i 的特征向量 (比如爱情电影，动作电影，好吧，如你所愿，可能还有爱情动作片)。这样，用户 j 对电影 i 的预测评分为 $(\theta^{(j)})^T (x^{(i)})$。&lt;/p&gt;
&lt;p&gt;接下来的目标，是怎么样获得用户 j 的参数 $\theta^{(j)}$？这个实际上是个线性回归问题，即我们利用用户对现有电影的所有的评分学习出其参数 $\theta^{(j)}$。根据线性回归算法的成本公式，我们的目标是求解线性回归算法的成本函数的最小值时，$\theta^{(j)}$ 的值。假设 $m^{(j)}$ 是用户 j 评价过的电影的总数。n 为电影的特征数。&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta^{(j)}) = \frac{1}{2m^{(j)}} \left[ \sum_{i:r(i,j)=1} \left( (\theta^{(j)})^T (x^{(i)}) - y^{(i,j)} \right)^2 + \lambda \sum_{k=1}^n (\theta_k^{(j)})^2 \right]&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这里的 $\theta^{(j)} \in R^{n+1}$。累加器部分是指用户所有己评分的电影进行累加。&lt;/p&gt;
&lt;p&gt;求解 $\theta^{(j)}$ 的过程就是最小化成本函数的过程。在数学上，我们可以稍微改造一下，得到基于内容的推荐算法的目标函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;求解用户 j 的参数 $\theta^{(j)}$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;求下面这个成本函数的最小值，就得到了用户 j 的参数 $\theta^{(j)}$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\frac{1}{2} \sum_{i:r(i,j)=1} \left( (\theta^{(j)})^T (x^{(i)}) - y^{(i,j)} \right)^2 + \frac{\lambda}{2} \sum_{k=1}^n (\theta_k^{(j)})^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;求解所有用户的参数 $\theta^{(1)}, \theta^{(2)}, &amp;hellip; , \theta^{(n_u)}$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;叠加所有的用户，求下面成本函数的最小值，就得到了所有用户的参数。&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\frac{1}{2} \sum_{j=1}^{n_u} \sum_{i:r(i,j)=1} \left( (\theta^{(j)})^T (x^{(i)}) - y^{(i,j)} \right)^2 + \frac{\lambda}{2} \sum_{j=1}^{n_u} \sum_{k=1}^n (\theta_k^{(j)})^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;根据线性回归算法介绍过的内容，针对针对 $k=0$，我们不取正则项。则其参数迭代公式为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_k^{(j)} = \theta_k^{(j)} - \alpha \left( \sum_{i:r(i,j)=1} \left( (\theta^{(j)})^T - y^{(i)} \right) x_k^{(i)} \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;根据线性回归算法介绍过的内容，针对 $k \ne 0$，包含正则项的迭代公式。其参数迭代公式为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_k^{(j)} = \theta_k^{(j)} - \alpha \left( \sum_{i:r(i,j)=1} \left( (\theta^{(j)})^T x^{(i)} - y^{(i)} \right) x_k^{(i)} + \lambda \theta_k^{(j)} \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 $\alpha$ 是学习率。&lt;/p&gt;
&lt;h2 id="collaborative-filtering"&gt;协同过滤算法 (Collaborative Filtering)&lt;/h2&gt;
&lt;p&gt;基于内容的推荐算法需要对推荐对象提取特征，构成特征向量。我们还是拿电影推荐系统为例，需要对电影进行特征提取，如爱情片，动作片，然后对所有的电影进行特征采集，即针对每个电影写出其爱情成分是多少分，动作成分是多少分。这在工程上工作量非常大。&lt;/p&gt;
&lt;p&gt;换一个方法，我们可以在用户注册的时候，让用户告诉我们他的偏好，比如用户喜欢哪些类型的电影。即我们通过调查问卷，事先知道了用户 j 的参数 $\theta^{(j)}$。再根据用户的对看过的电影的评分数据，去推断出电影属于哪种类型，即电影的特征向量 $x^{(i)}$。针对用户 j 没有看过的电影 i ，根据 $(\theta^{(j)})^T (x^{(i)})$ 预测出用户可能的评分，根据预测出来的评分高低，去决定是否向用户推荐这部电影。&lt;/p&gt;
&lt;p&gt;怎么样从数学上描述这个过程呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算电影 i 的特征向量 $x^{(i)}$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选取合适的 $x^{(i)}$ ，以便让下面的公式值最小。这是求解电影 i 的特征向量 $x^{(i)}$ 的过程。&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\frac{1}{2} \sum_{i:r(i,j)=1} \left( (\theta^{(j)})^T (x^{(i)}) - y^{(i,j)} \right)^2 + \frac{\lambda}{2} \sum_{k=1}^n (x_k^{(i)})^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;求解所有电影的特征 $x^{(1)}, x^{(2)}, &amp;hellip; , x^{(n_m)}$&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选取合适的 $x^{(1)}, x^{(2)}, &amp;hellip; , x^{(n_m)}$ ，以便让下面的公式值最小。&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\frac{1}{2} \sum_{i=1}^{n_m} \sum_{i:r(i,j)=1} \left( (\theta^{(j)})^T (x^{(i)}) - y^{(i,j)} \right)^2 + \frac{\lambda}{2} \sum_{i=1}^{n_m} \sum_{k=1}^n (x_k^{(i)})^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;h3 id="_3"&gt;协同过滤算法&lt;/h3&gt;
&lt;p&gt;实际工程应用上，事先知道用户 j 的参数 $\theta^{(j)}$ 也是件很难的事。我们从之前的内容知道，有了所有的用户参数 $\theta^{(j)}$，我们就可以估算出电影的特征向量 $x^{(i)}$。或者如果有了电影的特征向量 $x^{(i)}$，我们可以算出用户的偏好参数 $\theta^{(j)}$。这看起来象是个鸡生蛋和蛋生鸡的问题。&lt;/p&gt;
&lt;p&gt;实际上，协同过滤算法就是为了解决这个问题的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先随机估算出用户参数 $\theta^{(j)}$&lt;/li&gt;
&lt;li&gt;利用估算出来的 $\theta^{(j)}$ 和用户看过的电影的评分数据，估算出特征向量 $x^{(i)}$&lt;/li&gt;
&lt;li&gt;利用估算出来的特征向量 $x^{(i)}$，反向估算出用户偏好参数 $\theta^{(j)}$&lt;/li&gt;
&lt;li&gt;重复步骤 2 ，直到用户参数 $\theta^{(j)}$ 和特征向量 $x^{(i)}$ 收敛到一个合适的值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这就是协同过滤算法的核心步骤。协同过滤的一个重要的效应是，&lt;strong&gt;当用户对某个电影进行评分时，会帮助算法学习电影的特征，这有利于系统向所有用户推荐合适的电影，同时也让算法更好地学习到用户的偏好&lt;/strong&gt;。这样所有用户不停地使用系统的过程中，无形中在协同过滤，帮助系统学习出更好的参数，从而更准确地推荐出用户喜欢的电影。&lt;/p&gt;
&lt;h3 id="_4"&gt;协同过滤算法的实现&lt;/h3&gt;
&lt;p&gt;上一节描述的协同过滤算法需要不停地计算 $\theta^{(j)}$ 和 $x^{(i)}$，这样算法的效率实际上是比较低的。从数学角度，一个更高效的算法是把计算 $\theta^{(j)}$ 和 $x^{(i)}$ 的两个成本函数合并起来，得到以 $\theta^{(j)}$ 和 $x^{(i)}$ 为参数的总成本函数，最小化这个成本函数，就可以同时求出 $\theta^{(j)}$ 和 $x^{(i)}$ 的值。&lt;/p&gt;
&lt;p&gt;总成本函数为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J = \frac{1}{2} \sum_{(i,j):r(i,j)=1} \left( (\theta^{(j)})^T (x^{(i)}) - y^{(i,j)} \right)^2 + \frac{\lambda}{2} \sum_{i=1}^{n_m} \sum_{k=1}^n (x_k^{(i)})^2 + \frac{\lambda}{2} \sum_{j=1}^{n_u} \sum_{k=1}^n (\theta_k^{(j)})^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;累加器 $\sum_{(i,j):r(i,j)=1}$ 表示针对每个用户评价过的所有的电影进行累加。后两项分别是 $\theta^{(j)}$ 的正则项和 $x^{(i)}$ 的正则项。需要注意的是，总成本函数里 $\theta^{(j)}$ 和 $x^{(i)}$ 都是 n 维向量，即不包含偏置向量 $x_0$。&lt;/p&gt;
&lt;p&gt;这样我们可以更新协同过滤算法的实现步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用较小的随机数来初始化 $x^{(1)}, x^{(2)}m, &amp;hellip; ,x^{(n_m)}, \theta^{(1)}, \theta^{(2)}, &amp;hellip; , \theta^{(n_u)}$。为什么要用较小的随机数来初始化，而不全用零呢？这是因为我们需要让这些变量具有不同的初始值，以便不会让两个变量变成同一个特征。&lt;/li&gt;
&lt;li&gt;最小化成本函数 $J(x^{(1)}, x^{(2)}m, &amp;hellip; ,x^{(n_m)}, \theta^{(1)}, \theta^{(2)}, &amp;hellip; , \theta^{(n_u)})$ ，可以使用梯度下降或其他的优化过的高级算法。其参数迭代公式为&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_k^{(j)} = \theta_k^{(j)} - \alpha \left( \sum_{i:r(i,j)=1} \left( (\theta^{(j)})^T  x^{(i)} - y^{(i)} \right) x_k^{(i)} + \lambda \theta_k^{(j)} \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
x_k^{(i)} = x_k^{(i)} - \alpha \left( \sum_{i:r(i,j)=1} \left( (\theta^{(j)})^T x^{(i)} - y^{(i)} \right) \theta_k^{(i)} + \lambda x_k^{(j)} \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习出参数后，针对一个用户 j 的参数为 $\theta^{(j)}$ ，针对这个用户没有看过的电影，学习到的特征为 $x^{(i)}$，那么可以预测到这个用户对这个电影的评分将是 $(\theta^{(j)})^T x^{(i)}$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要特别注意的是，此处我们没有加偏置变量 $x_0$，也不存在 $\theta_0$。&lt;/p&gt;
&lt;h3 id="_5"&gt;协同过滤算法的向量化实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;低秩矩阵分解 (Low Rank Matrix Factorization)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用协同过滤算法算出所有用户的参数 $\theta^{(j)}$ 和所有电影的特征 $x^{(i)}$ 之后，我们可以针对某个用户 j 对电影 i 的评分做出预测，预测公式为 $(\theta^{(j)})^T x^{(i)}$ 。如果我们想要一次性计算所有用户对所有电影的评分，我们可以写成下面的矩阵：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{bmatrix}&lt;br /&gt;
(\theta^{(1)})^T x^{(1)} &amp;amp; (\theta^{(2)})^T x^{(1)} &amp;amp; \cdots &amp;amp; (\theta^{(n_u)})^T x^{(1)} \\&lt;br /&gt;
(\theta^{(1)})^T x^{(2)} &amp;amp; (\theta^{(2)})^T x^{(2)} &amp;amp; \cdots &amp;amp; (\theta^{(n_u)})^T x^{(2)} \\&lt;br /&gt;
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \vdots \\&lt;br /&gt;
(\theta^{(1)})^T x^{(n_m)} &amp;amp; (\theta^{(2)})^T x^{(n_m)} &amp;amp; \cdots &amp;amp; (\theta^{(n_u)})^T x^{(n_m)} \\&lt;br /&gt;
\end{bmatrix}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这是个 $n_m \times n_u$ 的矩阵，其中 $n_m$ 是电影个数，$n_u$ 是用户数。我们把所有的电影特征 $x^{(i)}$ 写成一个 $n_m \times n$ 的矩阵，其中 n 是电影的特征个数。&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
X = \begin{bmatrix}&lt;br /&gt;
- &amp;amp; (x^{(1)})^T &amp;amp; - \\&lt;br /&gt;
- &amp;amp; (x^{(2)})^T &amp;amp; - \\&lt;br /&gt;
- &amp;amp; \vdots &amp;amp; - \\&lt;br /&gt;
- &amp;amp; (x^{(n_m)})^T &amp;amp; - \\&lt;br /&gt;
\end{bmatrix}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;再把所有的用户参数 $\theta^{(j)}$ 写成一个 $n_u \times n$ 的矩阵：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\Theta = \begin{bmatrix}&lt;br /&gt;
- &amp;amp; (\theta^{(1)})^T &amp;amp; - \\&lt;br /&gt;
- &amp;amp; (\theta^{(2)})^T &amp;amp; - \\&lt;br /&gt;
- &amp;amp; \vdots &amp;amp; - \\&lt;br /&gt;
- &amp;amp; (\theta^{(n_u)})^T &amp;amp; - \\&lt;br /&gt;
\end{bmatrix}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;利用矩阵相乘的法则，公式 $Y = X \Theta^T$ 就可以一次性算出所有用户对所有电影的评分。其中 $X \in R^{n_m \times n}, \Theta^T \in R^{n \times n_u}$，其内积 $Y \in R^{n_m \times n_u}$。&lt;/p&gt;
&lt;h3 id="_6"&gt;计算量问题&lt;/h3&gt;
&lt;p&gt;针对大型的电影网站，电影数量是非常庞大的，用户量可能更庞大。对这样一个大的矩阵进行运算，其计算量将大的惊人的。从协同过滤算法的核心原则来看，系统需要经常计算这个矩阵，最坏的情况是每当有用户对一个新电影进行评分时就需要计算一次。详细讨论这个问题已经超出本文的范围，但可以简单谈一些策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择合适的计算周期&lt;br /&gt;
  我们不一定在每次用户提交一个新的电影评分数据时就计算，而是一天甚至几天计算一次。这样的结果就是，只要数据库的读写分离做得好，即使我们用很有限的硬件资源，也可以完成预期的计算目标。因为我们的计算时效性要求不强，每次计算完，更新参数后，我们的推荐系统就变得更准确一点了。&lt;/li&gt;
&lt;li&gt;使用分布式计算&lt;/li&gt;
&lt;li&gt;使用量子计算机&lt;br /&gt;
  量子计算机的运算速度上比目前的计算机要提高 N 个数量级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_7"&gt;推荐相似的电影&lt;/h3&gt;
&lt;p&gt;我们还是以电影为例，假设我们已经通过协同过滤算法学习到了所有的电影特征 $x^{(i)}$。假设这个时候用户在浏览电影 i ，我们要推荐 5 部相似的电影给用户。怎么样找到这 5 部相似的电影呢？&lt;/p&gt;
&lt;p&gt;我们可以遍历所有的电影，通过公式 $\| x^{(i)} - x^{(k)} \|$ 找出和正在浏览的电影“距离最小”，即相似度最高的 5 部电影。&lt;/p&gt;
&lt;h3 id="mean-normalization"&gt;均值归一化 Mean Normalization&lt;/h3&gt;
&lt;p&gt;假设现在有个新用户 j 没有对任何电影进行打分。那么根据协同过滤算法的成本函数：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J = \frac{1}{2} \sum_{(i,j):r(i,j)=1} \left( (\theta^{(j)})^T (x^{(i)}) - y^{(i,j)} \right)^2 + \frac{\lambda}{2} \sum_{i=1}^{n_m} \sum_{k=1}^n (x_k^{(i)})^2 + \frac{\lambda}{2} \sum_{j=1}^{n_u} \sum_{k=1}^n (\theta_k^{(j)})^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;第一部分将为 0 ，因为对用户 j ，没有 $r(i,j)=1$ 的项。第二部分将为一个固定值，因为已经学习好了电影的特征，所以 $x_k^{(i)}$ 将是常量，所以针对新用户 j 问题将简化为最小化 $\frac{\lambda}{2} \sum_{j=1}^{n_u} \sum_{k=1}^n (\theta_k^{(j)})^2$ ，这个计算结果将使 $\theta^{(j)}$ 为全 0 。&lt;/p&gt;
&lt;p&gt;这样的话，这个用户对所有电影的评分将预测为 0 ，我们也就没有什么他喜欢的电影推荐给他了。&lt;/p&gt;
&lt;p&gt;怎么样解决这个问题呢？&lt;/p&gt;
&lt;p&gt;简单地讲，&lt;strong&gt;如果一个新用户没有评分过任何电影，我们可以预测这个用户对新电影的评分为这个电影的评分的平均值&lt;/strong&gt;。用数学的语言来描述就是，我们需要先对电影评分数据进行&lt;strong&gt;均值归一&lt;/strong&gt;处理。&lt;/p&gt;
&lt;p&gt;假设我们有所有的电影评分矩阵 $Y \in R^{n_m \times n_u}$，对其按行求平均值，得到 $\mu \in R^{n_m}$。然后我们计算 $Y - \mu$ 作为我们协同过滤算法的训练数据集。这样训练出来 $\theta^{(j)}$ 和 $x^{(i)}$ 之后，针对新用户 j 对电影 i 的预测评分公式将变成 $(\theta^{(j)})^T x^{(i)} + \mu_i$。&lt;/p&gt;
&lt;p&gt;还有一种情况是如果有一部新的电影，所有人都没有评分过，那么这个电影的特征值将全为 0 。我们也可以用均值归一法来处理，但这样处理是否合理需要从业务层面去理解。比如一部新电影，所有人都没看过，也没评分过，我们就不应该推荐给任何人。从业务层面，一个新电影可能会有专门的展示区域，比如“新片速递”。&lt;/p&gt;
&lt;h2 id="_8"&gt;总结&lt;/h2&gt;
&lt;p&gt;协同推荐算法就像魔术一样，解决了鸡生蛋和蛋生鸡的问题，从无到有构建了用户的偏好和电影的特征。当然，这里没有魔术，协同过滤算法的关键是用户不停地使用系统，使用过程中不停地完善推荐系统。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>异常检测</title><link href="http://blog.kamidox.com/gaussian-distribution.html" rel="alternate"></link><updated>2015-12-15T23:11:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-12-15:gaussian-distribution.html</id><summary type="html">&lt;h2 id="_1"&gt;异常检测模型和实例&lt;/h2&gt;
&lt;p&gt;给定一组数据 $x^{(1)}, x^{(2)}, &amp;hellip; , x^{(m)}$，我们建立一个模型 $p(x)$，当有一个新的实例 $x_{test}$ 时，如果 $p(x_{test}) \le \epsilon$ 我们就认为 $x_{test}$ 是异常的。&lt;/p&gt;
&lt;p&gt;异常检测在网站防盗等领域有广泛的应用，比如我们可以提取用户的一些特征，$x_1$ 代表用户的登录次数，$x_2$ 表示用户游览的页面个数，$x_3$ 表示用户的打字速度，$x_4$ 表示用户的交易次数等等，建立完特征，根据用户的历史数据建立一个模型，当某次用户的行为偏离这个模型较远时，这个用户的帐户可能是被盗了。&lt;/p&gt;
&lt;p&gt;另外一个应用领域是在工业制造。比如某个制造飞机引擎的公司，从飞机引擎提取出一系列的特征值，并且训练出一个模型。当新制造出来的引擎符合这个模型时，就可认为是良品，如果偏离这个模型较远时，就可以认为可能有缺陷，需要进一步的检测。&lt;/p&gt;
&lt;p&gt;异常检测还在数据中心有广泛的应用，比如可以从一台服务器上提取出一系列特征，如内存占用，CPU 使用率，网络吞吐量，磁盘访问频率等等。利用这些特征建立一个模型。当某个服务器偏离这个模型较远时，可能这台机器快要死机了，就可以进一步查看这台机器的情况以便做出相应的处理。&lt;/p&gt;
&lt;h2 id="_2"&gt;高斯分布&lt;/h2&gt;
&lt;p&gt;高斯分布也称为正态分布。高斯分布有两个参数，一个是平均值 $\mu$，另外一个是方差 $\sigma^2$ ($\sigma$ 称为标准差)，给定一个数值 X 作为横轴，它出现在不同位置的概率作为 Y 轴，在二维坐标上画出的图形是一个“钟形”的图形。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Gaussian Distribution" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/Normal_Distribution_PDF.svg/700px-Normal_Distribution_PDF.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;用数据公式给出高斯分布的公式如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(x; \mu, \sigma^2) = \frac{1}{\sigma \sqrt{2\pi}} exp \left( - \frac{(x - \mu)^2}{2 \sigma^2} \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;h3 id="_3"&gt;参数计算&lt;/h3&gt;
&lt;p&gt;假设我们有一个数据集 $x^{(1)}, x^{(2)}, &amp;hellip; , x^{(m)}$，其中 $x^{(i)} \in R$。且 $x^{(i)}$ 满足高斯分布，记作 $x^{(i)} \sim N(\mu, \sigma^2)$，如何算出高斯分布的参数 $\mu, \sigma^2$ 呢？&lt;/p&gt;
&lt;p&gt;算法可以用下面的公式给出：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\mu = \frac{1}{m} \sum_{i=1}^m x^{(i)}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\sigma^2 = \frac{1}{m} \sum_{i=1}^m (x^{(i)} - \mu)^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这个实际上就是概率论里的极大似然法来估计参数。另外需要提一点，计算方差 $\sigma^2$ 的公式里，一些概率论书本里分母是用 $m-1$，但机器学习领域喜欢直接用 $m$ ，虽然这是两个不同版本的公式，但在实际应用中，如果样例个数足够多，即 m 很大的话，实际计算结果差别不大。&lt;/p&gt;
&lt;h2 id="_4"&gt;异常检测算法&lt;/h2&gt;
&lt;p&gt;假设我们有一个数据集 $x^{(1)}, x^{(2)}, &amp;hellip; , x^{(m)}$，其中 $x^{(i)} \in R^n$，其中每个特征都独立地满足高斯分布，即 $x_j^{(i)} \sim N(\mu_j, \sigma_j^2)$。那么高斯分布的概率密度函数为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
p(x) = \prod_{j=1}^n p(x_j; \mu_j, \sigma_j^2)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 $\prod$ 是连乘符号，表示其后的式子相乘。&lt;/p&gt;
&lt;p&gt;利用高斯分布进行异常检测的算法可以完整地描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特征选择。选择那些能鉴别出异常的特征 $x_j$。&lt;/li&gt;
&lt;li&gt;针对每个特征，计算出其高斯分布参数 $\mu_j, \sigma_j^2$。计算公式为:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br /&gt;
\mu_j = \frac{1}{m} \sum_{i=1}^m x_j^{(i)}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\sigma_j^2 = \frac{1}{m} \sum_{i=1}^m (x_j^{(i)} - \mu_j)^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定一个新的实例 $x$，计算其出现的概率 $p(x)$。计算公式为：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br /&gt;
p(x) = \prod_{j=1}^n p(x_j; \mu_j, \sigma_j^2) = \prod_{j=1}^n \frac{1}{\sigma_j \sqrt{2\pi}} exp \left( - \frac{(x_j - \mu_j)^2}{2 \sigma_j^2} \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选定一个较小的常数 $\epsilon$，如果 $p(x) \le \epsilon$ 则表示新的实例 $x$ 是异常的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_5"&gt;异常检测算法的性能评价&lt;/h3&gt;
&lt;p&gt;怎么样评价一个异常检测算法的性能是否达到要求呢？&lt;/p&gt;
&lt;p&gt;假设我们拿飞机引擎制造作为例子，我们有 10,000 个正常的引擎数据，20 个异常的引擎数据。这样我们把数据分成三份：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;训练数据集：6,000 个正常的引擎数据&lt;/li&gt;
&lt;li&gt;交叉验证数据集：2,000 个正常的引擎数据；10 个异常引擎数据&lt;/li&gt;
&lt;li&gt;测试数据集：2,000 个正常的引擎数据；10 个异常的引擎数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们开始来评估算法的性能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用训练数据集来建立 $p(x)$ 模型&lt;/li&gt;
&lt;li&gt;使用下面的模型来预测交叉验证数据集和测试数据集里的样例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br /&gt;
y = \begin{cases}&lt;br /&gt;
    1, &amp;amp; if p(x) &amp;lt; \epsilon (异常)\\&lt;br /&gt;
    0, &amp;amp; if p(x) \ge \epsilon (正常) \\&lt;br /&gt;
\end{cases}&lt;br /&gt;
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用交叉验证数据集来计算&lt;strong&gt;查准率&lt;/strong&gt;，&lt;strong&gt;召回率&lt;/strong&gt;以及&lt;strong&gt;$F_1Score$&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$&lt;br /&gt;
Precision = \frac{TruePositive}{TruePositive + FalsePositive}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
Recall = \frac{TruePositive}{TruePositive + FalseNegative}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
F_1Score = 2 \frac{PR}{P + R}&lt;br /&gt;
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用交叉验证数据集来选择合适的 $\epsilon$，来让 $F_1Score$ 的值最大&lt;/li&gt;
&lt;li&gt;最后使用测试数据集来计算模型的最终性能 $F_1Score$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TruePosition: 真阳性，即真实结果是真，算法的预测结果也是真&lt;br /&gt;
FalsePositive: 假阳性，即真实结果是假，算法的预测结果是真&lt;br /&gt;
FalseNegative: 假阴性，即真实结果是真，算法的预测结果是假&lt;/p&gt;
&lt;h3 id="_6"&gt;异常检测与监督学习的区别&lt;/h3&gt;
&lt;p&gt;上一节介绍的飞机引擎异常检测算法里，我们有正常的数据，有异常的数据，为什么不直接用逻辑回归或神经网络算法来对一个新引擎进行直接预测呢？实际上异常检测和监督学习有其不同的适用范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常检测适用范围&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正向样本 (y = 1) 非常少 (0 - 20)，但负向样本 (y = 0) 很多&lt;/li&gt;
&lt;li&gt;有太多的异常类型，算法很难从正常的数据样例里学习到异常的特征&lt;/li&gt;
&lt;li&gt;未来新出来的异常数据和我们训练样例里现有的异常数据根本不一样，即没见过的异常样例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果满足这三个条件中的任何一个，都需要考虑使用异常检测算法，而不是监督学习相关的算法。&lt;strong&gt;监督学习算法适用于有大量的正向样本，也有大量的负向样本，有足够的正向样本让算法来学习其特征，未来新出现的正向数据可能和训练样例里的某个正向样本类似&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由此可见异常检测和监督学习相关算法的适用范围是不一样的。下面是一些例子&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;异常检测&lt;/th&gt;
&lt;th&gt;监督学习&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;信用卡诈骗&lt;/td&gt;
&lt;td&gt;垃圾邮件识别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;制造业异常产品检测&lt;/td&gt;
&lt;td&gt;天气预报 (晴/雨 等)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据中心机器异常检测&lt;/td&gt;
&lt;td&gt;癌症检测&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="_7"&gt;异常检测中的特征选择&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;非高斯分布特征的转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用高斯分布来作为异常检测模型时，有个前提，即每个特征都需要独立地呈现高斯分布。如果我们获得的特征数据可视化后发现他不是一个高斯分布的钟形图形怎么办呢？我们可以用 octave 的 &lt;code&gt;hist&lt;/code&gt; 命令来画出特征的柱状图，然后对特征进行转换，比如画出 $log(x)$ 的图形，或画出 $x^{0.5}$ 或 $x^{0.1}$ 的柱状图。看图形的形状来判断是否符合高斯分布。然后选择转换后的特征来加入我们的异常检测算法中来。&lt;/p&gt;
&lt;p&gt;&lt;img alt="特征转换" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_gd_feature_transform.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常检测的错误分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假如我们有一个异常检测算法，算出正常样本的概率很大，但算出异常样本的概率也很大。这样就没有办法区分出异常样本了。这个时候，一个可行的方法是去查看这个概率很大的异常样本，看能不能得到一些启发，以便让我们发现一些新的特征，用这个特征可以把这种异常样本区分出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征选择的一般性原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择那些在异常时，特征值会变得很大或很小的特征来作为异常检测的特征。比如，我们要检测数据中心中的计算机工作是否正常，我们有下面几个特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 使用率&lt;/li&gt;
&lt;li&gt;网络吞吐量&lt;/li&gt;
&lt;li&gt;磁盘访问速度&lt;/li&gt;
&lt;li&gt;内存使用情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般情况下，CPU 使用率和网络吞量是成正比的，即用户访问越多，CPU 使用率就越高。当 CPU 使用率很高，但网络吞吐量比较小时，这个时候这个机器可能就出现异常了，比如进入了死循环了。如果我们想检测出这种异常，可以选择 &lt;em&gt;CPU 使用率&lt;/em&gt; / &lt;em&gt;网络吞吐量&lt;/em&gt; 来作为一个新的特征，加入我们的异常检测算法里。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>主成份分析算法 PCA</title><link href="http://blog.kamidox.com/pca.html" rel="alternate"></link><updated>2015-12-12T20:34:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-12-12:pca.html</id><summary type="html">&lt;h2 id="_1"&gt;维数约减&lt;/h2&gt;
&lt;p&gt;维数约减 (Dimensionality Reduction) 是把&lt;strong&gt;高维度数据&lt;/strong&gt;在&lt;strong&gt;损失最小&lt;/strong&gt;的情况下转换为&lt;strong&gt;低维度数据&lt;/strong&gt;的动作。&lt;/p&gt;
&lt;h3 id="_2"&gt;动机：为什么需要维数约减&lt;/h3&gt;
&lt;h4 id="_3"&gt;动机一：数据压缩&lt;/h4&gt;
&lt;p&gt;维数约减即减少数据的维度，比如从 2 维降成 1 维，从 3 维降成 2 维等。好处是节省内存，提高运算速度。比如，我们有多个特征，其中两个特征的相关性非常大，一个是用 cm 测量的长度，另外一个是用 inch 测量的长度 (实际上这可能是个真实的例子，因为一个实际问题可能有 1000 个特征，而采集这些特征的工程师可能不是同一个人，这样他们采集回来的数据就可能存在重复，即高相关性)。那么我们可以把这两个高相关性的特征用一条直线来表示，$x^{(i)} = {x_1^{(i)}, x_2^{(i)}}$ 简化为 $z^{(i)} = {z_1^{(i)}}$。相同的原理，如果在一个 3 维空间里，一些点基本分布在一个平面上，那么就可以把 3 维降成 2 维，即 $x^{(i)} = {x_1^{(i)}, x_2^{(i)}, x_3^{(i)}}$ 简化为 $z^{(i)} = {z_1^{(i)}, z_2^{(i)}}$。&lt;/p&gt;
&lt;p&gt;&lt;img alt="数据压缩" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_pca_data_compress.png" /&gt;&lt;/p&gt;
&lt;p&gt;上图示例的就是把用英寸测量的特征和用厘米测量的特征合并起来的示意图。这里有个问题，为什么按 inch 测量的特征和按 cm 测量的特征不是在同一条直线上，而是在一条直线周围波动？实际上这个是正常的，因为测量的人和误差等方面的原因，会导致特征采集时数据会在误差范围内波动。&lt;/p&gt;
&lt;h4 id="_4"&gt;动机二：数据可视化&lt;/h4&gt;
&lt;p&gt;比如考查一个国家的经济状况，可能会有 50 个特征，经济总量，人均 GDP，出口值，进口值等等。如果想要直观地观察多个特征之间的关系，就比较难办。因为我们很难画出 50 个特征的图出来。这个时候，我们可以把 50 个特征简化为 2 维或 3 维的数据，然后画出 2D 或 3D 图出来，就可以直观地观察这些数据的样子。&lt;/p&gt;
&lt;h2 id="_5"&gt;主成份分析法&lt;/h2&gt;
&lt;p&gt;主成份分析法简称 PCA (Principal Component Analysis)，这是目前最常用和流行的数据降维方法。&lt;/p&gt;
&lt;p&gt;假设需要把 2 维数据降为 1 维数据时，我们需要找出一个向量 $u^{(1)}$ ，以便让 2 维数据的点在这个向量所在的直线上的&lt;strong&gt;投射误差最小&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="PCA - 2D to 1D" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_pca_2d_1d.png" /&gt;&lt;/p&gt;
&lt;p&gt;上图中，我们的目标就是找到红色的向量所在的直线，以便让所有黑色的点到这条直线的平均距离最短，这样我们就可以把原来在二维平面上的点映射到在红色直线所在的一维直线上的绿色的点来表示。即把二维数据降为一维数据。&lt;/p&gt;
&lt;p&gt;假如需要把 3 维数据降为 2 维数据时，我们需要找出两个向量 $u^{(1)}, u^{(2)}$，以便让 3 维数据的点在这两个向量所决定的平面上的投射误差最小。&lt;/p&gt;
&lt;p&gt;从数学角度更一般地描述 PCA 算法，当我们需要从 n 维数据降为 k 维数据时，我们需要找出 k 个向量 $u^{(1)}, u^{(2)}, &amp;hellip; , u^{(k)}$ ，把 n 维的数据投射到这 k 个向量决定的线性空间里，最终使&lt;strong&gt;投射误差最小化&lt;/strong&gt;的过程。&lt;/p&gt;
&lt;h3 id="pca"&gt;PCA 算法主要步骤&lt;/h3&gt;
&lt;h4 id="_6"&gt;步骤一：数据归一化和缩放&lt;/h4&gt;
&lt;p&gt;在进行 PCA 算法前，需要对数据进行预处理。预处理包括两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据归一化 (Mean Normalization)：使数据的均值为零。加快 PCA 运算速度。&lt;/li&gt;
&lt;li&gt;数据缩放 (Feature Scaling)：使不同的特征数值在同一个数量级。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据归一化公式为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
z_j^{(i)} = x_j^{(i)} - \mu_j&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，$\mu_j$ 是训练样本中第 j 个特征 ($x_j^{(i)}$) 的平均值。然后用 $z_j^{(i)}$ 代替 $x_j^{(i)}$ 进行 PCA 运算。&lt;/p&gt;
&lt;p&gt;接着对数据进行缩放，缩放只在不同特征数据不在同一个数量级上时才使用。&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
x_j^{(i)} = \frac{x_j^{(i)} - \mu_j}{s_j}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，$\mu_j$ 是训练样本中第 j 个特征 ($x_j^{(i)}$) 的平均值&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\mu_j = \frac{1}{m} \sum_{i=1}^m x_j^{(i)}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$s_j$ 是训练样本中第 j 个特征 ($x_j^{(i)}$) 的范围，即 $s_j = max(x_j^{(i)}) - min(x_j^{(i)})$。&lt;/p&gt;
&lt;h4 id="_7"&gt;步骤二：计算协方差矩阵的特征向量&lt;/h4&gt;
&lt;p&gt;数据预处理完，我们需要计算&lt;strong&gt;协方差矩阵 (Covariance Matrix)&lt;/strong&gt;，用大写的 Sigma 表示 (大写的 Sigma 和累加运算符看起来几乎一样，但这里其实是一个数学符号而已，不是累加运算)：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\Sigma = \frac{1}{m} \sum_{i=1}^m (x^{(i)}) (x^{(i)})^T&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;如果把训练样例用行向量来表示，那么 X 将是一个 m x n 的矩阵，m 是训练样例个数，n 是特征个数。向量化计算 Sigma 的公式将是：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\Sigma = \frac{1}{m} X^T X&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;计算结果 Sigma 将是一个 n x n 矩阵。接着，计算协方差矩阵的&lt;strong&gt;特征向量 (eigenvectors)&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
[U, S, V] = svd(Sigma)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;&lt;code&gt;svd&lt;/code&gt; 是奇异值分解 (Singular Value Decomposition)，是高级线性代数的内容。在 Octave 里，也可以使用 &lt;code&gt;eig&lt;/code&gt; 函数来求解协方差矩阵的特征向量。这里，Sigma 是 n x n 矩阵，经过 &lt;code&gt;svd&lt;/code&gt; 运算后，我们真正关心的是 U。它是一个 n x n 矩阵。如果我们选择 U 的列作为向量，那么我们得到 n 个列向量 $u^{(1)}, u^{(2)}, &amp;hellip; , u^{(n)}$，我们如果需要把数据降维为 k 维，那么我们只需要选取前 k 个向量即可，即 $u^{(1)}, u^{(2)}, &amp;hellip; , u^{(k)}$。&lt;/p&gt;
&lt;h4 id="_8"&gt;步骤三：数据降维&lt;/h4&gt;
&lt;p&gt;接着，我们计算降维后的值 z，假设降维前的值为 $x^{(i)}$，降维后为 $z^{(i)}$，那么：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
z^{(i)} = U_{reduce}^T x^{(i)}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，$U_{reduce} = [u^{(1)} u^{(2)} &amp;hellip; u^{(k)}]$。看一下数据维度，$U_{reduce}$ 是 n x k 矩阵，$x^{(i)}$ 是 n x 1 矩阵，$z^{(i)}$ 是 k x 1 矩阵。&lt;/p&gt;
&lt;p&gt;实现时可以用向量化来提高性能。假设 X 是 m x n 矩阵，m 表示训练样例个数，n 表示特征数。用大写的 Z 表示降维后的数据，是一个 m x k 的矩阵。$U_{reduce}$ 是 n x k 的主成份特征矩阵，每列表示一个主成份特征。那么他们满足下面的关系：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
Z = X * U_{reduce}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;要从数学上证明这样计算出来的 $z^{(i)}$ 就是 $x^{(i)}$ 在 $U_{reduce}$ 线性空间投射，使得其投射误差最小，将是一个非常复杂的过程。所幸如果我们单纯从应用 PCA 算法来对数据进行降维的角度来看的话，借用 Octave/Matlab 等现成函数，计算过程相对比较简单。&lt;/p&gt;
&lt;h2 id="pca_1"&gt;PCA 的应用&lt;/h2&gt;
&lt;h3 id="_9"&gt;数据还原&lt;/h3&gt;
&lt;p&gt;我们怎么样从压缩过的数据里还原出压缩前的数据呢？从前文的计算公式，我们知道降维后的数据计算公式 $z^{(i)} = U_{reduce}^T x^{(i)}$。所以，如果要还原数据，我们可以使用下面的公式：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
x_{approx}^{(i)} = U_{reduce} z^{(i)}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，$U_{reduce}$ 是 n x k 维矩阵，$z^{(i)}$ 是 k x 1 列向量。这样算出来的 $x^{(i)}$ 就是 n x 1 列向量。&lt;/p&gt;
&lt;p&gt;向量化运算公式为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
X_{approx} = Z * U_{reduce}^T&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 $X_{approx}$ 是还原回来的数据，是个 m x n 矩阵，每行表示一个训练样例。Z 是个 m x k 矩阵，是压缩后的数据。$U_{reduce}$ 是 n x k 的主成份特征矩阵，每列表示一个主成份特征。&lt;/p&gt;
&lt;h3 id="pca-k"&gt;PCA 算法中 K 参数的选择&lt;/h3&gt;
&lt;p&gt;怎么样选择参数 K 呢？K 是主成份分析法中主成份的个数。可以用下面的公式来判断选择的 K 是否合适：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\frac{ \frac{1}{m} \sum_{i-1}^m \| x^{(i)} - x_{approx}^{(i)} \|^2 }{ \frac{1}{m} \sum_{i=1}^m \|  x^{(i)} \| } \le 0.01&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中分子部分表示平均投射误差的平方；分母部分表示所有训练样例到原点的距离的平均值。这里的物理意义用术语可以描述为 &lt;strong&gt;99% 的数据真实性被保留下来了 (99% of variance is retianed)&lt;/strong&gt;。简单地理解为压缩后的数据还原出原数据的的准确度为 99%。另外常用的比率还有 0.05 ，这个时候准确度就是 95%。在实际应用中，可以根据要解决的问题的场景来决定这个比率。&lt;/p&gt;
&lt;p&gt;假设我们的还原率要求是 99%，那么用下面的算法来选择参数 K：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让 K = 1&lt;/li&gt;
&lt;li&gt;运行 PCA 算法，计算出 $U_{reduce}, z^{(1)}, z^{(2)}, &amp;hellip; , z^{(m)}, x_{approx}^{(1)}, x_{approx}^{(2)}, &amp;hellip; , x_{approx}^{(m)}$&lt;/li&gt;
&lt;li&gt;利用 $\frac{ \frac{1}{m} \sum_{i-1}^m \| x^{(i)} - x_{approx}^{(i)} \|^2 }{ \frac{1}{m} \sum_{i=1}^m \|  x^{(i)} \| }$ 计算投射误差率，并判断是否满足要求，如果不满足要求，K = K + 1，继续步骤 2；如果满足要求，K 即是我们选择的参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个算法容易理解，但实际上效率非常低下，因为每做一次循环都需要运行一遍 PCA 算法。另外一个更高效的方法是利用 &lt;code&gt;svd&lt;/code&gt; 函数返回的 S 矩阵：$[U, S, V] = svd(Sigma)$。其中 S 是个 n x n 对角矩阵，即只有对角线上的值非零其他元素均为零。&lt;/p&gt;
&lt;p&gt;从数学上可以证明（从应用角度，可以忽略这个证明过程），投射误差率也可以使用下面的公式计算：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
1 - \frac{\sum_{i=1}^k S_{ii}}{\sum_{i=1}^n S_{ii}}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这样运算效率大大提高，我们只需要调用一次 &lt;code&gt;svd&lt;/code&gt; 函数即可。&lt;/p&gt;
&lt;h3 id="_10"&gt;加快监督机器学习算法的运算速度&lt;/h3&gt;
&lt;p&gt;PCA 的一个典型应用是用来&lt;strong&gt;加快监督学习 (Supervised Learning) 的速度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如，我们有 m 个训练数据 $(x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), &amp;hellip; , (x^{(m)}, y^{(m)})$，其中 $x^{(1)}$ 是 10,000 维的数据，想像一下，如果这是个图片分类问题，如果输入的图片是 100 x 100 分辨率的。那么我们就有 10,000 维的输入数据。&lt;/p&gt;
&lt;p&gt;使用 PCA 来加快算法运算速度时，我们把输入数据分解出来 $x^{(1)}, x^{(2)}, &amp;hellip; , x^{(m)}$，然后运用 PCA 算法对输入数据进行降维压缩，得到降维后的数据 $z^{(1)}, z^{(2)}, &amp;hellip; , z^{(m)}$，最后得到新的训练样例 $(z^{(1)}, y^{(1)}), (z^{(2)}, y^{(2)}), &amp;hellip; , (z^{(m)}, y^{(m)})$。利用新的训练样例训练出关于压缩后的变量 $z$ 的预测函数 $h_\theta(z)$。&lt;/p&gt;
&lt;p&gt;需要注意，PCA 算法只用来处理训练样例，运行 PCA 算法得到的转换参数 $U_{reduce}$ 可以用来对交叉验证数据集 $x_{cv}^{(i)}$ 以及测试数据集 $x_{test}^{(i)}$ 进行转换。当然，还需要相应地对数据进行归一化处理或对数据进行缩放。&lt;/p&gt;
&lt;h3 id="pca_2"&gt;PCA 误用&lt;/h3&gt;
&lt;p&gt;PCA 的典型应用场景是对数据进行压缩，减少磁盘/内存占用，加快算法运行速度。另外一个是用来数据可视化 (降到 2 维或 3 维)。我们了解到 PCA 可以对数据进行降维，即减少特征数，有人用 PCA 来解决&lt;strong&gt;过拟合&lt;/strong&gt;问题。这可能在某些情况下会起作用，但实际上 &lt;strong&gt;PCA 不是一个好的解决过拟合的方法&lt;/strong&gt;。解决过拟合应该使用正则化，加大成本函数里正则项的比重。&lt;/p&gt;
&lt;h3 id="pca_3"&gt;PCA 滥用&lt;/h3&gt;
&lt;p&gt;另外一个场景是在设计机器学习算法时，一开始就引入 PCA 来对数据进行压缩降维。实际上这不是好的方法。我们应该尽量使用原始数据来进行机器学习运算，当出现问题时，比如内存占用太大，运算时间太长等问题时，我们才考虑用 PCA 来优化。PCA 是算法优化的一个步骤，而不是机器学习系统里的必须步骤。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>使用 Sublime + PlantUML 高效地画图</title><link href="http://blog.kamidox.com/sublime-plantuml.html" rel="alternate"></link><updated>2015-12-10T22:52:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-12-10:sublime-plantuml.html</id><summary type="html">&lt;h2 id="plantuml"&gt;什么是 PlantUML&lt;/h2&gt;
&lt;p&gt;PlantUML 是一个画图脚本语言，用它可以快速地画出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时序图&lt;/li&gt;
&lt;li&gt;流程图&lt;/li&gt;
&lt;li&gt;用例图&lt;/li&gt;
&lt;li&gt;状态图&lt;/li&gt;
&lt;li&gt;组件图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单地讲，我们使用 visio 画图时需要一个一个图去画，但使用 PlantUML 只需要用文字表达出图的内容，然后就可以直接生成图片。看一个最简单的例子：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Bob -&amp;gt; Alice : Hello, how are you
Alice -&amp;gt; Bob : Fine, thank you, and you?
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="demo" src="http://plantuml.com/plantuml/png/SyfFKj2rKt3CoKnELR1Iy4ZDoSdNKSZ8BrT8B4fLgCmlvO980TKu0PLQARXbvgNgA9Ha9EPbWwHr51BpKa0CUm00" /&gt;&lt;/p&gt;
&lt;h2 id="_1"&gt;软件安装&lt;/h2&gt;
&lt;p&gt;这些软件全部是开源或共享软件，不存在版权问题，可以放心使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装 &lt;a href="http://www.sublimetext.com/"&gt;Sublime&lt;/a&gt;&lt;br /&gt;
  Sublime 是个强大的可扩展的文本编辑器。进入&lt;a href="http://www.sublimetext.com/"&gt;官网&lt;/a&gt;下载对应操作系统下的版本安装即可。&lt;/li&gt;
&lt;li&gt;安装 &lt;a href="http://graphviz.org/"&gt;graphviz&lt;/a&gt;&lt;br /&gt;
  graphviz 是个开源的图片渲染库。安装了这个库才能在 Windows 下实现把 PlantUML 脚本转换为图片。&lt;/li&gt;
&lt;li&gt;安装 &lt;a href="https://github.com/jvantuyl/sublime_diagram_plugin"&gt;PlantUML for Sublime&lt;/a&gt; 插件&lt;br /&gt;
  有了这个插件后，我们就可以在 Sublime 里写 PlantUML 脚本，然后直接通过一个快捷键生成图片。安装步骤如下&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/jvantuyl/sublime_diagram_plugin/tarball/master"&gt;下载插件&lt;/a&gt;，并解压&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Preferences -&amp;gt; Browse Packages ...&lt;/code&gt; 打开 sublime 的 &lt;code&gt;Packages&lt;/code&gt; 目录，解压后的插件放在 &lt;code&gt;Packages&lt;/code&gt; 目录下&lt;/li&gt;
&lt;li&gt;重启 Sublime&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了简化使用，可以在 Sublime 里配置个快捷键。打开 &lt;code&gt;Preferences -&amp;gt; Key Binding - User&lt;/code&gt;，添加一个快捷键：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;{ &amp;quot;keys&amp;quot;: [&amp;quot;alt+d&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;display_diagrams&amp;quot;}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的代码配置成按住 &lt;code&gt;Alt + d&lt;/code&gt; 来生成 PlantUML 图片，你可以修改成你自己喜欢的按键。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果检验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后检验一下工作安装是否正确。打开 Sublime 输入：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Bob -&amp;gt; Alice : Hello, how are you
Alice -&amp;gt; Bob : Fine, thank you, and you?
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;选中这些文本内容，按 Alt + d 会在当前工作目录下生成这个图片文件，同时自动弹出窗口显示图片。&lt;/p&gt;
&lt;h2 id="plantulm"&gt;PlantULM 快速入门&lt;/h2&gt;
&lt;h3 id="_2"&gt;时序图&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;@startuml

title 时序图

== 鉴权阶段 ==

Alice -&amp;gt; Bob: 请求
Bob -&amp;gt; Alice: 应答

== 数据上传 ==

Alice -&amp;gt; Bob: 上传数据
note left: 这是显示在左边的备注

Bob --&amp;gt; Canny: 转交数据
... 不超过 5 秒钟 ...
Canny --&amp;gt; Bob: 状态返回
note right: 这是显示在右边的备注

Bob -&amp;gt; Alice: 状态返回

== 状态显示 ==

Alice -&amp;gt; Alice: 给自己发消息

@enduml
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="sequence diagram" src="http://plantuml.com/plantuml/png/RO_DIiD058Ntzodk2vYTcq84zKbKeWP22fADE-iFqK89beYfzMyHj8WsbjQ9HarU9dCpUGkdCoeKihkSUyxvEE3PdcCXNJAU1NoO0vWcrcSpkZcg8qRZDpHDW5N7th9mQGNNsfij54bAaqEGzrnIlnRoBAnUGXMdYrVgZSltRlbrtn3N3sq2j-rPw5ZRdgmj1XGb5ELLdF7h4KyVHFvHNHtpsAVf23HFbgnlkEw-j7y_brdyMsCOXkpj2NOY2X-NiNhir_qxb38ekmegUjLbTD0HHSY7jvg-P-_iDk23QGF-V-v2pNoq5dHySVHVudCW_2UUJdXmJkoKEWdy0000" /&gt;&lt;/p&gt;
&lt;p&gt;TIPS：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;title&lt;/code&gt; 来指定标题&lt;/li&gt;
&lt;li&gt;&amp;rsquo;-&amp;gt;&amp;rsquo; 和 &amp;lsquo;&amp;ndash;&amp;gt;&amp;rsquo; 来指示线条的形式&lt;/li&gt;
&lt;li&gt;在每个时序后面加冒号 &lt;code&gt;:&lt;/code&gt; 来添加注释&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;note&lt;/code&gt; 来显示备注，备注可以指定显示在左边或右边&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;== xxx ==&lt;/code&gt; 来分隔时序图&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;...&lt;/code&gt; 来表示延迟省略号&lt;/li&gt;
&lt;li&gt;节点可以给自己发送消息，方法是发送方和接收方使用同一个主体即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_3"&gt;用例图&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;@startuml

left to right direction
actor 消费者
actor 销售员
rectangle 买单 {
消费者 -- (买单)
(买单) .&amp;gt; (付款) : include
(帮助) .&amp;gt; (买单) : extends
(买单) -- 销售员
}

@enduml
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="use case" src="http://plantuml.com/plantuml/png/oqbDAr4eoLSeoapFA558oInAJIx9pC_ZIamkoIzIUBQjuyMMdIyQMg7ybrCQdavPztJY32wGkiIyz9nKXISxDppjdQfGpGLNhA2hgw014TRaWZ4KzEo0WhjdF5kpJrF1IY4pBpcdD2MLI-FfZdLFkrP2fQ5AhHHIAqfIyrAA4Rg1HY8ih-K20000" /&gt;&lt;/p&gt;
&lt;p&gt;TIPS：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例图&lt;ul&gt;
&lt;li&gt;用例图是指由参与者（Actor）、用例（Use Case）以及它们之间的关系构成的用于描述系统功能的静态视图&lt;/li&gt;
&lt;li&gt;&lt;a href="http://baike.baidu.com/view/1281729.htm"&gt;百度百科&lt;/a&gt;上有简易的入门资料，其中用例之间的关系 (include, extends) 是关键&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;actor&lt;/code&gt; 来定义参与者&lt;/li&gt;
&lt;li&gt;使用括号 &lt;code&gt;(xxx)&lt;/code&gt; 来表示用例，用例用椭圆形表达&lt;/li&gt;
&lt;li&gt;使用不同的线条表达不同的关系。包括参与者与用例的关系，用例与用例的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_4"&gt;流程图&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;@startuml

title 流程图

(*) --&amp;gt; &amp;quot;步骤1处理&amp;quot;
--&amp;gt; &amp;quot;步骤2处理&amp;quot;
if &amp;quot;条件1判断&amp;quot; then
    -&amp;gt;[true] &amp;quot;条件1成立时执行的动作&amp;quot;
    if &amp;quot;分支条件2判断&amp;quot; then
        -&amp;gt;[no] &amp;quot;条件2不成立时执行的动作&amp;quot;
        -&amp;gt; === 中间流程汇总点1 ===
    else
        --&amp;gt;[yes] === 中间流程汇总点1 ===
    endif
    if &amp;quot;分支条件3判断&amp;quot; then
        --&amp;gt;[yes] &amp;quot;分支条件3成立时执行的动作&amp;quot;
        --&amp;gt; &amp;quot;Page.onRender ()&amp;quot; as render
        --&amp;gt; === REDIRECT_CHECK ===
    else
        --&amp;gt;[no] &amp;quot;分支条件3不成立时的动作&amp;quot;
        --&amp;gt; render
    endif
else
    --&amp;gt;[false] === REDIRECT_CHECK ===
endif

if &amp;quot;条件4判断&amp;quot; then
    -&amp;gt;[yes] &amp;quot;条件4成立时执行的动作&amp;quot;
    --&amp;gt; &amp;quot;流程最后结点&amp;quot;
else
endif
--&amp;gt; &amp;quot;流程最后结点&amp;quot;
--&amp;gt;(*)

@enduml
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="activity diagram" src="http://plantuml.com/plantuml/png/uoh9BCb9LNYsjV7vYkwdi_TnSMbeQIhewjefA3rRk_JbgYM6JvUqF9_GfiI596O44yjC0mhDNVXazpR3fnrBdarRgwHGaf6QnwK01BfsqIL5fQcnS1NFEYOyNztzRFgsPvtBNopiUJwhvMdNYYTxvoY1bOECUjhHzcpAUeXo8mm3eORcvSEDD7goenU_gH0z2hQsjWfFTgnzENqBnAFFDhO_QzZzl6cd8KWAh38rfpWLeGLeJsLgSInH6lDICjEmUi4OknTWPgEg9S8Ve0W8I4nFrSlF2mBQcbgaeA6ff91Oh504vg4e13ayoDN5CyZLEIJUsSFLsHktJy4XYk8Ov735uH8aEo4X03SMP6HQ8f0NYyiL40r8gSS4M-g1119K0VxWWQHDI0pDQNWweU_vxid0I5A2E0fY7KurG0bWckS20000" /&gt;&lt;/p&gt;
&lt;p&gt;上面的流程图写的时候还是挺直观的，但画出来的图片渲染效果不好，对逻辑的显示不清楚。由于这个原因 PlantUML 实现了另外版本的流程图脚本。&lt;/p&gt;
&lt;p&gt;下面是 PlantUML 支持的新版本的流程图脚本，从使用角度来讲，更直观，画出来的图片也更漂亮，推荐使用。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;@startuml

start
:&amp;quot;步骤1处理&amp;quot;;
:&amp;quot;步骤2处理&amp;quot;;
if (&amp;quot;条件1判断&amp;quot;) then (true)
    :条件1成立时执行的动作;
    if (&amp;quot;分支条件2判断&amp;quot;) then (no)
        :&amp;quot;条件2不成立时执行的动作&amp;quot;;
    else
        if (&amp;quot;条件3判断&amp;quot;) then (yes)
            :&amp;quot;条件3成立时的动作&amp;quot;;
        else (no)
            :&amp;quot;条件3不成立时的动作&amp;quot;;
        endif
    endif
    :&amp;quot;顺序步骤3处理&amp;quot;;
endif

if (&amp;quot;条件4判断&amp;quot;) then (yes)
:&amp;quot;条件4成立的动作&amp;quot;;
else
    if (&amp;quot;条件5判断&amp;quot;) then (yes)
        :&amp;quot;条件5成立时的动作&amp;quot;;
    else (no)
        :&amp;quot;条件5不成立时的动作&amp;quot;;
    endif
endif
stop
@enduml
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="active diagram 2" src="http://plantuml.com/plantuml/png/Aov9B2hXib9wjdRforLB39ykQNa-eKt96YvY11V9J5FGK7esT-6JtTiCdtOiUJPjhPAcGab6Qfw2HabHQQecbm8GM44LFEkOy7nrzxFfsvvrBd-niEVvh9QdNIkUx9rZ3LO5DkffHzkpAUiXwetG3CpBXnW7DX9ggT6J7RsuZ5M2c9kQKvmAruVaNcCquojJYn7c8zjX3BS0tMYOyQXkGz6Bx3wislDICjEuK5bMIYyNxdgwgnyIsCRmm8QeG0vp4sn-WDbj0h4OsLPuM22POOel761ccUBq1AR_uNhm-HtY5mXPN99V0000" /&gt;&lt;/p&gt;
&lt;p&gt;TIPS：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;start&lt;/code&gt; 来表示流程开始，使用 &lt;code&gt;stop&lt;/code&gt; 来表示流程结束&lt;/li&gt;
&lt;li&gt;顺序流程使用冒号和分号 &lt;code&gt;:xxx;&lt;/code&gt; 来表示&lt;/li&gt;
&lt;li&gt;条件语句使用 &lt;code&gt;if ("condition 1") then (true/yes/false/no)&lt;/code&gt; 来表示&lt;/li&gt;
&lt;li&gt;条件语句可以嵌套&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_5"&gt;组件图&lt;/h3&gt;
&lt;p&gt;我们经常使用组件图来画部署视图，或者用来画系统的拓扑结构图。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;@startuml

package &amp;quot;组件1&amp;quot; {
    [&amp;quot;组件1.1&amp;quot;] - [&amp;quot;组件1.2&amp;quot;]
    [&amp;quot;组件1.2&amp;quot;] -&amp;gt; [&amp;quot;组件2.1&amp;quot;]
}

node &amp;quot;组件2&amp;quot; {
    [&amp;quot;组件2.1&amp;quot;] - [&amp;quot;组件2.2&amp;quot;]
    [&amp;quot;组件2.2&amp;quot;] --&amp;gt; [负载均衡服务器]
}

cloud {
    [负载均衡服务器] -&amp;gt; [逻辑服务器1]
    [负载均衡服务器] -&amp;gt; [逻辑服务器2]
    [负载均衡服务器] -&amp;gt; [逻辑服务器3]
}

database &amp;quot;MySql&amp;quot; {
    folder &amp;quot;This is my folder&amp;quot; {
        [Folder 3]
    }

    frame &amp;quot;Foo&amp;quot; {
        [Frame 4]
    }
}

[逻辑服务器1] --&amp;gt; [Folder 3]
[逻辑服务器2] --&amp;gt; [Frame 4]
[逻辑服务器3] --&amp;gt; [Frame 4]

@enduml
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="component diagram" src="http://plantuml.com/plantuml/png/uof8JCvEJ4zLK7g-k-N9xcs6IWhLN0f040qJq3DKYbNGHU8RASMYgJ02gR232nY1j73LSd7bvQV03JP2DzW8pM0Z38ED80Q3J7wnPVwBlNkVpcr_iN3XipczJxiMFfsv0cn7Sav-QGhCQEpAm6vxsR3xnRw9S473M59r696imnZim9J4aiIan69WGFXM1XVcm88XBJyd9RL8GIaa8xDO0OXoAw52C0LWozmWgemXTWDD0sijIim56kUMdu-g5Yni0bCAL8pfQKXe8ap5z2HK1SmiJ3-XAG00" /&gt;&lt;/p&gt;
&lt;p&gt;TIPS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用方括号 &lt;code&gt;[xxx]&lt;/code&gt; 来表示组件&lt;/li&gt;
&lt;li&gt;可以把几个组件合并成一个包，可以使用的关键字为 &lt;code&gt;package, node, folder, frame, cloud, database&lt;/code&gt;。不同的关键字图形不一样。&lt;/li&gt;
&lt;li&gt;可以在包内部用不同的箭头表达同一个包的组件之间的关系&lt;/li&gt;
&lt;li&gt;可以在包内部直接表达到另外一个包内部的组件的交互关系&lt;/li&gt;
&lt;li&gt;可以在流程图外部直接表达包之间或包的组件之间的交互关系&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_6"&gt;状态图&lt;/h3&gt;
&lt;p&gt;我们一般使用状态图来画状态机。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;@startuml

scale 640 width

[*] --&amp;gt; NotShooting

state NotShooting {
    [*] --&amp;gt; Idle
    Idle --&amp;gt; Processing: SignalEvent
    Processing --&amp;gt; Idle: Finish
    Idle --&amp;gt; Configuring : EvConfig
    Configuring --&amp;gt; Idle : EvConfig
}

state Configuring {
    [*] --&amp;gt; NewValueSelection
    NewValueSelection --&amp;gt; NewValuePreview : EvNewValue
    NewValuePreview --&amp;gt; NewValueSelection : EvNewValueRejected
    NewValuePreview --&amp;gt; NewValueSelection : EvNewValueSaved
    state NewValuePreview {
        State1 -&amp;gt; State2
    }
}

@enduml
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="State Diagram" src="http://plantuml.com/plantuml/png/SoWkIImgAStDuIfEJin9LJ0sDL0epqmfoU2ArefLqDMrK_3BBmdEoCyloSnBvm8gBab55b6eXglpJCb9vG8HO9vpVbvQPdff4KYDbO9h6OJFXImCquGiNmkr0baTmWg_rFAmn9pIrE3KdDJaaipyF2uC4HHr0KMfPPcfvM0BO69Sw99O3KRH4fIQ1HHDJI53Qt1Y6L0VDDZGT5Tp1OF43HM0fe1PHa3lrt8vfEQb0EC30000" /&gt;&lt;/p&gt;
&lt;p&gt;TIPS:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;[*]&lt;/code&gt; 来表示状态的起点&lt;/li&gt;
&lt;li&gt;使用 state 来定义子状态图&lt;/li&gt;
&lt;li&gt;状态图可以嵌套&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;scale&lt;/code&gt; 命令来指定生成的图片的尺寸&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_7"&gt;总结&lt;/h2&gt;
&lt;p&gt;不需要去记这些标记，在需要的时候去使用它，通过不断地使用来熟悉不同的图的语法。可以下载 &lt;a href="http://plantuml.com/PlantUML_Language_Reference_Guide.pdf"&gt;PlanUML 官方文档&lt;/a&gt; 作为参考，遇到问题的时候翻一翻，这样很快就可以学会使用 PlantUML 高效地画图。&lt;/p&gt;</summary><category term="sublime"></category><category term="uml"></category></entry><entry><title>K 均值算法</title><link href="http://blog.kamidox.com/k-mean.html" rel="alternate"></link><updated>2015-12-08T21:31:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-12-08:k-mean.html</id><summary type="html">&lt;h2 id="clustering"&gt;聚类问题 Clustering&lt;/h2&gt;
&lt;p&gt;针对监督式学习，输入数据为 (x, y) ，目标是找出分类边界，即对新的数据进行分类。而无监督式学习只给出一组数据集 ${x_1, x_2, &amp;hellip; , x_m}$ ，目标是去找出这组数据的模式特征，比如哪些数据是一种类型的，哪些数据是另外一种类型的。典型的无监督式学习包括市场细分，通过分析用户数据，来把一个产品的市场进行细分，找出细分人群。另外一个是社交网络分析，分析社交网络中的参与人员的不同特点，根据特点区分出不同群体。这些都是无监督式学习里的聚类 (Clustering) 问题。&lt;/p&gt;
&lt;h2 id="k"&gt;K 均值算法&lt;/h2&gt;
&lt;p&gt;K 均值算法算法就是一种解决聚类问题的算法，它包含两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给聚类中心分配点：计算所有的训练样例，把他分配到距离某个聚类中心最短的的那聚类里。&lt;/li&gt;
&lt;li&gt;移动聚类中心：新的聚类中心移动到这个聚类所有的点的平均值处。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一直重复做上面的动作，直到聚类中心不再移动为止。这个时候我们就探索出了数据集的结构了。可以通过一个动画来直观地看一下 K 均值算法聚类的过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="k-means animation" src="http://simplystatistics.org/wp-content/uploads/2014/02/kmeans.gif" /&gt;&lt;/p&gt;
&lt;p&gt;用数学的方法来描述 K 均值算法如下：&lt;/p&gt;
&lt;p&gt;算法有两个输入信息。一是 K 表示选取的聚类个数；二是训练数据集 ${x^{(1)}, x^{(2)}, &amp;hellip; , x^{(m)}}$。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机选择 K 个聚类中心 $u_1, u_2, &amp;hellip; , u_k$。&lt;/li&gt;
&lt;li&gt;从 1 - m 遍历所有的数据集，计算 $x^{(i)}$ 分别到 $u_1, u_2, &amp;hellip; , u_k$ 的距离，记录距离最短的聚类中心点。然后把 $x^{(i)}$ 这个点分配给这个聚类。令 $c^{(i)} = j$ 其中 $u_j$ 就是与 $x^{(i)}$ 距离最短的聚类中心点。计算距离时，一般使用 $\| x^{(i)} - u_j \|^2$ 来计算。&lt;/li&gt;
&lt;li&gt;从 1 - K 遍历所有的聚类中心，移动聚类中心的新位置到这个聚类的均值处。即 $u_j = \frac{1}{c} \left( \sum_{d=1}^c \right)$ ，其中 c 表示分配给这个聚类的训练样例点的个数。如果特殊情况下，没有点分配给这个聚类中心，那么说明这个聚类中心就不应该存在，直接删除掉这个聚类中心，最后聚类的个数变成 K - 1 个。&lt;/li&gt;
&lt;li&gt;重复步骤 2 ，直到聚类中心不再移动为止。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="k_1"&gt;K 均值算法成本函数&lt;/h3&gt;
&lt;p&gt;$$&lt;br /&gt;
J = \frac{1}{m} \sum_{i=1}^m \| x^{(i)} - u_{c^{(i)}} \|^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中， $c^{(i)}$ 是训练样例 $x^{(i)}$ 分配的聚类序号；$u_{c^{(i)}}$ 是 $x^{(i)}$ 所属的聚类的中心点。K 均值算法的成本函数的物理意义，就是&lt;strong&gt;训练样例到其所属的聚类中心点的距离的平均值&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="_1"&gt;随机初始化聚类中心点&lt;/h3&gt;
&lt;p&gt;假设 K 是聚类的个数，m 是训练样本的个数，那么必定有 $K &amp;lt; m$。在随机初始化时，随机从 m 个训练数据集里选择 K 个样本来作为聚类中心点。这是正式推荐的随机初始化聚类中心的做法。&lt;/p&gt;
&lt;p&gt;在实际解决问题时，最终的聚类结果会和随机初始化的聚类中心点有关。即不同的随机初始化的聚类中心点可能得到不同的最终聚类结果。因为成本函数可能会收敛在一个局部最优解，而不是全局最优解上。一个解决方法是多做几次随机初始化的动作，然后训练出不同的取类中心点以及聚类节点分配方案。然后用这些值算出成本函数，最终选择那个成本最小的。&lt;/p&gt;
&lt;p&gt;比如，假设我们做 100 次运算，步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机选择 K 个聚类中心点&lt;/li&gt;
&lt;li&gt;运行 K 均值算法，算出 $c^{(1)}, c^{(2)}, &amp;hellip; , c^{(m)}$ 和 $u_1, u_2, &amp;hellip; , u_k$&lt;/li&gt;
&lt;li&gt;使用 $c^{(1)}, c^{(2)}, &amp;hellip; , c^{(m)}$ 和 $u_1, u_2, &amp;hellip; , u_k$ 算出最终的成本值&lt;/li&gt;
&lt;li&gt;记录最小的成本值，然后跳回步骤 1，直到达到最大运算次数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样我们可以适当加大运算次数，从而求出全局最优解。&lt;/p&gt;
&lt;h3 id="_2"&gt;选择聚类的个数&lt;/h3&gt;
&lt;p&gt;怎么样选择合适的聚类个数呢？实际上聚类个数和业务有紧密的关联，比如我们要对 T-Shirt 大小进行聚类分析，我们是分成 3 个尺寸好呢还是分成 5 个尺寸好？这个更多的是个业务问题而非技术问题。3 个尺寸可以给生产和销售带来便利，但客户体验可能不好。5 个尺寸客户体验好了，但可能会给生产和库存造成不便。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Elbow" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_km_elbow.png" /&gt;&lt;/p&gt;
&lt;p&gt;从技术角度来讲，也是有一些方法可以来做一些判断的。我们可以把聚类个数作为横坐标，成本函数作为纵坐标，这样把成本和聚类个数的数据画出来。如上图所示。大体的趋势是随着 K 值越来越大，成本越来越低。我们找出一个拐点，即在这个拐点之前成本下降比较快，在这个拐点之后，成本下降比较慢，那么很可能这个拐点所在的 K 值就是我们要寻求的最优解。&lt;/p&gt;
&lt;p&gt;当然，这个技术方法并不总是有效，我们很可能会得到一个没有拐点的曲线，这样的话，就必须和业务逻辑结合以便选择合适的聚类个数。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>支持向量机核函数</title><link href="http://blog.kamidox.com/svm-kernel.html" rel="alternate"></link><updated>2015-12-07T23:04:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-12-07:svm-kernel.html</id><summary type="html">&lt;h2 id="_1"&gt;核函数&lt;/h2&gt;
&lt;p&gt;什么是核函数？核函数是&lt;strong&gt;特征转换&lt;/strong&gt;函数。这是非常抽象的描述，这一节的内容就是为了理解这个抽象的概念的。&lt;/p&gt;
&lt;h3 id="_2"&gt;从多项式说起&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Non-linear Decsion Boundary" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_sk_boundary.png" /&gt;&lt;/p&gt;
&lt;p&gt;假设我们有一个非线性分界线的分类问题，有两个特征 $x_1, x_2$ ，回顾逻辑回归算法里的知识，我们可以使用多项式来增加特征，以便描述出非线性分界线。当：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_0 + \theta_1 x_1 + \theta_2 x_2 + \theta_3 x_1 x_2 + \theta_4 x_1^2 + \theta_5 x_2^2 + &amp;hellip; &amp;gt;= 0&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;时，我们预测出 $y=1$。上述公式只写了二阶多项式，我们可以写到更高阶的多项式来模拟复杂的分界线。我们改写一下上面的公式：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_0 + \theta_1 f_1 + \theta_2 f_2 + \theta_3 f_3 + \theta_4 f_4 + \theta_5 f_5 + &amp;hellip; &amp;gt;= 0&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这里，$f_1=x_1, f_2 = x_2, f_3 = x_1 x_2, f_4 = x_1^2, f_5 = x_2^2 &amp;hellip;$ 。&lt;/p&gt;
&lt;p&gt;那么问题来了，&lt;strong&gt;除了多项式外，有没有更好地途径把特征 $x_1, x_2$ 映射到特征 $f_1, f_2, f_3, f_4, f_5 &amp;hellip;$ 呢？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="_3"&gt;相似性函数&lt;/h3&gt;
&lt;p&gt;我们在二维坐标上选择三个标记点 $l^{(i)}$ ，针对一个训练样例 $x$，我们使用相似性函数来定义新的特征：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
f_i &amp;amp;= similarity(x, l^{(i)}) \\&lt;br /&gt;
&amp;amp;= exp \left( - \frac{\| x - l^{(i)} \|^2}{2\sigma^2} \right) \\&lt;br /&gt;
&amp;amp;= exp \left( - \frac{\sum_{j=1}^n (x_j - l_j^{(i)})^2}{2\sigma^2} \right) \\&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;如下图所示，当我们选择三个标记点 $l^{(1)}, l^{(2)}, l^{(3)}$ 时，针对一个只有两个特征的训练样例 $(x_1, x_2)$，通过我们的相似性函数映射后，我们将得到 $f_1, f_2, f_3$ 三个新特征。&lt;/p&gt;
&lt;p&gt;&lt;img alt="landmark" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_sk_landmark.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相似性函数的物理意义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\| x - l^{(i)} \|^2$ 在二维平面上的物理意义是点 $x$ 到标记点 $l^{(i)}$ 的距离。从向量角度来理解，个是向量的范数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高斯核函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f_i = exp \left( - \frac{\sum_{j=1}^n (x_j - l_j^{(i)})^2}{2\sigma^2} \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;我们把上面的相似性函数称为高斯核函数，它的主要作用就是&lt;strong&gt;把输入特征映射到另外一组特征&lt;/strong&gt;上。当 $x$ 离标记点 $l^{(i)}$ 很近的时候，这两个点间的距离接近于 0 ，故 $f_i$ 接近于 1 。当 $x$ 离标记点 $l^{(i)}$ 很远的时候，这两个点间的距离接近于无穷大，故 $f_i$ 接近于 0 。&lt;/p&gt;
&lt;h3 id="_4"&gt;理解相似性函数&lt;/h3&gt;
&lt;p&gt;假设我们选择了三个标识点 $l^{(1)}, l^{(2)}, l^{(3)}$ ，映射出三个新特征 $f_1, f_2, f_3$ ，那么当：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_0 + \theta_1 f_1 + \theta_2 f_2 + \theta_3 f_3 &amp;gt;= 0&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;时，我们预测为 1。假设我们训练出来的参数为 $\theta_0 = -0.5, \theta_1 = 1, \theta_2 = 1, \theta_3 = 0$ ，那么当某个测试样例点 $x$ 靠近 $l^{(1)}$ ，但远离 $l^{(2)}, l^{(3)}$ 时，我们可以得出：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_0 + \theta_1 f_1 + \theta_2 f_2 + \theta_3 f_3 = -0.5 + 1 + 0 + 0 = 0.5 &amp;gt;= 0&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;即我们把测试样例点 $x$ 归类到 $y=1$ 这个类别里。相同的道理，假设某个测试样例 $x$ 离三个标记点都很远，那么：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_0 + \theta_1 f_1 + \theta_2 f_2 + \theta_3 f_3 = -0.5 + 0 + 0 + 0 = -0.5 &amp;lt; 0&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;&lt;img alt="prediction" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_sk_predict.png" /&gt;&lt;/p&gt;
&lt;p&gt;这样我们得出结论，把 $x$ 归类到 $y=0$ 这个类别里。使用相同的方法，最终我们针对所有的测试样例进行归类。&lt;/p&gt;
&lt;h2 id="_5"&gt;带核函数的支持向量机算法&lt;/h2&gt;
&lt;h3 id="_6"&gt;选择标记点&lt;/h3&gt;
&lt;p&gt;&lt;img alt="Select Landmark" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_sk_landmark_select.png" /&gt;&lt;/p&gt;
&lt;p&gt;定义标记点 (landmark) 的一个很自然的方法是直接把 landmark 定义在训练数据集的训练样例上，即 $l^{(i)}=x^{(i)}$。那么给定一个新的交叉验证数据集或测试数据集里的样例 $x$，它与 landmark 的相似性函数，即高斯核函数如下&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
f_i = similarity(x, l^{(i)}) = exp \left( - \frac{\| x - l^{(i)} \|^2}{2\sigma^2} \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;针对训练样例，也满足上述核函数。由于我们选择 landmark 与训练样例重合，所以针对训练样例 $x^{(i)}$ 有 $f_i=1$ 。&lt;/p&gt;
&lt;h3 id="_7"&gt;计算预测值&lt;/h3&gt;
&lt;p&gt;假如我们已经算出了 $\theta$，那么当 $\theta^Tf &amp;gt;= 0$ 时，预测值为 1，反之为 0。&lt;/p&gt;
&lt;h3 id="_8"&gt;计算参数&lt;/h3&gt;
&lt;p&gt;根据 SVM 的成本函数，由于我们把 $f$ 代替 $x$ 作为新的特征，所以我们可以通过最小化下面的函数来计算得出参数 $\theta$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = C \left[ \sum_{i=1}^m y^{(i)} cost_1(\theta^T f^{(i)}) + (1 - y^{(i)}) cost_0(\theta^T f^{(i)}) \right] + \frac{1}{2} \sum_{j=1}^n \theta_j^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;针对上述公式，实际上 $m=n$，因为 $f$ 是由训练数据集 $x^{(i)}$ 定义，即 $f$ 是一个 m 维的向量。&lt;/p&gt;
&lt;h3 id="_9"&gt;支持向量机算法的参数&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;C 值越大，越容易造成过拟合，即 lower bias, higher variance. 当 C 值越小，越容易造成欠拟合，即 higher bias, lower variance。&lt;/li&gt;
&lt;li&gt;$\sigma^2$ 越大，高斯核函数的变化越平缓，会导致 higher bias, lower variance。当 $\sigma^2$ 越小，高斯核函数变化越快，会导致 lower bias, higher variance。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="svm"&gt;实践中的 SVM&lt;/h2&gt;
&lt;p&gt;一般情况下，我们使用 SVM 库 (liblinear, libsvm &amp;hellip;) 来求解 SVM 算法的参数 $\theta$，而不是自己去实现 SVM 算法。在使用这些库的时候，我们要做的步骤如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择参数 C&lt;/li&gt;
&lt;li&gt;选择核函数&lt;ul&gt;
&lt;li&gt;可以支持空的核函数，即线性核函数 (linear kernel)。Predict &amp;ldquo;y = 1&amp;rdquo; if $\theta^Tx &amp;gt;= 0$。&lt;/li&gt;
&lt;li&gt;高斯核函数 $f_i = exp \left( - \frac{\| x - l^{(i)} \|^2}{2\sigma^2} \right)$，这个时候需要选择合适的参数 $\sigma^2$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在使用第三方算法的时候，一般需要我们提供核函数的实现。输入参数是 $x_1, x_2$，输出为新的特征值 $f_i$。另外一个需要注意的点是，如果使用高斯核函数，在实现核函数时，需要对参数进行缩放，以便加快算法收敛速度。&lt;/p&gt;
&lt;h3 id="_10"&gt;多类别的分类算法&lt;/h3&gt;
&lt;p&gt;这个和逻辑回归里介绍的 one-vs.-all 一样。可以先针对一个类别和其他类别做二元分类，逐个分类出所有的类别。这样我们得到一组参数。假如，我们有 K 个类别，那么我们最终将得到 $\theta^{(1)}, \theta^{(2)}, \theta^{(3)} &amp;hellip; \theta^{(K)}$ 个参数。&lt;/p&gt;
&lt;h3 id="_11"&gt;算法选择&lt;/h3&gt;
&lt;p&gt;逻辑回归和 SVM 都可以用来解决分类问题，他们适用的场景有些区别。&lt;/p&gt;
&lt;p&gt;假设 n 是特征个数；m 是训练数据集的样例个数。一般可以按照下面的规则来选择算法。&lt;/p&gt;
&lt;p&gt;如果 n 相对 m 来说比较大。比如 n = 10,000; m = 10 - 1000，如文本处理问题，这个时候使用逻辑回归或无核函数的 SVM 算法。&lt;br /&gt;
如果 n 比较小，m 中等大小。比如 n = 1 - 1000; m = 10 - 10,000。那么可以使用高斯核函数的 SVM 算法。&lt;br /&gt;
如果 n 比较小，m 比较大。比如 n = 1 - 1000; m = 50,000+ 。那么一般需要增加特征，并且使用逻辑回归或无核函数的 SVM 算法。&lt;/p&gt;
&lt;p&gt;以上的所有情况都可以使用神经网络来解决。但训练神经网络的计算成本比较高。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>支持向量机 SVM 算法</title><link href="http://blog.kamidox.com/svm.html" rel="alternate"></link><updated>2015-12-03T22:04:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-12-03:svm.html</id><summary type="html">&lt;p&gt;支持向量机算法 SVM 是 Support Vector Machine 的缩写，它是工业和学术界都有广泛应用的强大的算法。&lt;/p&gt;
&lt;h2 id="_1"&gt;从逻辑回归算法谈起&lt;/h2&gt;
&lt;h3 id="_2"&gt;逻辑回归算法的预测函数&lt;/h3&gt;
&lt;p&gt;逻辑回归算法的预测函数称为 Sigmoid Function ，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="contacts_structure" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Logistic-curve.svg/320px-Logistic-curve.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;这意味着，针对 $y=1$，我们希望预测值 $h(x) \approx 1$，那么只要 $z=\theta^T x \gg 0$ 即可。相同的道理，针对 $y=0$，我们希望预测值 $h(x) \approx 0$，那么只要 $z=\theta^T x \ll 0$ 即可。&lt;/p&gt;
&lt;h3 id="_3"&gt;逻辑回归算法的成本函数&lt;/h3&gt;
&lt;p&gt;回顾之前的知识，逻辑回归算法的成本函数如下&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = -\frac{1}{m} \left[ \sum_{i=1}^m y^{(i)} log(h_\theta(x^{(i)})) + (1 - y^{(i)}) log(1 - h_\theta(x^{(i)})) \right] + \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;如果我们去掉 $\frac{1}{m}$ 和累加器，同时暂时不考虑正则项，则可以得到另外一个样式的成本函数：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = - y^{(i)} log(h_\theta(x^{(i)})) - (1 - y^{(i)}) log(1 - h_\theta(x^{(i)}))&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;当 $y^{(i)}=1$ 时，$1-y^{(i)}=0$，故这一式子再简化为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = - y^{(i)} log(h_\theta(x^{(i)})) = - log(\frac{1}{1 + e^{-z}})&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;把上述函数以成本 J 为纵坐标，z 为横坐标，画出来的函数曲线如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="cost 1" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_svm_cost_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，针对 $y=1$ 的情况，如果 $z=\theta^T x \gg 1$ 时，成本将很小。&lt;strong&gt;支持向量机的原理，就是简化逻辑回归算法的成本函数，以 $z=1$ 为分界线，当 $z&amp;lt;1$ 时，把成本函数简化为一条斜线，当 $z&amp;gt;=1$ 时，直接把成本简化为 0&lt;/strong&gt;。如上图洋红色所示。&lt;/p&gt;
&lt;p&gt;相同的道理，针对$y^{(i)}=0$ 时，变形后的逻辑回归算法成本函数简化为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = -(1 - y^{(i)}) log(1 - h_\theta(x^{(i)})) = - log(1 - \frac{1}{1 + e^{-z}})&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;把上述函数以成本 J 为纵坐标，z 为横坐标，画出来的函数曲线如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="cost 1" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_svm_cost_0.png" /&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，针对 $y=0$ 的情况，如果 $z=\theta^T x \ll -1$ 时，成本将很小。&lt;strong&gt;支持向量机的原理，就是简化逻辑回归算法的成本函数，以 $z=-1$ 为分界线，当 $z&amp;lt;-1$ 时，把成本函数简化为 0，当 $z&amp;gt;=-1$ 时，把成本简化一条斜线&lt;/strong&gt;。如上图洋红色所示。&lt;/p&gt;
&lt;h3 id="_4"&gt;支持向量机算法的成本函数&lt;/h3&gt;
&lt;p&gt;根据上面的定义，支持向量机把成本函数分成两部分，一部分是针对 $y=1$ 的情况，它是一个以 $z=1$ 为分界点的折线。另外一部分是针对 $y=0$ 的情况，它是以 $z=-1$ 为分界点的折线。我们把这两个情况合并起来，并把正则项加上去，就得到支持向量机的成本函数：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = C \left[ \sum_{i=1}^m y^{(i)} cost_1(\theta^T x^{(i)}) + (1 - y^{(i)}) cost_0(\theta^T x^{(i)}) \right] + \frac{1}{2} \sum_{j=1}^n \theta_j^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这就是用在支持向量机算法里的成本函数。这里的参数 C 越大，正则项的比重就越小，就容易造成过拟合。反之，如果 C 越小，正则项的比重就越大，就容易造成欠拟合。&lt;/p&gt;
&lt;h3 id="_5"&gt;支持向量机的预测函数&lt;/h3&gt;
&lt;p&gt;我们定义支持向量机的预测函数如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
h_\theta(x) = \begin{cases}&lt;br /&gt;
    1, &amp;amp; \text{if $\theta^T x$ &amp;gt;= 1} \\&lt;br /&gt;
    0, &amp;amp; \text{if $\theta^T x$ &amp;lt;= -1} \\&lt;br /&gt;
\end{cases}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这里和逻辑回归算法比较，针对逻辑回归算法，其正负样本分界线为 $\theta^T x = 0$，即 $\theta^T x &amp;gt; 0$ 时为正样本，当 $\theta^T x &amp;lt; 0$ 时为负样本。而&lt;strong&gt;支持向量机的分类预测函数要求更严格&lt;/strong&gt;，它要求 $\theta^T x &amp;gt;= 1$ 时为正样本，$\theta^T x &amp;lt;= -1$ 时为负样本。根据支持向量机的成本函数图形，只有这样成本才最小，即成本为零。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="svm cost" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_svm_cost.png" /&gt;&lt;/p&gt;
&lt;h2 id="_6"&gt;大间距分类算法&lt;/h2&gt;
&lt;p&gt;支持向量机也称为大间距分类算法。大间距的意思是，用 SVM 算法计算出来的分界线会保留对类别最大的间距，即有足够的余量。&lt;/p&gt;
&lt;p&gt;我们看一个比较极端的情况，假设我们选取一个很大的值作为参数 C 的值，那么为了让成本最小，我们必须让成本函数的前半部分为 0，这样成本函数就只剩下：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = \frac{1}{2} \sum_{j=1}^n \theta_j^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;求解这个函数的结果，就会让我们获得一个较大间距的分类算法。如下图所示，假设我们有个分类问题。那么洋红色和绿色的都可以是合法的分界线，但 SVM 可以得到黑色的分界线，即确保到两个类别有最大的间距。&lt;/p&gt;
&lt;p&gt;&lt;img alt="svm decision boundary" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_svm_db.png" /&gt;&lt;/p&gt;
&lt;p&gt;为什么求解 $J(\theta) = \frac{1}{2} \sum_{j=1}^n \theta_j^2$ 会得到最大间距的分界线呢？这个我们留到下面详细解释。&lt;/p&gt;
&lt;p&gt;我们接着看下图，如果我们的参数 C 很大，那么可能发生过拟合，即左下角的一个异常的红色样例 X 可能会导致决策界从黑色线变成洋红色线。但实际上，直观地来理解，这样的转变是不合理的，我们仍然希望得到黑色的决策界。这个时候，我们可以调整参数 C ，让 C 的值不要太大，这样就不会被左下角的红色 X 异常样例的干扰，照样得到黑色的决策边界。&lt;/p&gt;
&lt;p&gt;&lt;img alt="svm overfitting" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_svm_db_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;与逻辑回归算法类比，C 相当于 $\frac{1}{\lambda}$。通过调整 C 可以让 SVM 算法不至于过拟合，也不至于欠拟合。&lt;/p&gt;
&lt;h2 id="_7"&gt;从数学角度理解大间距分类算法&lt;/h2&gt;
&lt;h3 id="_8"&gt;向量内积的几何含义&lt;/h3&gt;
&lt;p&gt;假设 u, v 是一个二维列向量，那么 $u^Tv$ 表示向量 v 在 向量 u 上的投影的长度。可以通过在二维平面上画出向量 u 和向量 v 来更清楚地看这个关系。&lt;/p&gt;
&lt;p&gt;&lt;img alt="vector inner product" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_svm_inner_product.png" /&gt;&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
u^T v = u_1 v_1 + u_2 v_2 = p \|u\|&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 p 就是 v 在 u 上的投影的长度，它是有符号的实数；$\|u\|$ 是向量 u 的范数，即向量 u 的长度，其值为 $\sqrt{u_1^2 + u_2^2}$。&lt;/p&gt;
&lt;h3 id="_9"&gt;从数学上理解为什么支持向量机会把类别边界的间距做到最大&lt;/h3&gt;
&lt;p&gt;假设我们只有两个特征，即 n = 2，则 $J(\theta) = \frac{1}{2} \sum_{j=1}^n \theta_j^2$ 简化为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = \frac{1}{2} (\theta_1^2 + \theta_2^2) = \frac{1}{2} \left( \sqrt{\theta_1^2 + \theta_2^2} \right)^2 = \frac{1}{2} \| \theta \|^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;回到 SVM 算法的预测函数：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
h_\theta(x) = \begin{cases}&lt;br /&gt;
    1, &amp;amp; \text{if $\theta^T x$ &amp;gt;= 1} \\&lt;br /&gt;
    0, &amp;amp; \text{if $\theta^T x$ &amp;lt;= -1} \\&lt;br /&gt;
\end{cases}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;即当预测为正样本时，我们需要 $\theta^T x &amp;gt;=1$，这个式子可以理解为向量内积，它的几何含义是&lt;strong&gt;x 在 $\theta$ 上的投影的长度&lt;/strong&gt;大于等于 1，即 $p \| \theta \| &amp;gt;= 1$。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="theta and x inner product" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_svm_inner_product_xt.png" /&gt;&lt;/p&gt;
&lt;p&gt;而我们的算法求解目标是使 $J(\theta) = \frac{1}{2} \| \theta \|^2$ 最小，所以 SVM 算法的求解目标就是要让 p 尽可能最大。即使所有的训练样例点 $x^{i}$ 到参数向量 $\theta$ 的投影长度最大。在几何上，&lt;strong&gt;决策边界和参数 $\theta$ 是正交的&lt;/strong&gt;。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="svm decision boundary" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_svm_db_3.png" /&gt;&lt;/p&gt;
&lt;p&gt;绿色线为决策边界，绿色线为 $\theta$ 所代表的向量。那么 &lt;strong&gt;SVM 的求解目标就是让各个训练样例的点 $x^{i}$ 到 $\theta$ 上的投影长度最大&lt;/strong&gt;。上图中，我们可以试着换一个决策边界，试着画出训练样例到这个新的决策边界所决定的参数 $\theta$ 的投影长度，即可理解为什么 SVM 可以让决策边界得到最大的间距。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>机器学习系统的设计与调优</title><link href="http://blog.kamidox.com/evaluating-2.html" rel="alternate"></link><updated>2015-12-02T23:08:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-12-02:evaluating-2.html</id><summary type="html">&lt;h2 id="_1"&gt;构建垃圾邮件过滤系统&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;特征选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实践中，可以遍历所有的训练数据集，即所有的垃圾邮件和所有的非垃圾邮件，找出出现频率最高的 10,000 - 50,000 个单词作为特征，假设特征数量记为 n。这样&lt;strong&gt;一封邮件就可以用一个 n 维向量来表示&lt;/strong&gt;，即 n 个特征单词是否出现在邮件里，如果出现记为 1 不出现记为 0 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构建步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集尽量多的数据，如 &lt;a href="http://www.projecthoneypot.org"&gt;honeypot&lt;/a&gt; 项目&lt;/li&gt;
&lt;li&gt;从邮件路由信息中提取出有效的特征来区分垃圾邮件，路由信息放在邮件头部&lt;/li&gt;
&lt;li&gt;从邮件的内容中提取复杂特征&lt;/li&gt;
&lt;li&gt;开发一套算法来检查拼写错误。因为很多算法从邮件内容中通过关键字为特征来区分垃圾邮件，垃圾邮件系统为了跳过这个检查，故意把一些敏感词拼错，这样规避垃圾邮件检查机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于哪个方法是最有效的，需要头脑风暴或者事先详细研究才能得出结论。当然，在算法通过检验之前，很难事先判断哪个特征是最有效的。&lt;/p&gt;
&lt;h2 id="_2"&gt;错误分析&lt;/h2&gt;
&lt;p&gt;用机器学习算法解决问题时，可以偿试如下的策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;从简单的算法开始&lt;/strong&gt;，先实现出来，然后使用交叉验证数据来验证结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;画出学习曲线&lt;/strong&gt;，诊断算法的问题和优化方向，是需要去获取更多训练数据还是要增加特征等。&lt;/li&gt;
&lt;li&gt;错误分析：&lt;strong&gt;针对交叉验证数据的错误项进行手动分析&lt;/strong&gt;，试图从这些错误结果里找出更多线索和特征。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;错误分析实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们实现的垃圾邮件过滤算法，针对 500 封交叉验证数据里有 100 封被错误分类了，那么我们可以进行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动检查这些被错误分类的邮件类型，比如钓鱼邮件，卖药的邮件等等，通过手动分析总结出哪种类型的邮件被错误地分类数量最多，然后先把精力花在这种类型的邮件上面。&lt;/li&gt;
&lt;li&gt;有哪些线索或特征有助于算法正确鉴别这些邮件。比如通过分析，我们发现异常路由的邮件数量有多少，错误拼写的邮件有多少，异常标点符号的邮件有多少。通过总结这些特征，决定我们应该要把时间花在哪方面来改善算法性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如，我们在实现垃圾邮件鉴别算法时，我们需要决定 Dicount/Discounts/Discounted/Discouting 等单词视为同一个单词还是不同的单词。如果要视为相同的单词，可以使用词干提取法 (Porter Stemmer) ，但使用词干提取法一样会带来问题，比如会错误地把 universe/university 归类为同一个单词。这个时候如何决策呢？&lt;/p&gt;
&lt;p&gt;一个可行的办法是分别计算使用了词干提取法和不使用时候的交叉验证数据集成本 $J_{cv}(\theta)$ 和测试数据集成本 $J_{test}(\theta)$ ，这样来判断到底是使用更好还是不使用性能更好。&lt;/p&gt;
&lt;p&gt;实际上，优化算法过程中的很多偿试都可以使用这个方法来判断是否是有效的优化策略。&lt;/p&gt;
&lt;h2 id="_3"&gt;处理有倾向性的数据&lt;/h2&gt;
&lt;p&gt;比如针对癌症筛查算法，根据统计，普通肿瘤中癌症的概率是 0.5% 。我们有个机器学习算法，在交叉验证数据时得出的准确率是 99.2%，错误率是 0.8% 。这个算法到底是好还是坏呢？如果努力改进算法，最终在交叉验证数据集上得出的准确率是 99.5%，错误率是 0.5% 到底算法性能是提高了还是降低了呢？&lt;/p&gt;
&lt;p&gt;坦白讲，如果单纯从交叉验证数据集上测试准确率的方法很难进行判断到底算法是变好了还是变坏了。因为这个事情的先验概率太低了，假如我们写了一个超级简单的预测函数，总是返回 0，即总是认为不会得癌症，那么我们这个超级简单的预测函数在交叉验证数据集上得到的准确率是 99.5%，错误率是 0.5% 。因为总体而言，只有那 0.5% 真正得癌症的可怜虫被我们误判了。&lt;/p&gt;
&lt;p&gt;那么我们怎么样来衡量分类问题的准确性能呢？我们引入了另外两个概念，&lt;strong&gt;查准率 (Precision)&lt;/strong&gt; 和 &lt;strong&gt;召回率 (Recall)&lt;/strong&gt;。还是以癌症筛查为例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;预测数据/实际数据&lt;/th&gt;
&lt;th&gt;实际恶性肿瘤&lt;/th&gt;
&lt;th&gt;实际良性肿瘤&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;预测恶性肿瘤&lt;/td&gt;
&lt;td&gt;TruePositive&lt;/td&gt;
&lt;td&gt;FalsePositive&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;预测良性肿瘤&lt;/td&gt;
&lt;td&gt;FalseNegative&lt;/td&gt;
&lt;td&gt;TrueNegative&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;$$&lt;br /&gt;
Precision = \frac{TruePosition}{TruePosition + FalsePositive}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
Recall = \frac{TruePositive}{TruePositive + FalseNegative}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;在处理先验概率低的问题时，我们总是把概率较低的事件定义为 1 ，并且总是把 $y=1$ 作为 Positive 的预测结果。有了这个公式，如果一个简单地返回 0 的预测函数，那么它的查准率和召回率都为 0。这显然不是个好的预测模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIPS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何理解 &lt;code&gt;True/False&lt;/code&gt; 和 &lt;code&gt;Positive/Negative&lt;/code&gt; ？&lt;code&gt;True/False&lt;/code&gt; 表示预测结果是否正确，而 &lt;code&gt;Positive/Negative&lt;/code&gt; 表示预测结果是 1 (恶性肿瘤) 或 0 (良性肿瘤)。故，TruePositive 表示正确地预测出恶性肿瘤的数量；FalsePositive 表示错误地预测出恶性肿瘤的数量；FalseNegative 表示错误地预测出良性肿瘤的数量。&lt;/p&gt;
&lt;h2 id="_4"&gt;在查准率和召回率之间权衡&lt;/h2&gt;
&lt;p&gt;假设我们想提高癌症的查准率，即只有在很有把握的情况下才预测为癌症。回忆我们在逻辑回归算法里，当 $h_\theta(x) &amp;gt;= 0.5$ 时，我们就预测 $y = 1$ ，为了提高查准率，可以把门限值从 0.5 提高到 0.8 之类的。这样就提高了查准率，但这样会降低召回率。同样的道理，我们如果想提高召回率，可以降低门限值，从 0.5 降到 0.3 。这样召回率就会提高，但查准率就会降低。所以在实际问题时，可以要接实际问题，去判断是查准率重要还是召回率重要，根据重要性去调整门限值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何评价算法的好坏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于我们现在有两个指标，查准率和如回率，如果有一个算法的查准率是 0.5, 召回率是 0.4；另外一个算法查准率是 0.02, 召回率是 1.0；那么两个算法到底哪个好呢？&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们引入了 $F_1Score$ 的概念&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
F_1Score = 2 \frac{PR}{P + R}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 P 是查准率，R 是召回率。这样就可以用一个数值直接判断哪个算法性能更好。典型地，如果查准率或召回率有一个为 0，那么 $F_1Score$ 将会为 0。而理想的情况下，查准率和召回率都为 1 ，则算出来的 $F_1Score$ 为 1。这是最理想的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动选择门限值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前文介绍过，门限值可以调节查准率和召回率的高低。那么如何自动选择门限值以便让算法的性能最优呢？我们可以使用交叉验证数据，算出使 $F_1Score$ 最大的门限值。这个值就是我们自动选择出来的最优的门限值。&lt;/p&gt;
&lt;h2 id="_5"&gt;使用大量的数据集&lt;/h2&gt;
&lt;p&gt;Michele Banko and Eric Brill 在 2011 年用四种算法进行了一个自然语言的机器学习训练，结果发现，数据量越大，训练出来的算法准确性越高。他们得出了下图的结论。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Accuracy and data size" src="http://img.ptcms.csdn.net/article/201506/18/55828e0dad1e5.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;然后这个结论是些前提：&lt;strong&gt;有足够的特征进行机器学习&lt;/strong&gt;。怎么样判断是否有足够的特征呢？我们可以让这个领域的专家来人工预测。比如给出一个房子的面积，让房产经纪人预测其房价，他肯定无法正确地预测。因为特征不足，很难只根据房子的面积推算出房子的价格。&lt;/p&gt;
&lt;p&gt;怎么样从理论上证明这个结论呢？我们知道，如果我们有足够的特征来进行预测，意味着我们可以构建足够复杂的模型（比如神经网络）来让我们的预测函数有比较低的偏差 (Low Bais)，即让训练数据集成本 $J_{train}(\theta)$ 的值很小。如果我们有足够多的数据，就可以确保我们可以训练出一个低方差 (Low Variance) 的算法，即我们可以让交叉验证数据集成本 $J_{cv}(\theta)$ 接近训练数据集成本 $J_{train}(\theta)$ 。这样最终我们的测试数据集成本  $J_{test}(\theta)$ 也会靠近训练数据集成本 $J_{train}(\theta)$ 。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>机器学习算法的性能评估</title><link href="http://blog.kamidox.com/evaluating.html" rel="alternate"></link><updated>2015-12-01T22:48:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-12-01:evaluating.html</id><summary type="html">&lt;h2 id="_1"&gt;机器学习算法的性能评估&lt;/h2&gt;
&lt;h3 id="_2"&gt;为什么需要评估机器学习算法的性能&lt;/h3&gt;
&lt;p&gt;当我们辛苦开发出来的机器学习算法不能很好地预测新数据时，我们该怎么办呢？一般情况下，有以下几个方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取更多的训练数据&lt;/li&gt;
&lt;li&gt;减少输入的特征数量，避免出现过拟合&lt;/li&gt;
&lt;li&gt;增加有价值的特征，即重新解读并理解训练数据&lt;/li&gt;
&lt;li&gt;增加多项式特征&lt;/li&gt;
&lt;li&gt;减小正则化参数 $\lambda$&lt;/li&gt;
&lt;li&gt;增大正则化参数 $\lambda$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何评估机器学习算法，以便遇到问题时能知道用上面方法中的哪个方法？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对机器学习算法的性能进行评估，接下来就要介绍机器学习算法性能评估的方法&lt;/li&gt;
&lt;li&gt;对机器学习算法进行诊断，诊断是指通过对机器学习算法进行测试，以便找出算法在哪种情况下能良好地工作，哪种情况下无法良好地工作。进而找出算法性能优化的方向和方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="_3"&gt;预测函数模型性能评估&lt;/h3&gt;
&lt;p&gt;怎么样判断我们的预测函数模型的性能是可以接受的呢？&lt;/p&gt;
&lt;p&gt;我们可以把训练数据集分成两部分，随机选择 70% 的训练数据作为训练数据集，用来训练机器学习算法；另外 30% 作为测试数据集，用来验证训练出来的机器学习算法针对这些测试数据集的误差。&lt;strong&gt;一个好的机器学习算法应该是对训练数据集成本比较低，即较准确地拟合数据，同时对测试数据集误差比较小，即对未知数据有良好的预测性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如何计算测试数据集的误差呢？&lt;/p&gt;
&lt;p&gt;简单地说，就是用测试数据集和训练出来的机器学习算法参数，代入相应的成本函数里计算测试数据集的成本。&lt;/p&gt;
&lt;p&gt;针对线性回归算法，我们可以使用下面的公式计算测试数据集的误差，其中 m 是测试数据集的个数：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J_{test}(\theta) = \frac{1}{2m} \sum_{i=0}^m \left( h_\theta(x^{(i)}) - y^{(i)} \right)^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;针对逻辑回归算法，可以使用下面的公式计算测试数据集的误差，其中 m 是测试数据集的个数：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J_{test}(\theta) = -\frac{1}{m} \sum_{i=1}^m \left[ log(h_\theta(x^{(i)})) + (1 - y^{(i)}) log(1 - h_\theta(x^{(i)})) \right]&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;针对分类问题时，还可以用分类错误率来代替成本函数算法，从而更直观地观察到一个算法对测试数据集的误差情况。我们定义错误率为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
err(h_\theta(x), y) = \begin{cases}&lt;br /&gt;
    1, &amp;amp; \text{if error classification. $h_\theta(x) \geq 0.5$, $y$ = 0 or $h_\theta(x) &amp;lt; 0.5$, $y$ = 1} \\&lt;br /&gt;
    0, &amp;amp; \text{if correct classification. $h_\theta(x) \geq 0.5$, $y$ = 1 or $h_\theta(x) &amp;lt; 0.5$, $y$ = 0} \\&lt;br /&gt;
\end{cases}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;如何直观地理解错误率？如果预测出错了 (即实际值是 1 预测为 0 ，或者实际值是 0 预测为 1) ，则成本算为 1 。如果预测正确了，成本算为 0 。&lt;/p&gt;
&lt;p&gt;测试数据集的错误率定义为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
Test Error = \frac{1}{m} \sum_{i=0}^m err(h_\theta(x^{(i)}), y^{(i)})&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，m 为测试数据集的个数，$(x^{(i)}), y^{(i)})$ 为测试数据。直观地理解，就是针对测试数据集，其错误预测的数据的个数。&lt;/p&gt;
&lt;h3 id="_4"&gt;模型选择&lt;/h3&gt;
&lt;p&gt;模型选择问题包括怎么样选择多项式来拟合数据，怎么样把数据集分成训练数据集，验证数据集，测试数据集，怎么样确定正则化参数 lambda 的值等等。&lt;/p&gt;
&lt;p&gt;以多项式模型选择为例。假设我们用一阶多项式，二阶多项式，三阶多项式 &amp;hellip; 十阶多项式来拟合数据，多项式的阶数我们记为 d。我们把数据集分成训练数据集和测试数据集。先用训练数据集训练出机器学习算法的参数 $\theta^{(1)}, \theta^{(2)}, \theta^{(3)}, &amp;hellip; , \theta^{(10)}$ 分别代表从一阶到十阶多项式的参数。这个时候我们再用测试数据集算出针对测试数据集的成本 $J_test(\theta)$ 看哪个模型的测试数据集成本最低，这样我们选择这个测试数据集最低的多项式来拟合我们的数据。但实际上，&lt;strong&gt;这是不公平的，因为我们通过测试数据集的成本来选择多项式时，我们可能选择了一个针对测试数据集成本最低的多项式，即在模型选择过程中，我们通过测试数据集拟合了多项式的项数 d。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们把数据分成三部分，随机选择 60% 的数据作为训练数据集，其成本记为 $J(\theta)$，随机选择剩下的 20% 数据作为交叉验证数据集 (Cross Validation)，其成本记为 $J_{cv}(\theta)$，剩下的 20% 作为测试数据集，其成本记为 $J_{test}(\theta)$。&lt;/p&gt;
&lt;p&gt;在模型选择时，我们使用训练数据集来训练算法参数，用交叉验证数据集来验证参数，选择交叉验证数据集的成本 $J_{cv}(\theta)$ 最小的参数来选择合适的模型多项式 d ，最后再用测试数据集来测试选择出来的模型的针对测试数据集的错误率。&lt;strong&gt;因为在模型选择过程中，我们使用了交叉验证数据集，所以适配模型多项式 d 的过程中，实际上是没有使用我们的测试数据集的。这样保证了使用测试数据集来计算成本时，确保我们选择出来的模型没有见过测试数据，即测试数据集没有参与模型选择的过程。&lt;/strong&gt;这样算出来的针对测试数据集的成本是相对公平合理的。&lt;/p&gt;
&lt;p&gt;当然，在实践过程中，很多人直接把数据集分成训练数据集和测试数据集，然后通过比较测试数据集选择的成本来选择模型。&lt;/p&gt;
&lt;h3 id="bias-vs-variance"&gt;方差与偏差 Bias vs. Variance&lt;/h3&gt;
&lt;p&gt;假定 $J_{train}(\theta)$ 表示训练误差；$J_{cv}(\theta)$ 表示交叉验证误差；那么高方差意味着 $J_{train}(\theta)$ 很大，$J_{cv}(\theta)$ 也很大，这时算法是&lt;strong&gt;欠拟合&lt;/strong&gt;的。高偏差定义为 $J_{train}(\theta)$ 很小，但 $J_{cv}(\theta)$ 很大，这时算法是&lt;strong&gt;过拟合&lt;/strong&gt;的。&lt;/p&gt;
&lt;h3 id="_5"&gt;正则化与方差及偏差的关系&lt;/h3&gt;
&lt;p&gt;当 lambda 为零时，容易产生过拟合，即 $J_{train}(\theta)$ 很小，但 $J_{cv}(\theta)$ 很大，这个就是高偏差的定义。而当 lambda 太大时，$J_{train}(\theta)$ 很大，$J_{cv}(\theta)$ 也很大，此时会产生高方差。&lt;/p&gt;
&lt;p&gt;可以把数据集的成本作为纵坐标，lambda 作为横坐标，把 $J_{train}(\theta)$ 和 $J_{cv}(\theta)$ 以及 lambda 画在一个二维坐标轴上，这样我们可以明显地看到 $J_{train}(\theta)$ 和 $J_{cv}(\theta)$ 随着 lambda 的变化规则，从而编程自动找出最合适的 lambda 值。&lt;/p&gt;
&lt;h3 id="_6"&gt;学习曲线&lt;/h3&gt;
&lt;p&gt;我们可以把 $J_{train}(\theta)$ 和 $J_{cv}(\theta)$ 作为纵坐标，画出与训练数据集 m 的大小的关系。&lt;/p&gt;
&lt;p&gt;我们可以观察到当高偏差 (High Bias, Under Fitting) 时，随着训练数据集的增加，$J_{cv}(\theta)$ 不会明显地下降，且 $J_{train}(\theta)$ 增加很快，且最终&lt;strong&gt;$J_{train}(\theta)$ 和 $J_{cv}(\theta)$ 的值非常接近，且两个值都比较大&lt;/strong&gt;。这个就是过拟合的表现。从这个关系也可以看出来，&lt;strong&gt;当发生高偏差时，过多的训练数据样例不会对算法性能有较大的改善&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="contacts_structure" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_high_bias.png" /&gt;&lt;/p&gt;
&lt;p&gt;当高方差产生时 (High Variance, Over Fitting)，比如我们用 100 阶的多项式来拟合数据。随着训练数据集 m 的增加，$J_{train}(\theta)$ 的增加比较缓慢，且值比较小。而 $J_{train}(\theta)$ 刚开始时很大，随着训练数据集 m 的增加，它会开始缓慢下降，但其值还是比较大。最终 &lt;strong&gt;$J_{train}(\theta)$ 和 $J_{cv}(\theta)$ 的值相差比较大。&lt;/strong&gt;当发生高方差时，更多的训练数据样例会对算法性能有较大的改善，因为最终两条线会越来越接近，达到我们想要的效果**。&lt;/p&gt;
&lt;p&gt;&lt;img alt="contacts_structure" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_high_variance.png" /&gt;&lt;/p&gt;
&lt;p&gt;当需要改进学习算法时，可以画出学习曲线，以便判断算法是处在高偏差还是高方差问题。&lt;/p&gt;
&lt;h3 id="_7"&gt;决定下一步行动&lt;/h3&gt;
&lt;p&gt;回到本周开始的地方，我们可以总结那些行动可以解决哪些算法问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取更多的训练数据 -&amp;gt; 解决高方差问题 (High Variance, Over Fitting)&lt;/li&gt;
&lt;li&gt;减少输入的特征数量，避免出现过拟合 -&amp;gt; 解决高方差问题&lt;/li&gt;
&lt;li&gt;增加有价值的特征，即重新解读并理解训练数据 -&amp;gt; 解决高偏差问题 (High Bias, Under Fitting)&lt;/li&gt;
&lt;li&gt;增加多项式特征 -&amp;gt; 解决高偏差问题 (High Bias, Under Fitting)&lt;/li&gt;
&lt;li&gt;减小正则化参数 lambda -&amp;gt; 解决高偏差问题 (High Bias, Under Fitting)&lt;/li&gt;
&lt;li&gt;增大正则化参数 lambda -&amp;gt; 解决高方偏差问题 (High Variance, Over Fitting)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="_8"&gt;神经网络的过拟合&lt;/h3&gt;
&lt;p&gt;针对神经网络时，我们可以设计两套方案。第一套方案是使用小型的神经网络，即只有一个隐藏层，隐藏层的神经单元个数也比较少。第二套是使用大型的神经网络，可以有多个隐藏层，每个隐藏层有多个神经单元。&lt;/p&gt;
&lt;p&gt;一般来讲，方案一可能会导致高偏差，即欠拟合，但计算成本很低。而方案二可能会导致过拟合，且计算成本很高。针对欠拟合的情况，我们可以通过调整正则项参数 lambda 来解决。一般来讲，针对一个实际问题，选择一个大一点的神经网络，通过 lambda 纠正过拟合现象，这样的神经网络架构会比小型神经网络性能要好。&lt;/p&gt;
&lt;p&gt;另外一个问题，多个隐藏层好还是一个隐藏层好呢？针对不同的实际问题结论是不一样的。一个通用的方法是在不同隐藏层个数的神经网络里进行比较，通过计算交叉验证数据集的成本 $J_{cv}(\theta)$ 来判断哪个网络更适合我们的实际问题。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>神经网络（二）</title><link href="http://blog.kamidox.com/neural-networks-2.html" rel="alternate"></link><updated>2015-11-29T23:09:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-11-29:neural-networks-2.html</id><summary type="html">&lt;h2 id="_1"&gt;成本函数&lt;/h2&gt;
&lt;p&gt;与线性回归或逻辑回归类似，要使用神经网络对训练数据进行拟合时，需要有成本函数。这样只要针对训练数据，求解成本函数的最小值即可得出神经网络模型参数。&lt;/p&gt;
&lt;p&gt;针对 K 类分类问题的神经网络的输出层&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
h_\Theta(x) \in R^K; \left( h_\Theta(x) \right)_k = k^{th} output&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 K 是输出层的的单元个数，K &amp;gt;= 3。因为如果 K &amp;lt; 3 则可以直接用一个单元表示。其成本函数是：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\Theta) = - \frac{1}{m} \left[ \sum_{i=1}^m \sum_{k=1}^K y_k^{(i)} log(h_k^{(i)}) + (1 - y_k^{(i)}) log(1 - h_k^{(i)}) \right] + \frac{\lambda}{2m} \sum_{l=1}^{L-1} \sum_{i=1}^{s_l} \sum_{j=1}^{s_{l+1}} (\Theta_{ji}^{(l)})^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 $h_k^{(i)} = {h_\Theta(x^{(i)})}_k$ 是输出层的第 $k^{th}$ 个输出值。$L$ 是神经网络的层数，$s_l$ 是指第 $l$ 层的单元个数。公式的前半部分是未正则化的成本函数，后半部分是正则项，加起来就是正则化的成本公式。注意正则项部分求和时是从 $i=1$ 开始的，即我们不把偏置变量正则化。&lt;/p&gt;
&lt;div class="admonition warnning"&gt;
&lt;p class="admonition-title"&gt;MathJax 的缺陷&lt;/p&gt;
&lt;p&gt;这个公式我写了 20 分钟。它已经复杂到我不得不把 $h_k^{(i)}$ 独立写出来了，如果全部写一个公式里，公式将无法正确显示。不服的人可以试看看。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;怎么理解神经网络的成本公式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上不需要记住这么复杂的公式，但可以结合逻辑回归算法的成本公式来理解神经网络的成本公式。我们知道，神经网络中间层和输出层的每个神经元，都和其前面一层的神经网络的神经元构成逻辑回归关系。这个是神经网络的定义。而逻辑回归算法的成本函数是：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = -\frac{1}{m} \left[ \sum_{i=1}^m y^{(i)} log(h_\theta(x^{(i)})) + (1 - y^{(i)}) log(1 - h_\theta(x^{(i)})) \right]&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;跟神经网络成本函数对比，你会发现神经网络输出层有 K 个神经元。所以计算成本函数时，需要把输出层 K 个神经元的逻辑回归成本累加起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么理解正则项呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正则项有三个累加器，最前面那个是层累加器，典型地，对 3 层神经网络模型 $L=3$ ，正则项简化为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
reg = \frac{\lambda}{2m} \left( \sum_{i=1}^{s_1} \sum_{j=1}^{s_2} \left( \Theta_{ji}^{(1)} \right)^2 + \sum_{i=1}^{s_2} \sum_{j=1}^{s_3} \left( \Theta_{ji}^{(2)} \right)^2 \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;h3 id="_2"&gt;向后传播算法&lt;/h3&gt;
&lt;p&gt;我们把 $\delta_j^{(l)}$ ( $\delta$ 读作 delta ) 记作神经网络中第 $l$ 层，第 $j$ 个节点的误差。针对输出层，我们有&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\delta_j^{(L)} = a_j^{(L)} - y_j&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;按照向量化写法，我们得到&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\delta^{(L)} = a^{(L)} - y&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;此由可见，$\delta^{(L)}$ 是和 $y$ 一样维度的向量。针对第 $L-1$ 层，我们把误差定义为&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\delta^{(L-1)} = (\Theta^{(L-1)})^T \delta^{(L)} .* g&amp;rsquo;(z^{(L-1)})&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这个公式的前半部分 $ (\Theta^{(L-1)})^T \delta^{(L)}$ 样式很熟悉吧，就是线性回归算法的预测函数的样式。中间的 $.*$ 读作点乘，就是逐个元素相乘。$z^{(L-1)}=\Theta^{(L-2)} a^{(L-2)}$，$g&amp;rsquo;(z)$ 是 Sigmoid 函数的偏微分。&lt;/p&gt;
&lt;p&gt;可以从数学上证明 $g&amp;rsquo;(z^{(L-1)}) = a^{(L-1)} .* (1 - a^{(L-1)})$ 成立。证明过程可以参阅 &lt;a href="http://blog.kamidox.com/computation-rules-for-derivative.html"&gt;常用的微分运算法则&lt;/a&gt; 里关于 Sigmoid Function 偏微分的推导过程。这样我们算出输出层的误差，然后一层层往前推导，算出各层的误差，就是我们向后传播算法名字的由来。需要注意的是，不存在 $\delta^{(1)}$，因为神经网络的第 1 层是我们的输入项，不存在误差问题。&lt;/p&gt;
&lt;p&gt;从数学上可以证明，如果忽略正则项，即 $\lambda = 0$时&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\frac{\partial}{\partial \Theta_{ij}^{(l)}} J(\Theta) = a_j^{(l)} \delta_i^{(l+1)}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算微分项时，只需要计算 1, 2, &amp;hellip;, l+1 层的微分项&lt;/li&gt;
&lt;li&gt;微分项 $\frac{\partial}{\partial \Theta_{ij}^{(l)}} J(\Theta)$ 是个和 $\Theta^{(l)}$ 尺寸相同的矩阵&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对训练样本 ${ (x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), &amp;hellip; (x^{(m)}, y^{(m)}),}$，我们可以把向后传播算法用伪代码描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化误差累加值 set $\Delta_{ij}^{(l)} = 0$, for all $l, i, j$&lt;/li&gt;
&lt;li&gt;遍历所有的训练样本 for i = 1 to m&lt;ul&gt;
&lt;li&gt;设置输入层的激励为第 $i$ 个训练样本的输入值 set $a^{(1)} = x^{(i)}$&lt;/li&gt;
&lt;li&gt;使用向前传播算法 $a^{(l+1)} = g\left( a^{(l)} * \left( \Theta^{(l)} \right)^T \right)$，算出所有层的激励 $a^{(l)}$ for $l = 2, 3, &amp;hellip; , L$&lt;/li&gt;
&lt;li&gt;使用输出层的激励，计算输出层的误差 $\delta^{(L)} = a^{(L)} - y^{(i)}$&lt;/li&gt;
&lt;li&gt;使用反向扩散的方法 $\delta^{(L-1)} = (\Theta^{(L-1)})^T \delta^{(L)} .* g&amp;rsquo;(z^{(L-1)})$ 计算每一层的误差 $\delta^{(L-1)}, \delta^{(L-2)}, &amp;hellip;, \delta^{(2)}$。&lt;/li&gt;
&lt;li&gt;累加 $(x^{(i)}, y^{(i)})$ 训练样本的误差 $\Delta_{ij}^{(l)} = \Delta_{ij}^{(l)} + a_j^{(l)} \delta_i^{(l+1)}$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;endfor&lt;/li&gt;
&lt;li&gt;累加的值除以 m 即得到无正则化的微分项 $\frac{\Delta_{ij}^{(l)}}{m}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后一项可以用向量化的写法：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\Delta^{(l)} = \Delta^{(l)} + \delta^{(l+1)} \left( a^{(l)} \right)^T&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;br /&gt;
&lt;strong&gt;计算过程中，需要注意偏置单元。根据惯例，累加时不计算偏置单元。针对反向扩散公式 $\delta^{(L-1)} = (\Theta^{(L-1)})^T \delta^{(L)} .* g&amp;rsquo;(z^{(L-1)})$，需要特别注意矩阵运算时的维度需要匹配。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加入正则项后，我们有&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
D_{ij}^{(l)} = \frac{1}{m} \Delta_{ij}^{(l)} + \frac{\lambda}{m} \Theta_{ij}^{(l)}, if j \ne 0&lt;br /&gt;
$$&lt;br /&gt;
$$&lt;br /&gt;
D_{ij}^{(l)} = \frac{1}{m} \Delta_{ij}^{(l)}, if j = 0&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;从数学上可以证明&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\frac{\partial}{\partial \Theta_{ij}^{(l)}} J(\Theta) = D_{ij}^{(l)}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这样我们就算出来了神经网络模型的&lt;strong&gt;成本函数微分项&lt;/strong&gt;。有了成本函数和成本函数微分项，我们就可以使用梯度下降或其他高级算法来计算神经网络成本函数的最小值，从而求解神经网络中各层激励的参数。&lt;/p&gt;
&lt;p&gt;在具体实现的时候，使用向量化的实现可以大幅提高算法效率。具体可以参考 &lt;a href="http://deeplearning.stanford.edu/wiki/index.php/Neural_Network_Vectorization"&gt;Neural Network Vectorization&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="_3"&gt;实践中的向后传播算法&lt;/h2&gt;
&lt;h3 id="_4"&gt;参数折叠&lt;/h3&gt;
&lt;p&gt;在线性回归或逻辑回归算法里，我们的参数是向量，我们使用的 &lt;code&gt;fminunc&lt;/code&gt; 等函数也只接受向量作为参数。而神经网络算法里，参数是个矩阵，$\Theta^{(l)} \in R^{s_{l+1} \times s_l + 1}$。所以，在训练神经网络算法时，需要对参数进行折叠，即把矩阵转换为向量，而在使用时，可以再从向量里恢复矩阵数据。&lt;/p&gt;
&lt;p&gt;假设 Theta1 是 10x11 的矩阵，它是第一层的参数； Theta2 是 10x11 的矩阵，它是第二层的参数。可以使用下面的 matlab/octave 来转换：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;ThetaVec = [Theta1(:); Theta2(:)];
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在成本函数函数里，我们需要转换为矩阵进行计算：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Theta1 = reshape(ThetaVec(1:110), 10, 11);
Theta2 = reshape(ThetaVec(111:220), 10, 11);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同理，针对成本函数的微分项，$D^{(1)} \in R^{10x11}, D^{(2)} \in R^{10x11}$，我们的成本函数返回这个微分项时，也需要把矩阵转换为向量：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;DVec = [D1(:); D2(:)]
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_5"&gt;微分项检验&lt;/h3&gt;
&lt;p&gt;神经网络的微分项特别复杂，有时候一些小的错误可能会导致算法失败，这样就很难发现问题。这里介绍一个方法来验证微分项算法是否正确。我们使用的是微分的数值估算方法。&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\frac{d}{d\theta} J(\theta) \approx \frac{J(\theta + \varepsilon) + J(\theta - \varepsilon)}{2 \varepsilon}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这里只要 $\varepsilon$ 足够小，则可以近似地计算出微分项的值。实际计算时，我们一般取 $\varepsilon = 0.0001$ 。这样算出来的值和微分项算出来的值应该非常近似，用这个方法我们可以验证微分项计算是否准确。&lt;strong&gt;需要特别注意的是，在验证完微分项计算的正确性后，数值近似计算必须关闭掉。否则会使算法效率严重降低。&lt;/strong&gt;因为数值计算的成本是很高的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程时需要注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微分项检查实际上是一种纯数学的做法。主要是检查我们使用向后传播算法 (backpropagation) 方法算出来的微分和用数值计算算出来的微分是否相同。它适用于其他算法，如线性回归或逻辑回归算法。有几点需要特别注意。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于计算很费时间，实际检查时，$\theta$ 可以选小一点的矩阵，比如 3 x 5，而不需要使用真正的机器学习时的 theta。因为 $\theta$ 太大不但费时间，还不利于观察。&lt;/li&gt;
&lt;li&gt;实际计算时，$\theta$ 往往是个列向量。这个时候我们需要让 $\varepsilon$ 也是一个和 $\theta$ 维度相同的向量，当检查 $\theta(i)$ 元素的偏微分项时，让 $\varepsilon$ 的的第 i 项的值为 0.0001，其他项都为 0 。这样进行矩阵来进行数值微分计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_6"&gt;用随机数初始化参数&lt;/h3&gt;
&lt;p&gt;在进行线性回归和逻辑回归计算时，我们把参数全部初始化为零。但这个做法在神经网络里是不可行的，如果我们把参数全部初始化为零，那么隐藏层的神经单元的激励 $a_i^{(l)}$ 将是相同的，其误差 $\delta_i^{(l)}$ 也将是相同的，即我们计算的全部是相同的特征，这样神经网络就失去了其特征的覆盖度和丰富性。&lt;/p&gt;
&lt;p&gt;所以，我们需要把神经网络的每个参数 $\Theta_{ij}^{(l)}$ 初始化为 $[-\varepsilon, \varepsilon]$ 之间的一个随机数。例如：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Theta1 = &lt;span style="color: #AA22FF"&gt;rand&lt;/span&gt;(&lt;span style="color: #666666"&gt;10&lt;/span&gt;, &lt;span style="color: #666666"&gt;11&lt;/span&gt;) &lt;span style="color: #666666"&gt;.*&lt;/span&gt; (&lt;span style="color: #666666"&gt;2&lt;/span&gt; &lt;span style="color: #666666"&gt;.*&lt;/span&gt; INIT_VAREPSILON) &lt;span style="color: #666666"&gt;-&lt;/span&gt; INIT_VAREPSILON;
Theta2 = &lt;span style="color: #AA22FF"&gt;rand&lt;/span&gt;(&lt;span style="color: #666666"&gt;10&lt;/span&gt;, &lt;span style="color: #666666"&gt;11&lt;/span&gt;) &lt;span style="color: #666666"&gt;.*&lt;/span&gt; (&lt;span style="color: #666666"&gt;2&lt;/span&gt; &lt;span style="color: #666666"&gt;.*&lt;/span&gt; INIT_VAREPSILON) &lt;span style="color: #666666"&gt;-&lt;/span&gt; INIT_VAREPSILON;
Theta3 = &lt;span style="color: #AA22FF"&gt;rand&lt;/span&gt;(&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;11&lt;/span&gt;) &lt;span style="color: #666666"&gt;.*&lt;/span&gt; (&lt;span style="color: #666666"&gt;2&lt;/span&gt; &lt;span style="color: #666666"&gt;.*&lt;/span&gt; INIT_VAREPSILON) &lt;span style="color: #666666"&gt;-&lt;/span&gt; INIT_VAREPSILON;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;$\varepsilon$ 应该选择小一点，这样神经网络的学习最有效率。一个经验做法是&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\varepsilon^{(l)} = \frac{\sqrt{6}}{\sqrt{s_l} + \sqrt{s_{l+1}}}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$s_l, s_{l+1}$ 分别表示 $l$ 层和 $l+1$ 层的神经单元个数。即每层的参数范围根据这层的神经单元个数及下一层的神经单元个数。&lt;/p&gt;
&lt;h2 id="_7"&gt;总结&lt;/h2&gt;
&lt;p&gt;使用神经网络解决问题时，需要经过两个步骤。一是设计神经网络的架构；二是训练出对应的神经网络参数。&lt;/p&gt;
&lt;h3 id="_8"&gt;神经网络架构&lt;/h3&gt;
&lt;p&gt;在进行神经网络计算时，需要先进行神经网络的架构设计。架构设计时需要考虑以下三个事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入层的特征数量 (number of input unit)&lt;/li&gt;
&lt;li&gt;输出层的单元个数 (number of output unit) ，针对多类别的分类问题，可以把输出层设计成一个向量&lt;/li&gt;
&lt;li&gt;隐藏层的个数以及每个隐藏层的单元数目。一般来讲，隐藏层的个数越多越好，但会增加计算的工作量。另外，多个隐藏层的单元数目一般是相同的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="_9"&gt;训练神经网络&lt;/h3&gt;
&lt;p&gt;训练神经网络总共有六个步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照随机数对初始权重 (参数) 进行初始化&lt;/li&gt;
&lt;li&gt;实现向前传播算法，以便针对任何的输入 $x^{(i)}$ 都能算出相应的 $h_\Theta(x^{(i)})$&lt;/li&gt;
&lt;li&gt;实现神经网络成本函数 $J(\Theta)$ 来计算成本&lt;/li&gt;
&lt;li&gt;实现向后传播算法，计算成本函数针对每个参数的偏微分 $\frac{\partial}{\partial \Theta_{ij}^{(l)}} J(\Theta)$&lt;ul&gt;
&lt;li&gt;需要遍历每个训练样本，即有个从 1 到 m 的循环&lt;/li&gt;
&lt;li&gt;针对每个训练样本 $(x^{(i)}, y^{(i)})$ 执行向前传播算法和向后传播算法，以便算出 $l$ 层的激励 (Activations) $a^{(l)}$ 和误差 $\delta^{(l)}$&lt;/li&gt;
&lt;li&gt;需要针对神经网络的每层算出累计的误差值，这些层是 2, 3, &amp;hellip; , L&lt;/li&gt;
&lt;li&gt;最后，在循环外，算出成本函数的偏微分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用数值估计算法来验证神经网络成本函数的偏微分是否正确。验证通过后，关闭数值估计算法。&lt;/li&gt;
&lt;li&gt;使用梯度下降或其他优化过的高级算法来对成本函数 $J(\Theta)$ 进行最小化运算&lt;/li&gt;
&lt;/ul&gt;</summary><category term="machine-learning"></category></entry><entry><title>神经网络（一）</title><link href="http://blog.kamidox.com/neural-networks-1.html" rel="alternate"></link><updated>2015-11-25T22:59:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-11-25:neural-networks-1.html</id><summary type="html">&lt;h2 id="_1"&gt;动机&lt;/h2&gt;
&lt;p&gt;为什么我们需要神经网络？&lt;/p&gt;
&lt;p&gt;对非线性分类问题，当特征的个数很大的时候，计算量将会非常大。比如对有 100 个特征（$x_1, x_2, \cdots, x_100$）的问题，如果我们只算二阶多项多项式，我们将得到大概 5000 个特征 ($O(n^2)$)。而如果按照三阶多项式来模拟，将得到将近 300,000 个特征 ($O(n^3)$)。再比如，针对一个 100 x 100 分辨率的图片，我们假设每个象素点只用黑白来表示，那么将得到 100,000 个特征值。这个时候如果用二阶多项式来拟合，我们将得到 50,000,000,000 个特征值组合。这是非常巨大的计算量。&lt;/p&gt;
&lt;p&gt;显然，用线性回归和逻辑回归来解决这类问题是不现实的。&lt;/p&gt;
&lt;h2 id="_2"&gt;神经网络模型&lt;/h2&gt;
&lt;p&gt;神经网络模型是依照大脑的神经网络的结构建模的。即多个神经元构成一个层，这些神经元是输入，层的目标值为输出。一个神经网络包含多个层。神经元是神经网络中的运算单位。&lt;/p&gt;
&lt;h3 id="_3"&gt;神经元&lt;/h3&gt;
&lt;p&gt;神经元是神经网络中的最小运算单位，多个神经元构成一个层。神经网络依然使用逻辑回归算法里介绍的 Sigmoid Function 作为基本模型。&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
g(z) = \frac{1}{1 + e^{-z}} \\&lt;br /&gt;
z = \theta^T x \\&lt;br /&gt;
h_\theta(x) = \frac{1}{1 + e^{-\theta^T x}}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，$x$ 称作神经元的输入 (input wires or Dendrite)，是个列向量 $[x_1, x_2, &amp;hellip; x_n]$。$\theta$ 称为权重 (weights)，也可以按照逻辑回归算法里的叫法，称为参数 (parameters)。$h_\theta(x)$ 称为输出 (output wires or Axon)。这个是神经网络模型中的基本运算单元。&lt;/p&gt;
&lt;p&gt;类似逻辑回归，我们也会增加一个输入 $x_0=1$，在这里称作偏置单元 (bias unit)。&lt;/p&gt;
&lt;h3 id="_4"&gt;神经网络&lt;/h3&gt;
&lt;p&gt;神经网络可以划分成多个层，每个层有一定数量的神经元。其中第一层叫输入层，最后一层叫输出层，一个或多个中间层叫隐藏层。&lt;/p&gt;
&lt;p&gt;&lt;img alt="neural networks" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/neural_networks.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几个索引的含义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$a_i^{(j)}$: 表示第 j 层的第 i 个神经元 (unit i in layer j)&lt;br /&gt;
$\Theta^{(j)}$: 控制神经元网络中从第 j 层转化到第 j + 1 层的权重矩阵。这个矩阵里的元素经常写成 $\Theta_{ik}^{(j)}$ 其中 j 表示第 j 层，i 表示第 j 层神经元的单元索引值，k 表示第 j 层第 i 个神经元的输入项索引值。&lt;/p&gt;
&lt;p&gt;这段索引的描述很抽像。看一下上图的神经网络，他们的元素满足如下关系。从下面的关系中去正确地理解各个变量的索引值的含义。其中 $g(z) = \frac{1}{1 + e^{-z}}$ 就是 Sigmoid Function。&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
a_1^{(2)} = g(\Theta_{10}^{(1)} x_0 + \Theta_{11}^{(1)} x_1 + \Theta_{12}^{(1)} x_2 + \Theta_{13}^{(1)} x_3) \\&lt;br /&gt;
a_2^{(2)} = g(\Theta_{20}^{(1)} x_0 + \Theta_{21}^{(1)} x_1 + \Theta_{22}^{(1)} x_2 + \Theta_{23}^{(1)} x_3) \\&lt;br /&gt;
a_3^{(2)} = g(\Theta_{30}^{(1)} x_0 + \Theta_{31}^{(1)} x_1 + \Theta_{32}^{(1)} x_2 + \Theta_{33}^{(1)} x_3) \\&lt;br /&gt;
h_\Theta(x) = a_1^{(3)} = g(\Theta_{10}^{(2)} a_0 + \Theta_{11}^{(2)} a_1 + \Theta_{12}^{(2)} a_2 + \Theta_{13}^{(2)} a_3)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;假设 j 层有 $s_j$ 个单元，j + 1 层有 $s_{j+1}$ 个单元。那么 $\Theta^{(j)}$ 将是一个 $s_{j+1} \times (s_j + 1)$ 的矩阵。&lt;/p&gt;
&lt;h3 id="forward-propagation"&gt;向前传播 (Forward Propagation) 算法的向量化实现&lt;/h3&gt;
&lt;p&gt;针对上图的三层神经网络，其元素之前的关系按照向量化写法如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
let: z_1^{(2)} = \Theta_{10}^{(1)} x_0 + \Theta_{11}^{(1)} x_1 + \Theta_{12}^{(1)} x_2 + \Theta_{13}^{(1)} x_3 = \Theta^{(1)} x \\&lt;br /&gt;
\Rightarrow a_1^{(2)} = g\left( z_1^{(2)} \right) \\&lt;br /&gt;
a_2^{(2)} = g\left( z_2^{(2)} \right) \\&lt;br /&gt;
a_3^{(2)} = g\left( z_3^{(2)} \right) \\&lt;br /&gt;
\Rightarrow a^{(2)} = g\left( z^{(2)} \right) \\&lt;br /&gt;
z^{(3)} = \Theta^{(2)} a^{(2)} \\&lt;br /&gt;
\Rightarrow h_\Theta(x) = a^{(3)} = g\left( z^{(3)} \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;上述关系的本质上，就是从第二层开始，&lt;strong&gt;每个神经元，都把上一层的神经元当作输入，他们之间满足逻辑回归算法&lt;/strong&gt;。即从上一层的神经元可以计算出下一层的神经元。这也形象地称为向前传播算法。&lt;/p&gt;
&lt;p&gt;更一般的情况，假设待训练的数据集 $X$ 是 m x n 矩阵，记作 $X \in R^{m \times n}$，其中 m 是数据集个数，n 是输入的特征数，此处假设 $X$ 里已经加入了偏置单元 (bias unit)。假设隐藏层有 s2 个单元，$\Theta^{(1)}$ 为输入层到隐藏层的转换参数。则 $\Theta^{(1)} \in R^{s2 \times n}$。输出层有 s3 个单元，$\Theta^{(2)}$ 为隐藏层到输出层的转换参数。则 $\Theta^{(2)} \in R^{s3 \times (s2 + 1)}$。我们记 $a^{(2)}$ 为隐藏层，$a^{(3)}$ 为输出层，则：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
a^{(2)} = g\left( X * \left( \Theta^{(1)} \right)^T \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;算出后，给 $a^{(2)}$ 加上偏置单元。为了书写方便，此处我们仍然将加上偏置单元后的隐藏层记作 $a^{(2)}$。则：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
a^{(3)} = g\left( a^{(2)} * \left( \Theta^{(2)} \right)^T \right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这几个公式就是神经网络向量化运算的重要规则。其中 $g(z) = \frac{1}{1 + e^{-z}}$ 是 Sigmoid Function。熟悉矩阵运算的同学可以验证一下上述运算在矩阵维度上的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;神经网络通过学习来决定其特征&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单单从 $h_\Theta(x) = g\left(\Theta^{(2)} a^{(2)}\right)$ 式子来看，神经网络的输出就是由特征 $a_1^{(2)}, a_2^{(2)}, a_3^{(2)}$ 的逻辑回归模型表述的。但这里的每个特征 $a_1^{(2)}, a_2^{(2)}, a_3^{(2)}$ 都是分别由 $x_1, x_2, x_3$ 的逻辑回归模型学习出来的。这就是神经网络的精髓所在。&lt;/p&gt;
&lt;h2 id="_5"&gt;神经网络的应用实例&lt;/h2&gt;
&lt;h3 id="_6"&gt;运用神经网络来模拟逻辑运算&lt;/h3&gt;
&lt;p&gt;假设 $\Theta = [-30, 20, 20]$，&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
h_\Theta(x) = g(\Theta^T x) = g(-30 + 20x_1 + 20x_2)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$g(z)$ 是 Sigmoid Function，其图形近似于 S 形。假设 $x_1, x_2 \in [0, 1]$ 是逻辑值。当 $x_1 = 0, x_2 = 0$ 时，$h_\Theta(x) = g(-30) \approx 0$。同理可以写出下面的真值表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;x_1&lt;/th&gt;
&lt;th&gt;x_2&lt;/th&gt;
&lt;th&gt;h(x)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这样就模拟了逻辑 AND 的运算，即 h(x) = x1 AND x2。同理可以推算出当 $\Theta = [-10, 20, 20]$ 时，h(x) = x1 OR x2。还可以推断出当 $\Theta = [10, -20, -20]$ 时，h(x) = (NOT x1) AND (NOT x2)。当需要计算 x1 NXOR x2 时，可以用神经网络模型，即 x1 NXOR x2 = (x1 AND x2) OR ((NOT x1) AND (NOT x2))。我们把 x1, x2 当作输入，a1 = (x1 AND x2), a2 = (NOT x1) AND (NOT x2) 当作隐藏层，而最终的输出由 a1 OR a2 来计算得来了。这样我们就可以使用神经网络模拟复杂的逻辑运算。&lt;/p&gt;
&lt;h3 id="_7"&gt;运用神经网络来处理多类别的分类问题&lt;/h3&gt;
&lt;p&gt;上文介绍的神经网络只能输出 0, 1 二元问题。扩展到多个类别时，我们输出一个向量，比如针对最终结果是四种类别的问题时，输出 [1, 0, 0, 0] 表示第一种类别，输出 [0, 1, 0, 0] 表示是第二种类别，依此类推。&lt;/p&gt;
&lt;p&gt;问：为什么不用 1, 2, 3, 4 四个不同的值来表示四种类别，而要用一个四维的向量来表示？&lt;br /&gt;
答：从神经网络模拟逻辑运算的例子可以看出来，一个神经元可以输出只能是从 0 到 1 的之间的值，回忆逻辑回归算法里的描述，这个值表示的是出现 0 或 1 的概率，我们可以选择一个临界点，比如 0.5。当输出值大于等于 0.5 时判定为 1，当输出值小于 0.5 时判定为 0，一个神经元不能输出整其他整数值。逻辑回归就是用来解决分类问题的离散函数，而不是对值进行预测的连续函数。针对四个类别的分类问题时，我们可以把输出层神经元个数定为 4 个，这样这四个输出层神经元的值就构成了一个有四个元素的列向量。所以，我们使用四维的列向量来表示。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>正则化</title><link href="http://blog.kamidox.com/regularization.html" rel="alternate"></link><updated>2015-11-20T22:52:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-11-20:regularization.html</id><summary type="html">&lt;h2 id="_1"&gt;线性回归里的欠拟合和过拟合&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;欠拟合 (underfitting)&lt;br /&gt;
  也叫做高偏差 (high bias) 。使用的特征过少导致成本函数过高。模型不能很好地拟合训练数据。&lt;/li&gt;
&lt;li&gt;过拟合 (overfitting)&lt;br /&gt;
  也叫高方差 (high variance) 。使用多个特征建模的预测函数非常完美地拟合了训练数据，其成本函数的值接近于零，但对新的数据预测时效果很差。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;线性回归算法的欠拟合和过拟合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Linear Regression Overfit" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_linear_reg_overfit.png" /&gt;&lt;/p&gt;
&lt;p&gt;针对房价预测模型，左边是欠拟合的情况，右边是过拟合的情况。中间表示模型比较好的拟合了训练数据集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑回归算法的欠拟合和过拟合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Logistic Regression Overfit" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_logistic_reg_overfit.png" /&gt;&lt;/p&gt;
&lt;p&gt;针对分类算法，左边是欠拟合，右边是过拟合，中间的模型比较好地拟合了训练数据集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征太多，而训练样本数据太少，则很可能出现过拟合&lt;/strong&gt;。下面是一些解决过拟合问题的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少特征个数&lt;ul&gt;
&lt;li&gt;手动减少特征个数&lt;/li&gt;
&lt;li&gt;模型选择算法，比如主成份分析法 (PCA) 。主要原理就是把特征的重要性拿来排序，然后只选择前面几个权重比较大的特征，忽略排在后面的权重比较小的特征。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正则化&lt;ul&gt;
&lt;li&gt;保留所有的特征，减小特征的权重 $\theta_j$ 的值。确保所有的特征对预测值都有少量的贡献。&lt;/li&gt;
&lt;li&gt;当每个特征 $x_i$ 对预测值 $y$ 都有少量的贡献时，这样的模型可以良好地工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是正则化的目的，为了解决特征过多时的过拟合问题。&lt;/p&gt;
&lt;h2 id="_2"&gt;正则化&lt;/h2&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = \frac{1}{2m} \left[ \sum_{i=1}^m \left( h_\theta(x^{(i)}) - y^{(i)} \right)^2 \right] + \lambda \sum_{j=1}^n \theta_j^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 $\lambda$ 的值有两个目的，即要维持对训练样本的拟合，又避免对训练样本的过拟合。如果 $\lambda$ 太大，则能确保不出现过拟合，但可能会导致对现有训练样本出现欠拟合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么样从数学上理解正则化后的逻辑回归算法的成本函数解决了过拟合问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从数学角度来看，成本函数增加了一个正则项 $\lambda \sum_{j=1}^n \theta_j^2$ 后，成本函数不再唯一地与&lt;strong&gt;预测值与真实值的差距&lt;/strong&gt;决定，还和参数 $\theta$ 的大小有关。有了这个限制之后，要实现成本函数最小的目的，$\theta$ 就不能随便取值了，比如某个比较大的 $\theta$ 值可能会让预测值与真实值的差距 $\left( h_\theta(x^{(i)}) - y^{(i)} \right)^2$ 值很小，但会导致  $\theta_j^2$ 很大，最终的结果是成本函数太大。这样，通过调节参数 $\lambda$ 就可以控制正则项的权重。从而避免线性回归算法过拟合。&lt;/p&gt;
&lt;p&gt;利用正则化的成本函数，可以推导出参数迭代函数 (推导过程会用到一些微分运算法则)：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
\theta_j &amp;amp; = \theta_j - \alpha \frac{1}{m} \sum_{i=1}^m \left[ \left(\left(h(x^{(i)}) - y^{(i)}\right) x_j^{(i)}\right) + \frac{\lambda}{m} \theta_j \right] \\&lt;br /&gt;
&amp;amp; = \theta_j (1 - \alpha \frac{\lambda}{m}) - \alpha \frac{1}{m} \sum_{i=1}^m \left(\left(h(x^{(i)}) - y^{(i)}\right) x_j^{(i)}\right)&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$(1 - \alpha \frac{\lambda}{m})$ 因子在每次迭代时都将把 $\theta_j$ 收缩一点点。因为 $\alpha$ 和 $\lambda$ 是正数，而 m 是训练样例的个数，是个比较大的正整数。&lt;strong&gt;为什么要对 $\theta_j$ 进行收缩呢&lt;/strong&gt;？因为加入正则项的成本函数和 $\theta_j^2$ 成正比，所以迭代时需要不断地试图减小 $\theta_j$ 的值。&lt;/p&gt;
&lt;h2 id="_3"&gt;通用方程的正则化&lt;/h2&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta = (X^T X)^{-1} X^T y&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这是还没有正则化的通用方程，我们用它来快速求解线性回归算法。下面是正则化的通用方程：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta = (X^T X + \lambda Z)^{-1} X^T y&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，Z 是 (n + 1) x (n + 1) 矩阵&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
Z =&lt;br /&gt;
\begin{bmatrix}&lt;br /&gt;
0 \\&lt;br /&gt;
&amp;amp; 1 \\&lt;br /&gt;
&amp;amp; &amp;amp; 1 \\&lt;br /&gt;
&amp;amp; &amp;amp; &amp;amp; \ddots \\&lt;br /&gt;
&amp;amp; &amp;amp; &amp;amp; &amp;amp; 1&lt;br /&gt;
\end{bmatrix}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;正则化的通用方程实际上解决了两个问题。一个是确保不发生过拟合，另外一个也解决了 $X^T X$ 的奇异矩阵问题。当 m &amp;lt; n 时，$X^T X$ 将是一个奇异矩阵，使用 octave 里的 &lt;code&gt;pinv&lt;/code&gt; 函数我们可以求出近似逆矩阵的值，但如果在其他编程语言里，是没有办法求出奇异矩阵的逆矩阵的。而从数学上可以证明，加上 $\lambda Z$ 后，结果将是一个非奇异矩阵。&lt;/p&gt;
&lt;p&gt;通用方程的正则化公式推导过程极其复杂，过程从略。&lt;/p&gt;
&lt;h2 id="_4"&gt;逻辑回归成本函数的正则化&lt;/h2&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = -\frac{1}{m} \left[ \sum_{i=1}^m y^{(i)} log(h_\theta(x^{(i)})) + (1 - y^{(i)}) log(1 - h_\theta(x^{(i)})) \right] + \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;相应地，正则化后的参数迭代公式&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
\theta_j &amp;amp; = \theta_j - \alpha \frac\partial{\partial{\theta_j}}J(\theta) \\&lt;br /&gt;
&amp;amp; = \theta_j - \alpha \left[ \frac{1}{m} \sum_{i=1}^m \left( h_\theta(x^{(i)}) - y^{(i)} \right) x_j^{(i)} + \frac{\lambda}{m} \theta_j \right] \\&lt;br /&gt;
&amp;amp; = \theta_j (1 - \alpha \frac{\lambda}{m}) - \alpha \frac{1}{m} \sum_{i=1}^m \left(\left(h(x^{(i)}) - y^{(i)}\right) x_j^{(i)}\right)&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;需要注意的是，上式中 $j \geq 1$，因为 $\theta_0$ 没有参与正则化。另外需要留意，逻辑回归和线性回归的参数迭代算法看起来形式是一样的，即公式 (4) 和公式 (7) 形式一样，但其实他们的算法是不一样的，因为两个式子的预测函数 $h_\theta(x)$ 是不一样的。针对线性回归，$h_\theta(x) = \theta^T x$，而针对逻辑回归 $h_\theta(x) = \frac{1}{1 + e^{-\theta^T x}}$。&lt;/p&gt;
&lt;p&gt;根据正则化的，新的成本函数的参数迭代函数来实现 CostFunction，然后利用 octave 里的 &lt;code&gt;fminunc&lt;/code&gt; 函数来求解，这样可以达到最高的运算效率。因为 &lt;code&gt;fminunc&lt;/code&gt; 会使用优化过的梯度下降算法 Conjugate Gradient, BFGS, L-BFGS 等来提高运算效率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学到这里，你基本上可以使用线性回归逻辑回归解决一些现实问题了。我看到硅谷有大量的公司使用机器算法来构建伟大的产品，那些机器学习工程师在这些公司获得了很好的职业发展并且赚了不少钱。&amp;mdash; Andrew Ng&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老师除了教得好，还要会鼓励，让学生保持学习的热情和兴趣。学完三周，热情可能会被消耗得差不多了，特别是第一次接触这些复杂数学公式的同学，听了老师的这个鼓励，瞬间满血复活有没有。仿佛走上硅谷机器学习工程师的职业道路了~~，等一下，先别叫醒我，让我的梦想飞一会儿。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>逻辑回归算法</title><link href="http://blog.kamidox.com/logistic-regression.html" rel="alternate"></link><updated>2015-11-19T22:22:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-11-19:logistic-regression.html</id><summary type="html">&lt;h2 id="_1"&gt;分类问题及其表现形式&lt;/h2&gt;
&lt;h3 id="_2"&gt;为什么需要逻辑回归算法&lt;/h3&gt;
&lt;p&gt;比如要对一个图片进行分类，判断图片里是否包含汽车。包含汽车的预测值为 1 。不包含汽车的预测值为 0 。这种分类问题的值是离散的，如果用 linear regresstion 来作为分类问题的预测函数是不合理的。因为预测出来的数值可能远小于 0 或远大于 1。我们需要找出一个预测函数模型，使其值的输出在 [0, 1] 之间。然后我们选择一个基准值，比如 0.5 ，如果预测值算出来大于 0.5 就认为其预测值为 1，反之则其预测值为 0.&lt;/p&gt;
&lt;h3 id="_3"&gt;逻辑回归算法的预测函数&lt;/h3&gt;
&lt;p&gt;我们选择 $g(z) = \frac{1}{1 + e^{-z}}$ 来作为我们的预测函数。这个函数称为 &lt;a href="https://en.wikipedia.org/wiki/Sigmoid_function"&gt;Sigmoid Function&lt;/a&gt; 。它的图形如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="contacts_structure" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Logistic-curve.svg/320px-Logistic-curve.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出来，当 $z &amp;gt; 0$ 时，$g(z) &amp;gt; 0.5$ 。当 z 越来越大时，$g(z)$ 接无限接近于 1。当 $z &amp;lt; 0$ 时，$g(z) &amp;lt; 0.5$ 。当 z 越来越小时，$g(z)$ 接无限接近于 0。这正是我们想要的针对二元分类算法的预测函数。&lt;/p&gt;
&lt;p&gt;结合我们的线性回归函数的预测函数 $h_\theta(x) = \theta^T x$，则我们的逻辑回归模型的预测函数如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
h_\theta(x) = g(\theta^T x) = \frac{1}{1 + e^{-\theta^T x}}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解读逻辑回归预测函数的输出值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$h_\theta(x)$ 表示针对输入值 $x$ 以及参数 $\theta$ 的前提条件下，$y=1$ 的概率。用概率论的公式可以写成：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
h_\theta(x) = P(y=1 \vert x; \theta)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;上面的概率公式可以读成：&lt;strong&gt;在输入 $x$ 及参数 $\theta$ 条件下 $y=1$ 的概率&lt;/strong&gt;。由概率论的知识可以推导出，&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
P(y=1 \vert x; \theta) + P(y=0 \vert x; \theta) = 1&lt;br /&gt;
$$&lt;/p&gt;
&lt;h3 id="decision-boundary"&gt;判定边界 Decision Boundary&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;从逻辑回归公式说起&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逻辑回归预测函数由下面两个公式给出的：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
h_\theta(x) = g(\theta^T x)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
g(z) = \frac{1}{1 + e^{-z}}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;假定 $y=1$ 的判定条件是 $h_\theta(x) \geq 0.5$，$y=0$ 的判定条件是 $h_\theta(x) &amp;lt; 0.5$，则我们可以推导出 $y=1$ 的判定条件就是 $\theta^T x \geq 0$，$y=0$ 的判定条件就是 $\theta^T x &amp;lt; 0$。所以，$\theta^T x = 0$ 即是我们的判定边界。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判定边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假定我们有两个变量 $x_1, x_2$，其逻辑回归预测函数是 $h_\theta(x) = g(\theta_0 + \theta_1 x_1 + \theta_2 x_2)$。假设我们给定参数&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta = \begin{bmatrix} -3 \\ 1 \\ 1 \end{bmatrix}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;那么我们可以得到判定边界 $-3 + x_1 + x_2 = 0$，即 $x_1 + x_2 = 3$，如果以 $x_1$ 为横坐标，$x_2$ 为纵坐标，这个函数画出来就是一个通过 (0, 3) 和 (3, 0) 两个点的斜线。这条线就是我们的判定边界。&lt;/p&gt;
&lt;p&gt;&lt;img alt="contacts_structure" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_line_decision_boundary.png" /&gt;&lt;/p&gt;
&lt;p&gt;直线左下角为 $y=0$ ，直线右上解为 $y=1$ 。横坐标为 $x_1$，纵坐标为 $x_2$ 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非线性判定边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果预测函数是多项式 $h_\theta(x) = g(\theta_0 + \theta_1 x_1 + \theta_2 x_2 + \theta_3 x_1^2 + \theta_4 x_2^2)$，且给定&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta = \begin{bmatrix} -1 \\ 0 \\ 0 \\ 1 \\ 1 \end{bmatrix}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;则可以得到判定边界函数&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
x_1^2 + x_2^2 = 1&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;还是以 $x_1$ 为横坐标，$x_2$ 为纵坐标，则这是一个半径为 1 的圆。圆内部是 $y=0$ ，圆外部是 $y=1$。&lt;/p&gt;
&lt;p&gt;&lt;img alt="contacts_structure" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_circle_decision_boundary.png" /&gt;&lt;/p&gt;
&lt;p&gt;这是二阶多项式的情况，更一般的多阶多项式可以表达出更复杂的判定边界。&lt;/p&gt;
&lt;h2 id="_4"&gt;逻辑回归的成本函数&lt;/h2&gt;
&lt;p&gt;线性回归的成本函数是 $J(\theta) = \frac{1}{m} \sum_{i=1}^m \frac{1}{2} \left (h_\theta(x^{(i)}) - y^{(i)} \right)^2 $，如果我们按照线性回归的成本函数来计算逻辑回归的成本函数，那么我们最终会很可能会得到一个非凸函数 (non-convex function)，这样我们就无法通过梯度下降算法算出成本函数的最低值。&lt;/p&gt;
&lt;p&gt;为了让成本函数是个凸函数 (convex function)，以便容易求出成本函数的最小值，我们定义逻辑回归的成本函数如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
Cost(h_\theta(x), y) = \begin{cases}&lt;br /&gt;
    -log(h_\theta(x)), &amp;amp; \text{if $y$ = 1} \\&lt;br /&gt;
    -log(1 - h_\theta(x)), &amp;amp; \text{if $y$ = 0} \\&lt;br /&gt;
\end{cases}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成本函数的解读&lt;/strong&gt;&lt;br /&gt;
如果 $y = 1, h_\theta(x) = 1$，那么成本为 $Cost = 0$；如果 $y = 1, h_\theta(x) \rightarrow 0$，那么成本将是无穷大 $Cost \rightarrow \infty$。&lt;br /&gt;
如果 $y = 0, h_\theta(x) = 0$，那么成本为 $Cost = 0$；如果 $y = 0, h_\theta(x) \rightarrow 1$，那么成本将是无穷大 $Cost \rightarrow \infty$。&lt;/p&gt;
&lt;h4 id="_5"&gt;逻辑回归成本函数定义&lt;/h4&gt;
&lt;p&gt;由于 $y \in [0, 1]$ 的离散值，可以把两个成本函数合并起来：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = -\frac{1}{m} \left[ \sum_{i=1}^m y^{(i)} log(h_\theta(x^{(i)})) + (1 - y^{(i)}) log(1 - h_\theta(x^{(i)})) \right]&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;把 $y = 0, y = 1$ 两种情况代入上式，很容易可以验证成本函数合并的等价性。&lt;/p&gt;
&lt;h4 id="_6"&gt;梯度下降公式&lt;/h4&gt;
&lt;p&gt;我们依然使用梯度下降公式来对模型进行求解。根据梯度下降算法的定义，我们使用下面的公式来进行参数迭代：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_j := \theta_j - \alpha \dfrac{\partial}{\partial \theta_j}J(\theta)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这里的关键是求解成本函数的偏导数。在这之前，我们先求出 Sigmoid 函数的偏导数，以便后面可以利用上：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
\sigma(x)&amp;rsquo; &amp;amp;= \left(\frac{1}{1+e^{-x}}\right)&amp;rsquo; = \frac{-(1+e^{-x})&amp;rsquo;}{(1+e^{-x})^2} = \frac{-1&amp;rsquo;-(e^{-x})&amp;rsquo;}{(1+e^{-x})^2} \newline&lt;br /&gt;
&amp;amp;= \frac{0-(-x)&amp;rsquo;(e^{-x})}{(1+e^{-x})^2} = \frac{-(-1)(e^{-x})}{(1+e^{-x})^2} = \frac{e^{-x}}{(1+e^{-x})^2} \newline&lt;br /&gt;
&amp;amp;= \left(\frac{1}{1+e^{-x}}\right)\left(\frac{e^{-x}}{1+e^{-x}}\right) = \sigma(x)\left(\frac{+1-1 + e^{-x}}{1+e^{-x}}\right) \newline&lt;br /&gt;
&amp;amp;= \sigma(x)\left(\frac{1 + e^{-x}}{1+e^{-x}} - \frac{1}{1+e^{-x}}\right) \newline&lt;br /&gt;
&amp;amp;= \sigma(x)(1 - \sigma(x))&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;推导出来的这个公式将在下面用上，现在我们可以来计算成本函数的偏导数了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="成本函数偏导数" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/ml_partial_derivative.png" /&gt;&lt;/p&gt;
&lt;p&gt;最终得到梯度下降算法进行参数迭代的公式如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_j = \theta_j - \alpha \frac{1}{m} \sum_{i=1}^m \left( h_\theta(x^{(i)}) - y^{(i)} \right) x_j^{(i)}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这个公式的形式和线性回归算法的参数迭代公式是一样的。当然，由于这里 $h_\theta(x) = \frac{1}{1 + e^{-\theta^T x}}$，而线性回归算法里 $h_\theta(x) = \theta^T x$。所以，两者的形式一样，但数值计算完全不同。&lt;/p&gt;
&lt;h4 id="_7"&gt;算法优化&lt;/h4&gt;
&lt;p&gt;梯度下降算法的效率是比较低，优化的梯度下降算法有 Conjugate Gradient, BFGS, L-BFGS 等。这些算法比较复杂，实现这些算法是数值计算专家的工作，一般工程人员只需要大概知道这些算法是怎么优化的以及怎么使用这些算法即可。&lt;/p&gt;
&lt;p&gt;octave 里提供了 &lt;code&gt;fminunc&lt;/code&gt; 函数，可以查阅文档来学习函数用法，从而学会使用优化过的梯度下降算法，以提高计算效率。&lt;/p&gt;
&lt;h4 id="_8"&gt;多元分类算法&lt;/h4&gt;
&lt;p&gt;除了二元分类算法外，还有多元分类问题，比如需要给邮件打标签，则可能有多个标签需要考虑。这个时候需要使用 one-vs-all (one-vs-rest) 的方法。即把要分类的一种类别和其他所有类别区分开来的，这样就把多元分类问题转化为二元分类问题，这样就可以使用上文总结的所有二元分类问题的算法。&lt;/p&gt;
&lt;p&gt;针对 $y = i$，求解针对 i 的预测函数 $h_\theta^{(i)}(x)$。如果有 n 个类别，则需要求解 n 个预测函数。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>使用 pandas 玩转股票数据</title><link href="http://blog.kamidox.com/using-pandas-for-stock-data.html" rel="alternate"></link><updated>2015-11-17T23:16:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-11-17:using-pandas-for-stock-data.html</id><summary type="html">&lt;p&gt;pandas 是数据分析的瑞士军刀。我们今天使用 pandas 来玩一下股票数据，看看能从数据里得到哪些有意思的信息。&lt;/p&gt;
&lt;h2 id="pandas"&gt;pandas 教程&lt;/h2&gt;
&lt;p&gt;如果你熟悉 Python 的话，官网上的 &lt;a href="http://pandas.pydata.org/pandas-docs/stable/10min.html"&gt;10 Minutes to pandas&lt;/a&gt; 可以让你在短时间内了解 pandas 能干什么事以及是怎么干的。针对每个主题，都可以横向查到大量的资料和例子。&lt;/p&gt;
&lt;p&gt;如果你 Python 不熟，但又想用 pandas 玩转数据分析的话，&lt;a href="http://book.douban.com/subject/25717197/"&gt;Python for Data Analysis&lt;/a&gt; 是本不错的书。书里作者使用美国新生儿的名字得出了一些很有意思的结论。还分析了 movielen 的电影评分数据。熟悉 SQL 的同学应该对这些分析会深有感触，相信这些人用 SQL 写出过这些分析过程类似的代码。这本书的缺点是有点啰嗦，如果你熟悉 Python 又想快速学习的话，看第二章就够了。但这本书很适合不熟悉 Python 的人，书的最后一章还附了 Python 的教程，即如果只玩 pandas 的话，掌握这些 Python 知识就够了，真够贴心。而且本书的作者就是 pandas 的作者。&lt;/p&gt;
&lt;p&gt;另外补充一点，最好使用 &lt;a href="http://ipython.org"&gt;ipython&lt;/a&gt; 环境来玩转数据分析。特别是 ipython notebook ，熟悉快捷键后，用起来会很顺手。本文玩转的股票数据就是使用 ipython notebook。&lt;/p&gt;
&lt;h2 id="_1"&gt;股票数据下载&lt;/h2&gt;
&lt;p&gt;搜索 ghancn 可以免费下载 2009 年之前的 5 分钟数据和 1 分钟数据。坦白讲，数据质量不高，里面有不少错误。但不影响我们玩这些数据。数据是以年为单位分不同的文件夹保存的。&lt;/p&gt;
&lt;p&gt;我们先看一下某个股票的数据长什么样：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;pandas&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;as&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;pd&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;numpy&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;as&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;np&lt;/span&gt;


names &lt;span style="color: #666666"&gt;=&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;#39;date&amp;#39;&lt;/span&gt;,
         &lt;span style="color: #BB4444"&gt;&amp;#39;time&amp;#39;&lt;/span&gt;,
         &lt;span style="color: #BB4444"&gt;&amp;#39;opening_price&amp;#39;&lt;/span&gt;,
         &lt;span style="color: #BB4444"&gt;&amp;#39;ceiling_price&amp;#39;&lt;/span&gt;,
         &lt;span style="color: #BB4444"&gt;&amp;#39;floor_price&amp;#39;&lt;/span&gt;,
         &lt;span style="color: #BB4444"&gt;&amp;#39;closing_price&amp;#39;&lt;/span&gt;,
         &lt;span style="color: #BB4444"&gt;&amp;#39;volume&amp;#39;&lt;/span&gt;,
         &lt;span style="color: #BB4444"&gt;&amp;#39;amount&amp;#39;&lt;/span&gt;]
&lt;span style="color: #008800; font-style: italic"&gt;# 读取数据时，我们以日期为索引，并解析成日期格式&lt;/span&gt;
raw &lt;span style="color: #666666"&gt;=&lt;/span&gt; pd&lt;span style="color: #666666"&gt;.&lt;/span&gt;read_csv(&lt;span style="color: #BB4444"&gt;&amp;#39;raw/2008/SH600690.csv&amp;#39;&lt;/span&gt;, names&lt;span style="color: #666666"&gt;=&lt;/span&gt;names, header&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;, index_col&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;date&amp;#39;&lt;/span&gt;, parse_dates&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
raw&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;             time  opening_price  ceiling_price  floor_price  closing_price   volume    amount
date
2008-01-02  09:35          22.50          22.63        22.50          22.51   2042.50   4604723
2008-01-02  09:40          22.51          22.51        22.29          22.37   1545.17   3460503
2008-01-02  09:45          22.39          22.62        22.38          22.62   1744.76   3921443
2008-01-02  09:50          22.60          23.00        22.60          22.95   5339.00   12225939
2008-01-02  09:55          22.98          23.20        22.89          23.20   12577.73  28947824
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;转化为日交易数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们使用 2007 年和 2008 年的数据来作为示例。因为我们更关心是一些长期的趋势，分钟级别的交易数据太细了，我们转换为日数据。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# 股票涨跌幅检查，不能超过 10% ，过滤掉一些不合法的数据&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;_valid_price&lt;/span&gt;(g):
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; (((g&lt;span style="color: #666666"&gt;.&lt;/span&gt;max() &lt;span style="color: #666666"&gt;-&lt;/span&gt; g&lt;span style="color: #666666"&gt;.&lt;/span&gt;min()) &lt;span style="color: #666666"&gt;/&lt;/span&gt; g&lt;span style="color: #666666"&gt;.&lt;/span&gt;min()) &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color: #666666"&gt;0.223&lt;/span&gt;)&lt;span style="color: #666666"&gt;.&lt;/span&gt;all()

&lt;span style="color: #008800; font-style: italic"&gt;# 按照日期分组&lt;/span&gt;
days &lt;span style="color: #666666"&gt;=&lt;/span&gt; raw&lt;span style="color: #666666"&gt;.&lt;/span&gt;groupby(level&lt;span style="color: #666666"&gt;=0&lt;/span&gt;)&lt;span style="color: #666666"&gt;.&lt;/span&gt;agg(
    {&lt;span style="color: #BB4444"&gt;&amp;#39;opening_price&amp;#39;&lt;/span&gt;: &lt;span style="color: #AA22FF; font-weight: bold"&gt;lambda&lt;/span&gt; g: _valid_price(g) &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; g[&lt;span style="color: #666666"&gt;0&lt;/span&gt;] &lt;span style="color: #AA22FF; font-weight: bold"&gt;or&lt;/span&gt; &lt;span style="color: #666666"&gt;0&lt;/span&gt;,
     &lt;span style="color: #BB4444"&gt;&amp;#39;ceiling_price&amp;#39;&lt;/span&gt;: &lt;span style="color: #AA22FF; font-weight: bold"&gt;lambda&lt;/span&gt; g: _valid_price(g) &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; np&lt;span style="color: #666666"&gt;.&lt;/span&gt;max(g) &lt;span style="color: #AA22FF; font-weight: bold"&gt;or&lt;/span&gt; &lt;span style="color: #666666"&gt;0&lt;/span&gt;,
     &lt;span style="color: #BB4444"&gt;&amp;#39;floor_price&amp;#39;&lt;/span&gt;: &lt;span style="color: #AA22FF; font-weight: bold"&gt;lambda&lt;/span&gt; g: _valid_price(g) &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; np&lt;span style="color: #666666"&gt;.&lt;/span&gt;min(g) &lt;span style="color: #AA22FF; font-weight: bold"&gt;or&lt;/span&gt; &lt;span style="color: #666666"&gt;0&lt;/span&gt;,
     &lt;span style="color: #BB4444"&gt;&amp;#39;closing_price&amp;#39;&lt;/span&gt;: &lt;span style="color: #AA22FF; font-weight: bold"&gt;lambda&lt;/span&gt; g: _valid_price(g) &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; g[&lt;span style="color: #666666"&gt;-1&lt;/span&gt;] &lt;span style="color: #AA22FF; font-weight: bold"&gt;or&lt;/span&gt; &lt;span style="color: #666666"&gt;0&lt;/span&gt;,
     &lt;span style="color: #BB4444"&gt;&amp;#39;volume&amp;#39;&lt;/span&gt;: &lt;span style="color: #BB4444"&gt;&amp;#39;sum&amp;#39;&lt;/span&gt;,
     &lt;span style="color: #BB4444"&gt;&amp;#39;amount&amp;#39;&lt;/span&gt;: &lt;span style="color: #BB4444"&gt;&amp;#39;sum&amp;#39;&lt;/span&gt;})
days&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;            floor_price opening_price   ceiling_price   volume      amount      closing_price
date
2008-01-02  22.29       22.50           24.50           200809.34   476179680   24.03
2008-01-03  23.81       24.03           25.20           166037.98   406906304   24.54
2008-01-04  23.68       24.53           24.76           149078.64   358418560   24.17
2008-01-07  23.75       24.03           24.75           93950.43    227289136   24.38
2008-01-08  23.49       24.38           24.38           149056.24   355752416   23.53
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里只是为了玩这些数据，如果你真的需要股票日数据，雅虎财经网站上有质量非常高的日交易数据可供下载。&lt;/p&gt;
&lt;p&gt;按照上述方法，可以把一个股票几年的数据合并起来，生成一个包含所有年份的历史日交易数据。具体可以参阅 &lt;a href="https://github.com/kamidox/stock-data/blob/master/stock.py"&gt;stock.py&lt;/a&gt; 里的 &lt;code&gt;minutes_to_days_batch&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h2 id="_2"&gt;股票波动率&lt;/h2&gt;
&lt;p&gt;什么股票是好股票？要回答这个问题，先要把最简单的问题说清楚。炒股就是&lt;strong&gt;低买高卖，实现获利&lt;/strong&gt;。那么好股票的标准就是在你的持股周期内，波动最大的股票。这很好理解吧，波动最大，我们才有可能在相对低点买入，在相对高点卖出，获利最大。&lt;/p&gt;
&lt;p&gt;在一定的时间周期内，衡量股票波动的指标定义为 最高价/最低价。以我们表格中的数据，就是 ceiling_price/floor_price。这个比率最大的股票就是好股票。关于时间周期，这个和炒股策略有关。有些人喜欢做短线，可能就持股几天，或一两周。有些人习惯做长线，可能持股几个月甚至几年。也有些人本来打算做短线，做着做着变成长线，再做着做着，变成了股东。&lt;/p&gt;
&lt;p&gt;为了简单起见，我们拿波动周期为 30 个自然日来计算，即如果某个股票停牌，那么他的价格就一直没有变化，则波动为 0。&lt;br /&gt;
这里，我们直接使用 600690 这个股票来作为示例。我们直接读取已经合并过日交易的数据。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;qdhr &lt;span style="color: #666666"&gt;=&lt;/span&gt; pd&lt;span style="color: #666666"&gt;.&lt;/span&gt;read_csv(&lt;span style="color: #BB4444"&gt;&amp;#39;test-data/SH600690.csv&amp;#39;&lt;/span&gt;, index_col&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;date&amp;#39;&lt;/span&gt;, parse_dates&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
qdhr&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;                floor_price     opening_price   ceiling_price   volume      amount      closing_price
date
2007-01-04      9.28            9.30            10.14           259264.75   254734000   9.80
2007-01-05      9.53            9.70            10.15           171169.97   170154432   9.90
2007-01-08      9.93            9.93            10.78           159340.58   164954896   10.60
2007-01-09      10.08           10.68           11.15           227163.31   246309216   10.55
2007-01-10      10.26           10.49           11.13           232858.18   246221520   11.10
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们发现数据中间有空洞，即周末和停牌时间里是没有数据的。我们把这些数据填充完整，我们看看 pandas 如何处理 missing data 。&lt;/p&gt;
&lt;h3 id="_3"&gt;填充数据&lt;/h3&gt;
&lt;p&gt;我们先生成一段连续的日期数据作为索引：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# 填充数据：生成日期索引&lt;/span&gt;
l &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;len&lt;/span&gt;(qdhr)
start &lt;span style="color: #666666"&gt;=&lt;/span&gt; qdhr&lt;span style="color: #666666"&gt;.&lt;/span&gt;iloc[&lt;span style="color: #666666"&gt;0&lt;/span&gt;:&lt;span style="color: #666666"&gt;1&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;index&lt;span style="color: #666666"&gt;.&lt;/span&gt;tolist()[&lt;span style="color: #666666"&gt;0&lt;/span&gt;]
end &lt;span style="color: #666666"&gt;=&lt;/span&gt; qdhr&lt;span style="color: #666666"&gt;.&lt;/span&gt;iloc[l &lt;span style="color: #666666"&gt;-&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;: l]&lt;span style="color: #666666"&gt;.&lt;/span&gt;index&lt;span style="color: #666666"&gt;.&lt;/span&gt;tolist()[&lt;span style="color: #666666"&gt;0&lt;/span&gt;]
idx &lt;span style="color: #666666"&gt;=&lt;/span&gt; pd&lt;span style="color: #666666"&gt;.&lt;/span&gt;date_range(start&lt;span style="color: #666666"&gt;=&lt;/span&gt;start, end&lt;span style="color: #666666"&gt;=&lt;/span&gt;end)
idx
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;DatetimeIndex([&amp;#39;2007-01-04&amp;#39;, &amp;#39;2007-01-05&amp;#39;, &amp;#39;2007-01-06&amp;#39;, &amp;#39;2007-01-07&amp;#39;,
               &amp;#39;2007-01-08&amp;#39;, &amp;#39;2007-01-09&amp;#39;, &amp;#39;2007-01-10&amp;#39;, &amp;#39;2007-01-11&amp;#39;,
               &amp;#39;2007-01-12&amp;#39;, &amp;#39;2007-01-13&amp;#39;,
               ...
               &amp;#39;2008-12-22&amp;#39;, &amp;#39;2008-12-23&amp;#39;, &amp;#39;2008-12-24&amp;#39;, &amp;#39;2008-12-25&amp;#39;,
               &amp;#39;2008-12-26&amp;#39;, &amp;#39;2008-12-27&amp;#39;, &amp;#39;2008-12-28&amp;#39;, &amp;#39;2008-12-29&amp;#39;,
               &amp;#39;2008-12-30&amp;#39;, &amp;#39;2008-12-31&amp;#39;],
               dtype=&amp;#39;datetime64[ns]&amp;#39;, length=728, freq=&amp;#39;D&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着使用 &lt;code&gt;reindex&lt;/code&gt; 函数缺失的数据被全。填充股票数据时有个要求，我们把缺失的价格数据用前一个交易日的数据来填充，但交易量需要填充为 0。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;data &lt;span style="color: #666666"&gt;=&lt;/span&gt; qdhr&lt;span style="color: #666666"&gt;.&lt;/span&gt;reindex(idx)
zvalues &lt;span style="color: #666666"&gt;=&lt;/span&gt; data&lt;span style="color: #666666"&gt;.&lt;/span&gt;loc[&lt;span style="color: #666666"&gt;~&lt;/span&gt;(data&lt;span style="color: #666666"&gt;.&lt;/span&gt;volume &lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color: #666666"&gt;0&lt;/span&gt;)]&lt;span style="color: #666666"&gt;.&lt;/span&gt;loc[:, [&lt;span style="color: #BB4444"&gt;&amp;#39;volume&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;amount&amp;#39;&lt;/span&gt;]]
data&lt;span style="color: #666666"&gt;.&lt;/span&gt;update(zvalues&lt;span style="color: #666666"&gt;.&lt;/span&gt;fillna(&lt;span style="color: #666666"&gt;0&lt;/span&gt;))
data&lt;span style="color: #666666"&gt;.&lt;/span&gt;fillna(method&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;ffill&amp;#39;&lt;/span&gt;, inplace&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
data&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;            floor_price opening_price   ceiling_price   volume      amount      closing_price
2007-01-04  9.28        9.30            10.14           259264.75   254734000   9.8
2007-01-05  9.53        9.70            10.15           171169.97   170154432   9.9
2007-01-06  9.53        9.70            10.15           0.00        0           9.9
2007-01-07  9.53        9.70            10.15           0.00        0           9.9
2007-01-08  9.93        9.93            10.78           159340.58   164954896   10.6
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以看到，06， 07 两天的数据被正确地填充了。&lt;/p&gt;
&lt;h3 id="_4"&gt;分组计算&lt;/h3&gt;
&lt;p&gt;我们需要计算 30 个自然日里的股票平均波动周期。这样，我们必须以 30 天为单位，对所有的历史数据进行分组。然后逐个分组计算其波动率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成分组索引&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# 定义产生分组索引的函数，比如我们要计算的周期是 20 天，则按照日期，20 个交易日一组&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;gen_item_group_index&lt;/span&gt;(total, group_len):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot; generate an item group index array&lt;/span&gt;

&lt;span style="color: #BB4444; font-style: italic"&gt;    suppose total = 10, unitlen = 2, then we will return array [0 0 1 1 2 2 3 3 4 4]&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    group_count &lt;span style="color: #666666"&gt;=&lt;/span&gt; total &lt;span style="color: #666666"&gt;/&lt;/span&gt; group_len
    group_index &lt;span style="color: #666666"&gt;=&lt;/span&gt; np&lt;span style="color: #666666"&gt;.&lt;/span&gt;arange(total)
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; i &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;range&lt;/span&gt;(group_count):
        group_index[i &lt;span style="color: #666666"&gt;*&lt;/span&gt; group_len: (i &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;) &lt;span style="color: #666666"&gt;*&lt;/span&gt; group_len] &lt;span style="color: #666666"&gt;=&lt;/span&gt; i
    group_index[(i &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;) &lt;span style="color: #666666"&gt;*&lt;/span&gt; group_len : total] &lt;span style="color: #666666"&gt;=&lt;/span&gt; i &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; group_index&lt;span style="color: #666666"&gt;.&lt;/span&gt;tolist()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;In [&lt;span style="color: #666666"&gt;7&lt;/span&gt;]: gen_item_group_index(&lt;span style="color: #666666"&gt;10&lt;/span&gt;, &lt;span style="color: #666666"&gt;3&lt;/span&gt;)
Out [&lt;span style="color: #666666"&gt;7&lt;/span&gt;]: [&lt;span style="color: #666666"&gt;0&lt;/span&gt;, &lt;span style="color: #666666"&gt;0&lt;/span&gt;, &lt;span style="color: #666666"&gt;0&lt;/span&gt;, &lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;2&lt;/span&gt;, &lt;span style="color: #666666"&gt;2&lt;/span&gt;, &lt;span style="color: #666666"&gt;2&lt;/span&gt;, &lt;span style="color: #666666"&gt;3&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;根据分组索引来分组&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;period &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #666666"&gt;30&lt;/span&gt;

group_index &lt;span style="color: #666666"&gt;=&lt;/span&gt; gen_item_group_index(&lt;span style="color: #AA22FF"&gt;len&lt;/span&gt;(data), period)
&lt;span style="color: #008800; font-style: italic"&gt;# 把分组索引数据添加到股票数据里&lt;/span&gt;
data[&lt;span style="color: #BB4444"&gt;&amp;#39;group_index&amp;#39;&lt;/span&gt;] &lt;span style="color: #666666"&gt;=&lt;/span&gt; group_index
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;len&lt;/span&gt;(data)
data&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()&lt;span style="color: #666666"&gt;.&lt;/span&gt;append(data&lt;span style="color: #666666"&gt;.&lt;/span&gt;tail())
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们看一下添加了分组索引后的数据最前面 5 个和最后 5 个数据，注意 &lt;code&gt;group_index&lt;/code&gt; 的值。我们接下来就是根据这个值进行分组。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;            floor_price opening_price   ceiling_price   volume      amount      closing_price   group_index
2007-01-04  9.28        9.30            10.14           259264.75   254734000   9.80            0
2007-01-05  9.53        9.70            10.15           171169.97   170154432   9.90            0
2007-01-06  9.53        9.70            10.15           0.00        0           9.90            0
2007-01-07  9.53        9.70            10.15           0.00        0           9.90            0
2007-01-08  9.93        9.93            10.78           159340.58   164954896   10.60           0
2008-12-27  8.97        9.15            9.23            0.00        0           9.08            24
2008-12-28  8.97        9.15            9.23            0.00        0           9.08            24
2008-12-29  8.73        9.04            9.15            38576.07    34625144    9.11            24
2008-12-30  8.95        9.14            9.14            62983.38    56876600    8.96            24
2008-12-31  8.95        9.00            9.11            32829.30    29620508    8.99            24
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;分组计算最高价和最低价&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# 针对下跌的波动，我们把最高价设置为负数。什么是下跌的波动？就是先出现最高价，再出现最低价&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;_ceiling_price&lt;/span&gt;(g):
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; g&lt;span style="color: #666666"&gt;.&lt;/span&gt;idxmin() &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt; g&lt;span style="color: #666666"&gt;.&lt;/span&gt;idxmax() &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; np&lt;span style="color: #666666"&gt;.&lt;/span&gt;max(g) &lt;span style="color: #AA22FF; font-weight: bold"&gt;or&lt;/span&gt; (&lt;span style="color: #666666"&gt;-&lt;/span&gt;np&lt;span style="color: #666666"&gt;.&lt;/span&gt;max(g))


&lt;span style="color: #008800; font-style: italic"&gt;# 根据索引分组计算&lt;/span&gt;
group &lt;span style="color: #666666"&gt;=&lt;/span&gt; data&lt;span style="color: #666666"&gt;.&lt;/span&gt;groupby(&lt;span style="color: #BB4444"&gt;&amp;#39;group_index&amp;#39;&lt;/span&gt;)&lt;span style="color: #666666"&gt;.&lt;/span&gt;agg({
                                        &lt;span style="color: #BB4444"&gt;&amp;#39;volume&amp;#39;&lt;/span&gt;: &lt;span style="color: #BB4444"&gt;&amp;#39;sum&amp;#39;&lt;/span&gt;,
                                        &lt;span style="color: #BB4444"&gt;&amp;#39;floor_price&amp;#39;&lt;/span&gt;: &lt;span style="color: #BB4444"&gt;&amp;#39;min&amp;#39;&lt;/span&gt;,
                                        &lt;span style="color: #BB4444"&gt;&amp;#39;ceiling_price&amp;#39;&lt;/span&gt;: _ceiling_price})
group&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;                volume      ceiling_price   floor_price
group_index
0               1271711.00  22.33           16.21
1               1831018.01  24.75           18.98
2               2038944.01  -27.20          20.08
3               477219.16   23.49           21.40
4               203932.07   -22.48          20.10
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;给每个分组添加起始日期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时我们看到某个周期内下跌了很多，或上涨了很多，我们想知道是什么时候发生的，所以需要给每个分组添加起始日期。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# 添加每个分组的起始日期&lt;/span&gt;
date_col &lt;span style="color: #666666"&gt;=&lt;/span&gt; pd&lt;span style="color: #666666"&gt;.&lt;/span&gt;DataFrame({&lt;span style="color: #BB4444"&gt;&amp;quot;group_index&amp;quot;&lt;/span&gt;: group_index, &lt;span style="color: #BB4444"&gt;&amp;quot;date&amp;quot;&lt;/span&gt;: idx})
group[&lt;span style="color: #BB4444"&gt;&amp;#39;date&amp;#39;&lt;/span&gt;] &lt;span style="color: #666666"&gt;=&lt;/span&gt; date_col&lt;span style="color: #666666"&gt;.&lt;/span&gt;groupby(&lt;span style="color: #BB4444"&gt;&amp;#39;group_index&amp;#39;&lt;/span&gt;)&lt;span style="color: #666666"&gt;.&lt;/span&gt;agg(&lt;span style="color: #BB4444"&gt;&amp;#39;first&amp;#39;&lt;/span&gt;)
group&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;idx 是我们在上面代码里生成的连续的日期索引数据。添加日期数据后的样子：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;                volume      ceiling_price   floor_price     date
group_index
0               4634226.68  -12.38          9.02            2007-01-04
1               3499001.47  11.64           8.80            2007-02-03
2               6061972.34  12.79           9.41            2007-03-05
3               6086797.19  15.50           12.00           2007-04-04
4               5687407.73  17.15           13.49           2007-05-04
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;添加波动率&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# 添加我们的波动指标 股票波动系数 = 最高价/最低价&lt;/span&gt;
group[&lt;span style="color: #BB4444"&gt;&amp;#39;ripples_radio&amp;#39;&lt;/span&gt;] &lt;span style="color: #666666"&gt;=&lt;/span&gt; group&lt;span style="color: #666666"&gt;.&lt;/span&gt;ceiling_price &lt;span style="color: #666666"&gt;/&lt;/span&gt; group&lt;span style="color: #666666"&gt;.&lt;/span&gt;floor_price
group&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;                volume          ceiling_price   floor_price     date            ripples_radio
group_index
0               4634226.68      -12.38          9.02            2007-01-04      -1.372506
1               3499001.47      11.64           8.80            2007-02-03      1.322727
2               6061972.34      12.79           9.41            2007-03-05      1.359192
3               6086797.19      15.50           12.00           2007-04-04      1.291667
4               5687407.73      17.15           13.49           2007-05-04      1.271312
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照波动率排序，可以看到某段时间内波动最大的一些时间段。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# 降序排列。我们把分组的起始日期，交易量总和都列出来，也可以观察一下交易量和股票波动比的关系&lt;/span&gt;
ripples &lt;span style="color: #666666"&gt;=&lt;/span&gt; group&lt;span style="color: #666666"&gt;.&lt;/span&gt;sort_values(&lt;span style="color: #BB4444"&gt;&amp;#39;ripples_radio&amp;#39;&lt;/span&gt;, ascending&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
ripples&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;            volume          ceiling_price   floor_price     date            ripples_radio
group_index
101         4352881.31      14.85           9.18            2008-04-21      1.617647
90          5703121.25      18.89           11.85           2007-05-27      1.594093
92          4545365.71      23.96           16.42           2007-07-26      1.459196
85          4126972.83      12.38           8.58            2006-12-28      1.442890
84          2952951.46      9.20            6.40            2006-11-28      1.437500
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从数据可以看出来，波动最大的在 30 个自然日内上涨了 61.76%。发生在 2008-04-21 开始的 30 天内。&lt;/p&gt;
&lt;p&gt;当然，我们也可以计算前 10 大上涨波动的平均值。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;ripples&lt;span style="color: #666666"&gt;.&lt;/span&gt;head(&lt;span style="color: #666666"&gt;10&lt;/span&gt;)&lt;span style="color: #666666"&gt;.&lt;/span&gt;ripples_radio&lt;span style="color: #666666"&gt;.&lt;/span&gt;mean()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;1.3657990069195818
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以计算前 10 大下跌波动的平均值。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;ripples&lt;span style="color: #666666"&gt;.&lt;/span&gt;tail(&lt;span style="color: #666666"&gt;10&lt;/span&gt;)&lt;span style="color: #666666"&gt;.&lt;/span&gt;ripples_radio&lt;span style="color: #666666"&gt;.&lt;/span&gt;mean()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;-1.4124407127785106
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看来下跌的平均值比上涨的还大呀。&lt;/p&gt;
&lt;p&gt;我们针对每个股票都使用上述方法计算其平均波动，这样我们就可以从一系列股票里找出那些波动最大的股票了。当然，上涨波动越大，下跌波动也越大，正所谓风险和机遇并存嘛。具体可参阅 &lt;a href="https://github.com/kamidox/stock-data/blob/master/stock.py"&gt;stock.py&lt;/a&gt; 里的 &lt;code&gt;stock_ripples_batch&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h2 id="_5"&gt;其他玩法&lt;/h2&gt;
&lt;h3 id="_6"&gt;计算涨跌幅&lt;/h3&gt;
&lt;p&gt;我们注意到原始数据里没有涨跌幅的数据。涨跌幅定义为今日收盘价减去昨日收盘价。我们换个股票，取出原始数据。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;data &lt;span style="color: #666666"&gt;=&lt;/span&gt; pd&lt;span style="color: #666666"&gt;.&lt;/span&gt;read_csv(&lt;span style="color: #BB4444"&gt;&amp;#39;test-data/SZ000565.csv&amp;#39;&lt;/span&gt;, index_col&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;date&amp;#39;&lt;/span&gt;, parse_dates&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
data&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;            floor_price     opening_price   ceiling_price   volume      amount          closing_price
date
2007-01-04  4.16            4.22            4.27            17877.88    7477370.52      4.19
2007-01-05  4.15            4.16            4.27            10857.66    4588246.02      4.24
2007-01-08  4.27            4.27            4.45            30770.01    13467986.00     4.44
2007-01-09  4.42            4.48            4.54            26276.89    11726492.00     4.45
2007-01-10  4.36            4.45            4.90            80840.76    37866240.01     4.90
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;利用 &lt;code&gt;diff&lt;/code&gt; 函数快速计算涨跌幅。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;rise &lt;span style="color: #666666"&gt;=&lt;/span&gt; data&lt;span style="color: #666666"&gt;.&lt;/span&gt;closing_price&lt;span style="color: #666666"&gt;.&lt;/span&gt;diff()
data[&lt;span style="color: #BB4444"&gt;&amp;#39;rise&amp;#39;&lt;/span&gt;] &lt;span style="color: #666666"&gt;=&lt;/span&gt; rise
data&lt;span style="color: #666666"&gt;.&lt;/span&gt;head()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    floor_price opening_price   ceiling_price   volume  amount  closing_price   rise
date
2007-01-04  4.16    4.22    4.27    17877.88    7477370.52  4.19    NaN
2007-01-05  4.15    4.16    4.27    10857.66    4588246.02  4.24    0.05
2007-01-08  4.27    4.27    4.45    30770.01    13467986.00 4.44    0.20
2007-01-09  4.42    4.48    4.54    26276.89    11726492.00 4.45    0.01
2007-01-10  4.36    4.45    4.90    80840.76    37866240.01 4.90    0.45
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意到第一条记录的涨跌幅为 &lt;code&gt;NaN&lt;/code&gt;，因为第一条记录的昨日是没有数据的。感兴趣的同学可以再计算一下涨跌百分比，其定义为当日的涨跌幅除以昨日的收盘价。&lt;/p&gt;
&lt;h3 id="_7"&gt;计算指定时间点之前的一段时间内波动最大的股票&lt;/h3&gt;
&lt;p&gt;有时我们关心某个时间点之前的一段时间变化最剧烈的股票。比如最近一周涨幅最大的，最近一周跌幅最大的，或者最近一个月交易量变化最大的等等。&lt;/p&gt;
&lt;p&gt;我们看一下 000565 这个股票在 2008-12-31 之前 30 个自然日里的波动率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选定数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里涉及到用日期对数据进行分片的技术，我们需要选择指定日期及之前一段时间内的数据。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;end_date &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;2008-12-31&amp;#39;&lt;/span&gt;
period &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #666666"&gt;30&lt;/span&gt;

end_date &lt;span style="color: #666666"&gt;=&lt;/span&gt; pd&lt;span style="color: #666666"&gt;.&lt;/span&gt;Timestamp(end_date)
start_date &lt;span style="color: #666666"&gt;=&lt;/span&gt; end_date &lt;span style="color: #666666"&gt;-&lt;/span&gt; pd&lt;span style="color: #666666"&gt;.&lt;/span&gt;Timedelta(days&lt;span style="color: #666666"&gt;=&lt;/span&gt;period)

data &lt;span style="color: #666666"&gt;=&lt;/span&gt; pd&lt;span style="color: #666666"&gt;.&lt;/span&gt;read_csv(&lt;span style="color: #BB4444"&gt;&amp;#39;test-data/SZ000565.csv&amp;#39;&lt;/span&gt;, index_col&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;date&amp;#39;&lt;/span&gt;, parse_dates&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
data &lt;span style="color: #666666"&gt;=&lt;/span&gt; data&lt;span style="color: #666666"&gt;.&lt;/span&gt;loc[start_date:end_date]
data
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;            floor_price     opening_price   ceiling_price   volume          amount          closing_price
date
2008-12-01  7.40            7.58            7.90            41747.12        3.214610e+07    7.88
2008-12-02  7.55            7.56            8.38            74552.15        6.029661e+07    8.32
2008-12-03  8.40            8.40            8.93            85361.64        7.420082e+07    8.82
2008-12-04  8.42            8.88            9.08            110410.46       9.740610e+07    8.50
2008-12-05  8.33            8.40            9.35            126479.91       1.133572e+08    9.35
2008-12-08  9.35            9.40            9.99            149491.39       1.436038e+08    9.69
2008-12-09  9.10            9.73            9.73            89871.90        8.405230e+07    9.15
2008-12-10  9.09            9.11            9.55            70036.94        6.571389e+07    9.46
2008-12-11  9.06            9.40            9.47            57735.24        5.328468e+07    9.06
2008-12-12  8.15            8.80            9.00            59210.49        5.038026e+07    8.29
2008-12-15  8.30            8.33            8.72            41758.27        3.534860e+07    8.50
2008-12-16  8.02            8.48            8.60            38808.62        3.220561e+07    8.60
2008-12-17  8.58            8.67            8.89            46993.48        4.114008e+07    8.65
2008-12-18  8.50            8.62            8.81            34061.97        2.965074e+07    8.78
2008-12-19  8.79            8.79            9.39            70327.47        6.435001e+07    9.18
2008-12-22  8.95            9.19            9.39            50195.75        4.592311e+07    9.11
2008-12-23  8.20            9.17            9.17            75732.72        6.507140e+07    8.20
2008-12-24  7.59            8.03            8.18            61498.16        4.823624e+07    7.82
2008-12-25  7.40            7.90            7.93            34791.00        2.672370e+07    7.52
2008-12-29  6.96            7.50            7.55            31694.04        2.274100e+07    7.26
2008-12-30  7.11            7.29            7.48            25533.01        1.865500e+07    7.15
2008-12-31  6.94            7.16            7.25            22324.32        1.577828e+07    6.95
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;选出数据后，计算波动率就简单了。我们按照老办法，上涨的波动率为正数，下跌的波动率为负数。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# 计算波动值&lt;/span&gt;
_ripple_radio &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;lambda&lt;/span&gt; data: data&lt;span style="color: #666666"&gt;.&lt;/span&gt;ceiling_price&lt;span style="color: #666666"&gt;.&lt;/span&gt;max() &lt;span style="color: #666666"&gt;/&lt;/span&gt; data&lt;span style="color: #666666"&gt;.&lt;/span&gt;floor_price&lt;span style="color: #666666"&gt;.&lt;/span&gt;min()
ripple_radio &lt;span style="color: #666666"&gt;=&lt;/span&gt; data&lt;span style="color: #666666"&gt;.&lt;/span&gt;floor_price&lt;span style="color: #666666"&gt;.&lt;/span&gt;idxmin() &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt; data&lt;span style="color: #666666"&gt;.&lt;/span&gt;ceiling_price&lt;span style="color: #666666"&gt;.&lt;/span&gt;idxmax() &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; _ripple_radio(data) &lt;span style="color: #AA22FF; font-weight: bold"&gt;or&lt;/span&gt; &lt;span style="color: #666666"&gt;-&lt;/span&gt;_ripple_radio(data)
ripple_radio
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;-1.4394812680115274
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，遍历所有的股票，计算其指定日期之前的一段时间的波动值，选出波动最大的股票，即是我们关注的股票。比如，经历股票大跌，我们判断会反弹，我们想抢反弹，抢哪个股票呢？答案是抢大跌中下跌最多的，因为下跌最多的股票往往反弹也最多。这部分代码可参阅 &lt;a href="https://github.com/kamidox/stock-data/blob/master/stock.py"&gt;stock.py&lt;/a&gt; 里的 &lt;code&gt;recent_ripples&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h2 id="pandas_1"&gt;为什么要用 pandas 玩转股票数据&lt;/h2&gt;
&lt;p&gt;答案应该已经比较明显了，虽然很多数据股票软件里都有。但一些高级的数据筛选方式其实这些股票软件都不支持的。最后，需要补充一句，大家都是成年人，文章里的任何策略是个人的思路，不构成投资建议啊，后果自负啊。&lt;/p&gt;
&lt;p&gt;最最后，感兴趣的可以看一下 &lt;a href="https://github.com/kamidox/stock-data/blob/master/stock.ipynb"&gt;stock.ipynb&lt;/a&gt;，这个是本文在 ipython notebook 环境下的所有代码。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>怎样发现新需求</title><link href="http://blog.kamidox.com/howto-discovery-requirements.html" rel="alternate"></link><updated>2015-01-12T23:24:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-11-12:howto-discovery-requirements.html</id><summary type="html">&lt;p&gt;我一直很好奇人们是怎么样发现需求，从而开创一个新事业？我观察到了两类情况，一是发现了一个新的未来会有巨大增长的需求；二是相同的需求，但发现了满足这种需求的成本更低，效率更高的方法。问题来了，人们是怎么发现这些潜在的新需求和满足需求的新方法的呢？&lt;/p&gt;
&lt;p&gt;2007 年 iPhone 横空出世，2010 年，随着 Android 手机的出现和逐渐流行，隐约感觉到智能手机不会再像 2004 年的 WinCE/Pocket PC 那样温水煮青蛙了。时间拨回 2010 年，这样的时间当口，在这些新的巨大增长点面前，能做些什么呢？&lt;/p&gt;
&lt;h2 id="_1"&gt;积极参与新事物，发现问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;当发现未来可能会有巨大增长的新机会时，坚决地抓住先机，参与进去&lt;/strong&gt;。参与的原因是，坐在那想如果能想到好的点子，基本上都被想光了。想想那些巨头有专业的智囊团队在研究趋势和策略。那些市场容量太大的点子，巨头一旦参与进来，就很容易被干掉。只有那些巨头们暂时还关注不到的小问题，才可能成为一些小团队的真实需求。虽然目前解决的是小问题，但因为发展趋势，未来可能变成在解决一个大问题。这个时候巨头要么自己做，要么收购。如果如果评估下来，收购的成本比自己做还低，你可能就被收购了。&lt;/p&gt;
&lt;p&gt;当智能手机流行后，手机上的 App 必然会井喷，参与 App 的开发和运营，越早越好。你参与进去了，你就会发现这是个未经开垦的处女地。到处都是坑，到处都是问题，开发成本奇高无比，开发人员稀缺，运营策略非常原始。这里的每个问题都可以是一个潜在的需求，都可能在短期内出现巨大的增长。比如，我开发了一个 App ，需要统计 App 的用户增长和活跃情况，怎么办？需要自己在程序里埋点，还要自己开发个服务器，把用户的使用情况上传到自己的服务器上查看。太麻烦啦！！再细一想，不对呀，这是刚需啊，所有人都这么做不是太累了。所以友盟出现了，经过不足两年的发展，8000 万美刀被阿里收购了。再比如，开发人员难找，可以办个培训班呀。2010 年到 2014 年这四年间，搞 Android 培训的公司都发展得不错。再如 Android 开发遇到设备碎片化问题，适配不同的版本和不同的设备，简直是吐血的节奏。有问题就有机会，所以有公司就提供手机 App 的兼容性测试，开发一系列自动测试，自动抓 LOG ，自动生成测试报告的工具链，购买市场上几乎所有的主流手机。本来这个事情所有公司都要做一遍，可能投入上百万都不见得有效果，而使用他们的服务，几千块，甚至几百块就可以把自己 App 的兼容性问题都测出来。&lt;/p&gt;
&lt;p&gt;重点是，这些问题作为一个旁观者是发现不了的。当然不排除一些善长思考的人，理想因果关系后，能发现这些需求。但更多的人只有积极参与，才能发现问题。&lt;strong&gt;我们参与进去，就能发现小问题，这些小问题如果没有现成的解决方案，又是个共性的问题的话，这可能就是个机会。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="_2"&gt;问题即是机会&lt;/h2&gt;
&lt;p&gt;上述案例里，早期参与 App 开发的人和团队几乎都碰到过这些问题。可是最终能把问题转化为需求，把需求开发成产品，把产品做出口碑，需要付出艰巨的劳动。但实际上大部分人在第一阶段，即把问题转化为需求都做不到，而是把问题转化为抱怨了。为什么有些人能把问题转化为需求，从而开创一个新事业，而有些人只把问题转化为抱怨呢？一个原因是忙，这是个浮躁的社会，我们只想吃现成的，当遇到一个需要较大工作量才能解决的问题时，我们往往选择绕过问题。从而失去了深入思考的机会。二是少数真发现需求，且有能力通过技术手段解决这个需求的人，可能由于各种各样的原因没有重视。从而失去了开创一个新事业的机会。有一个笑话，说的是有一个机会，一万个人看到了，一千个人决定抓住这个机会，一百个人真正行动了，十个人把东西做出来了，最终只有一个人把东西做好，从而开创了一个新事业。这笑话虽然烂大街了，但说的还是真实情况。&lt;/p&gt;
&lt;h2 id="_3"&gt;真假需求&lt;/h2&gt;
&lt;p&gt;有时候，我们发现的是一些假的需求。当智能 App 逐渐流行，在手机上看新闻应该是个刚需吧。如果你把这个当需求，开发一个新闻阅读软件，可能会死得很惨。新闻阅读类应用的本质是内容，在 App 上看新闻和在电脑上看新闻的区别只是渠道不同，本质是人们对新闻的丰富性和实时性的要求。如果是中小公司，没有媒体内容背景，基本上做一个死一个。这个案例里，有个例外是头条新闻，他们解决内容的问题比较有意思，一是通过网络爬虫去抓取各大公司的新闻，推送给客户，从而解决了内容问题。二是利用机器学习，大数据计算，推荐个性化的阅读内容，所以这是个越用越聪明，越用越了解你的喜好的新闻阅读器。&lt;/p&gt;
&lt;p&gt;对于假需求，最近一堆 O2O 创业公司的死亡就是活生生的例子，有上门洗车的，有上门做饭的。曹政在他微信上说了个段子，每个人都有一个强烈的需求，就是不用干活，天天有钱赚。哪位过来满足一下啊。&lt;/p&gt;
&lt;h2 id="_4"&gt;活在当下&lt;/h2&gt;
&lt;p&gt;马后炮总是一件很轻松的事，像我等一事无成的人都可以指点江山，激扬文字，粪土当年巨头。知乎上有个很有意思的问题，中国互联网二十年来，你错过了哪些机会？实际上，错过了，就不是你的机会。&lt;/p&gt;
&lt;p&gt;站在当下，什么行业可能在未来十年井喷发展？我们能做什么？这是一个很有意思的问题，值得持续思考。&lt;/p&gt;
&lt;p&gt;IOT 喊了很久了，什么时候会暴发？以什么样的方式暴发？如果只是坐在那想，估计是想不出来，那么多大佬们天天在琢磨这事呢。如果参与进去，就会发现，很多传统的做硬件和嵌入式开发的公司，在服务器开发上都是很弱的，这个时候就有一些 IOT 公有云平台出现了。再比如，现在的并行计算和计算机运算能力的提升，使人工智能在技术上成为可能。实际上，人工智能在 60 年代就已经在喊会改变世界了，喊了近半个世纪，现在的硬件条件刚刚好具备了，作为个人或小团队，我们能在这里做些什么呢？&lt;/p&gt;
&lt;p&gt;我也没有答案。但我不去想，我在想办法参与这些事情，在过程中去发现小问题以及这些小问题的系统性解决方案。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>OS X El Capitan 初体验</title><link href="http://blog.kamidox.com/osx-el-capitan.html" rel="alternate"></link><updated>2015-10-10T23:23:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-10-10:osx-el-capitan.html</id><summary type="html">&lt;p&gt;&lt;img alt="os x el capitan" src="http://help.apple.com/osx-elcapitan/from-yosemite/Art/S0406_ElCapBkg.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;怕折腾，不敢偿鲜。所以等到最近才升级 OS X El Capitan，总体变化不大。写几点感受，给要升级的同学参考。&lt;/p&gt;
&lt;h3 id="_1"&gt;中文苹方字体&lt;/h3&gt;
&lt;p&gt;这个应该是日常使用中感觉到的最大的变化，整体中文字体显示效果确实好了很多。还记得当年微软设计出微软雅黑字体的感觉么？就是这个感觉。&lt;/p&gt;
&lt;h3 id="mission-control"&gt;Mission Control&lt;/h3&gt;
&lt;p&gt;相同应用程序的窗口不再层叠，互相遮挡了。个人最直观的体验是，打开多个 sublime 时，要切换到其中一个确实比 Yosemite 要方便很多。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://help.apple.com/osx-elcapitan/from-yosemite/#/mission-control"&gt;点击这里&lt;/a&gt;可以体验一下。&lt;/p&gt;
&lt;h3 id="split-view"&gt;Split View&lt;/h3&gt;
&lt;p&gt;分屏是 OS X El Capitan 苹果官方放第一个介绍的功能，具体就是按住绿色的最大化按钮不动，然后把一个窗口放在全屏的一侧，之后再选择另外一个应用程序放在另外一侧。实现全屏下两个应用并排显示。&lt;/p&gt;
&lt;p&gt;这个功能在有些场景下确实比较方便。iTerm 这种应用程序本身就支持这种分屏模式(Command + D)，用来提高效率。&lt;a href="http://help.apple.com/osx-elcapitan/from-yosemite/#/split-view"&gt;点击这里&lt;/a&gt;可以体验一下。&lt;/p&gt;
&lt;h3 id="_2"&gt;找鼠标&lt;/h3&gt;
&lt;p&gt;快速摇一摇鼠标会变大，帮助快速找到鼠标的位置。这个感觉还是人性化的。&lt;/p&gt;
&lt;h3 id="_3"&gt;词典&lt;/h3&gt;
&lt;p&gt;Mac 上最方便的词典还是自带的 Dictionary，三个手指在触摸板上对着单词点击即可出现释义。升级后的 Dictionary 中文翻译明显变好了，也更全了。&lt;/p&gt;
&lt;h3 id="_4"&gt;静音单个网页&lt;/h3&gt;
&lt;p&gt;你一边听着歌，一边浏览网页，某个网页突然播放一段声音打扰到你听音乐了有没有？不急，Safari 9.0 提供了静音单个网页的功能。当然，这个功能只需要把 Safari 升级到 9.0 就能体验，不一定要升级整个系统。&lt;/p&gt;
&lt;h3 id="_5"&gt;性能&lt;/h3&gt;
&lt;p&gt;苹果把这个版本作为性能提升的重要版本，数字说出来确实很漂亮，但坦白讲用起来没有感觉，反而开机后，输入用户名密码后登录到桌面感觉变慢了。&lt;/p&gt;
&lt;h3 id="_6"&gt;兼容性&lt;/h3&gt;
&lt;p&gt;兼容性不错，没遇到什么大问题。唯一的问题是升级完运行 octave 时提示 Java 1.6 没安装。按照提示到苹果官网下载安装一下就好了。&lt;/p&gt;
&lt;h3 id="_7"&gt;参考信息&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.apple.com/osx/whats-new/"&gt;whats-new&lt;/a&gt; 是官方的介绍文档，基本包含了所有的新功能介绍。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://help.apple.com/osx-elcapitan/from-yosemite/"&gt;osx-elcapitan-from-yosemite&lt;/a&gt; 是官方做的几大功能变化点的动画演示，升级前可以看看。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.macx.cn/archiver/tid-2164216.html"&gt;OS X 10.11 El Capitan 安装注意事项 与 USB启动盘的制作&lt;/a&gt;升级前一定要看一下，特别是关于 USB 启动盘，以及升级前做权限修复和磁盘修复的内容，为了顺利安全升级，这些事情还是要做的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外一个可能有用的参考信息是，整个升级包 6GB 多，我下载了大概 3 个小时。升级过程大概用了 30 分钟。就这样子。&lt;/p&gt;</summary><category term="tools"></category></entry><entry><title>一个加速访问 StackOverflow 的方法</title><link href="http://blog.kamidox.com/local-cdn.html" rel="alternate"></link><updated>2015-10-01T23:36:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-10-01:local-cdn.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;安全预警&lt;/strong&gt;：最近的 xcode ghost 事件让大家的安全意识提高了不少。本文介绍的方法可能存在一些安全隐患。当然，解决方案也是有的，就是可以把本地 cdn 加速的文件和官网发布的正式版本做 md5 检验，这样确保本地文件没有被修改。由于目前还没有实现 md5 检验。请确保你自己清楚你在做什么，否则可能导致你的计算机被恶意的人植入后门。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_1"&gt;问题&lt;/h2&gt;
&lt;p&gt;访问 StackOverflow 时奇慢无比有没有？其实原因不是因为 StackOverflow 不能访问，而是因为 StackOverflow 网站引用了 Google 的 CDN 加速服务器来下载 jqeury 脚本。&lt;a href="http://www.zhihu.com/question/22909851"&gt;知乎上有个话题&lt;/a&gt;讨论了这个问题。&lt;/p&gt;
&lt;h2 id="_2"&gt;解决方案&lt;/h2&gt;
&lt;p&gt;在本地搭建一个 web 服务器，然后下载好 jquery 脚本，放在本地 web 服务器上。再修改 hosts 文件，把 ajax.googleapis.com 重定向到本地 127.0.0.1 。这样浏览器就会从本地下载脚本，而不再从 ajax.googleapis.com 下载了。&lt;/p&gt;
&lt;h2 id="_3"&gt;详细步骤&lt;/h2&gt;
&lt;p&gt;这里将介绍详细的安装和配置过程，需要注意的是所有的目录和命令以我的 mac 下的环境为例。如果你用的是不同的版本或不同的操作系统，根据你的情况完成相应的配置即可。&lt;/p&gt;
&lt;h3 id="nginx"&gt;安装 nginx 服务器&lt;/h3&gt;
&lt;p&gt;网上一堆教程，搜索一下就可以成功安装，需要注意的是两点。一是需要设置 nginx 开机启动。二是需要修改 nginx 运行权限，因为我们要在 80 端口提供服务，80 端口需要 root 权限才可以。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置 nginx 开机启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把下面文件内容保存到 &lt;code&gt;/Library/LaunchAgents/com.nginx.plist&lt;/code&gt;。然后运行 &lt;code&gt;launchctl load -w /Library/LaunchAgents/com.nginx.plist&lt;/code&gt;。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;plist&lt;/span&gt; &lt;span style="color: #BB4444"&gt;version=&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;
  &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;Label&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;homebrew.mxcl.nginx&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;RunAtLoad&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;true/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;KeepAlive&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;false/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;ProgramArguments&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;/usr/local/opt/nginx/bin/nginx&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;-g&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;daemon off;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;WorkingDirectory&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;/usr/local&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;StandardErrorPath&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;/usr/local/var/log/nginx/error.log&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;StandardOutPath&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;/usr/local/var/log/nginx/access.log&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
  &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;修改 nginx 运行权限&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;sudo chown root:admin /usr/local/Cellar/nginx/1.8.0/bin/nginx
sudo chmod u+s /usr/local/Cellar/nginx/1.8.0/bin/nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="nginx_1"&gt;配置 nginx 服务器&lt;/h3&gt;
&lt;p&gt;配置 nginx 服务器主要分两步。一是生成 ssl 证书，用来提供 https 服务。二是下载 local-cdn 到本地，将配置 nginx 指向这个本地目录以便提供 cdn 服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成 ssl 证书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们本地 cdn 还需要支持 ssl，所以需要做一个自签名的证书。下面命令会在 &lt;code&gt;/usr/local/etc/nginx/ssl/&lt;/code&gt; 目录下生成一个自签名的证书。这个证书后面会用到。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;mkdir -p /usr/local/etc/nginx/ssl
openssl req -x509 -nodes -days &lt;span style="color: #666666"&gt;3650&lt;/span&gt; -newkey rsa:2048 -keyout /usr/local/etc/nginx/ssl/nginx.key -out /usr/local/etc/nginx/ssl/nginx.crt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;配置 nginx 服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把 local-cdn 下载到本地，比如放在 &lt;code&gt;/Users/kamidox/work/local-cdn&lt;/code&gt;。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;cd&lt;/span&gt; /Users/kamidox/work/
git clone https://github.com/kamidox/local-cdn.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后配置 nginx 添加这个目录当作内容目录。我们把下面内容保存到 &lt;code&gt;/usr/local/etc/nginx/servers/local-cdn.conf&lt;/code&gt;。注意配置中用到了我们上面生成的证书。另外，nginx 默认会 include &lt;code&gt;/usr/local/etc/nginx/servers/&lt;/code&gt; 下的所有配置文件。如果你修改过 nginx 的默认配置，根据你自己的情况配置即可。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;server {
    listen 80 default_server;
    listen [::]:80 default_server ipv6only=on;
    charset utf-8;

    listen 443 ssl;

    server_name localhost;
    ssl_certificate /usr/local/etc/nginx/ssl/nginx.crt;
    ssl_certificate_key /usr/local/etc/nginx/ssl/nginx.key;

    location / {
        root /Users/kamidox/work/local-cdn/;
        index index.html index.htm;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="contribution"&gt;Contribution&lt;/h2&gt;
&lt;p&gt;欢迎大家&lt;a href="https://github.com/kamidox/local-cdn"&gt;提 pull request&lt;/a&gt;，一起完善科学文明的上网环境。&lt;/p&gt;</summary><category term="tools"></category></entry><entry><title>numpy 矩阵运算的陷阱</title><link href="http://blog.kamidox.com/trap-of-numpy.html" rel="alternate"></link><updated>2015-09-30T20:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-09-30:trap-of-numpy.html</id><summary type="html">&lt;h2 id="_1"&gt;陷阱一：数据结构混乱&lt;/h2&gt;
&lt;p&gt;array 和 matrix 都可以用来表示多维矩阵&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;In [&lt;span style="color: #666666"&gt;98&lt;/span&gt;]: a &lt;span style="color: #666666"&gt;=&lt;/span&gt; np&lt;span style="color: #666666"&gt;.&lt;/span&gt;array([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;2&lt;/span&gt;, &lt;span style="color: #666666"&gt;3&lt;/span&gt;], [&lt;span style="color: #666666"&gt;4&lt;/span&gt;, &lt;span style="color: #666666"&gt;5&lt;/span&gt;, &lt;span style="color: #666666"&gt;6&lt;/span&gt;], [&lt;span style="color: #666666"&gt;7&lt;/span&gt;, &lt;span style="color: #666666"&gt;8&lt;/span&gt;, &lt;span style="color: #666666"&gt;9&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;99&lt;/span&gt;]: a
Out[&lt;span style="color: #666666"&gt;99&lt;/span&gt;]:
array([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;2&lt;/span&gt;, &lt;span style="color: #666666"&gt;3&lt;/span&gt;],
       [&lt;span style="color: #666666"&gt;4&lt;/span&gt;, &lt;span style="color: #666666"&gt;5&lt;/span&gt;, &lt;span style="color: #666666"&gt;6&lt;/span&gt;],
       [&lt;span style="color: #666666"&gt;7&lt;/span&gt;, &lt;span style="color: #666666"&gt;8&lt;/span&gt;, &lt;span style="color: #666666"&gt;9&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;100&lt;/span&gt;]: A &lt;span style="color: #666666"&gt;=&lt;/span&gt; np&lt;span style="color: #666666"&gt;.&lt;/span&gt;matrix([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;2&lt;/span&gt;, &lt;span style="color: #666666"&gt;3&lt;/span&gt;], [&lt;span style="color: #666666"&gt;4&lt;/span&gt;, &lt;span style="color: #666666"&gt;5&lt;/span&gt;, &lt;span style="color: #666666"&gt;6&lt;/span&gt;], [&lt;span style="color: #666666"&gt;7&lt;/span&gt;, &lt;span style="color: #666666"&gt;8&lt;/span&gt;, &lt;span style="color: #666666"&gt;9&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;101&lt;/span&gt;]: A
Out[&lt;span style="color: #666666"&gt;101&lt;/span&gt;]:
matrix([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;2&lt;/span&gt;, &lt;span style="color: #666666"&gt;3&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;4&lt;/span&gt;, &lt;span style="color: #666666"&gt;5&lt;/span&gt;, &lt;span style="color: #666666"&gt;6&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;7&lt;/span&gt;, &lt;span style="color: #666666"&gt;8&lt;/span&gt;, &lt;span style="color: #666666"&gt;9&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;102&lt;/span&gt;]: a&lt;span style="color: #666666"&gt;.&lt;/span&gt;shape
Out[&lt;span style="color: #666666"&gt;102&lt;/span&gt;]: (&lt;span style="color: #666666"&gt;3&lt;/span&gt;, &lt;span style="color: #666666"&gt;3&lt;/span&gt;)

In [&lt;span style="color: #666666"&gt;103&lt;/span&gt;]: A&lt;span style="color: #666666"&gt;.&lt;/span&gt;shape
Out[&lt;span style="color: #666666"&gt;103&lt;/span&gt;]: (&lt;span style="color: #666666"&gt;3&lt;/span&gt;, &lt;span style="color: #666666"&gt;3&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来效果不错。假设我们要对数据进行筛选，取第 1 列的第 1 行和第 3 行数据构成一个 2 x 1 的列向量。先看对 array 的做法&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;In [&lt;span style="color: #666666"&gt;99&lt;/span&gt;]: a
Out[&lt;span style="color: #666666"&gt;99&lt;/span&gt;]:
array([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;2&lt;/span&gt;, &lt;span style="color: #666666"&gt;3&lt;/span&gt;],
       [&lt;span style="color: #666666"&gt;4&lt;/span&gt;, &lt;span style="color: #666666"&gt;5&lt;/span&gt;, &lt;span style="color: #666666"&gt;6&lt;/span&gt;],
       [&lt;span style="color: #666666"&gt;7&lt;/span&gt;, &lt;span style="color: #666666"&gt;8&lt;/span&gt;, &lt;span style="color: #666666"&gt;9&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;100&lt;/span&gt;]: y
Out[&lt;span style="color: #666666"&gt;100&lt;/span&gt;]:
matrix([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;0&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;1&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;101&lt;/span&gt;]: a[:, &lt;span style="color: #666666"&gt;0&lt;/span&gt;]
Out[&lt;span style="color: #666666"&gt;101&lt;/span&gt;]: array([&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;4&lt;/span&gt;, &lt;span style="color: #666666"&gt;7&lt;/span&gt;])

In [&lt;span style="color: #666666"&gt;102&lt;/span&gt;]: a[:, &lt;span style="color: #666666"&gt;0&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;shape
Out[&lt;span style="color: #666666"&gt;102&lt;/span&gt;]: (&lt;span style="color: #666666"&gt;3&lt;/span&gt;,)

In [&lt;span style="color: #666666"&gt;110&lt;/span&gt;]: a[:, &lt;span style="color: #666666"&gt;0&lt;/span&gt;][y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;]
&lt;span style="color: #666666"&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #D2413A; font-weight: bold"&gt;IndexError&lt;/span&gt;                                Traceback (most recent call last)
&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;ipython&lt;span style="color: #666666"&gt;-&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;input&lt;/span&gt;&lt;span style="color: #666666"&gt;-110-&lt;/span&gt;f32ed63aa2a8&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;module&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;()
&lt;span style="color: #666666"&gt;----&amp;gt;&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt; a[:, &lt;span style="color: #666666"&gt;0&lt;/span&gt;][y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;]

&lt;span style="color: #D2413A; font-weight: bold"&gt;IndexError&lt;/span&gt;: too many indices &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; array

In [&lt;span style="color: #666666"&gt;111&lt;/span&gt;]: a[:, &lt;span style="color: #666666"&gt;0&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;reshape(&lt;span style="color: #666666"&gt;3&lt;/span&gt;, &lt;span style="color: #666666"&gt;1&lt;/span&gt;)[y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;]
Out[&lt;span style="color: #666666"&gt;111&lt;/span&gt;]: array([&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;7&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从 Out[101] 可以看到一个陷阱，&lt;code&gt;a[:, 0]&lt;/code&gt; 过滤完应该是一个 3 x 1 的列向量，可是它变成了行向量。其实也不是真正意义上的行向量，因为行向量 shape 应该是 3 x 1，可是他的 shape 是 (3,) ，这其实已经退化为一个数组了。所以，导致最后 In [110] 出错。只有像 In [111] 那样 reshape 一下才可以。我不知道大家晕了没有，我是已经快晕了。&lt;/p&gt;
&lt;p&gt;相比之下，matrix 可以确保运算结果全部是二维的，结果相对好一点。为什么只是相对好一点呢？呆会儿我们再来吐吐 matrix 的槽点。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;In [&lt;span style="color: #666666"&gt;101&lt;/span&gt;]: A
Out[&lt;span style="color: #666666"&gt;101&lt;/span&gt;]:
matrix([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;2&lt;/span&gt;, &lt;span style="color: #666666"&gt;3&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;4&lt;/span&gt;, &lt;span style="color: #666666"&gt;5&lt;/span&gt;, &lt;span style="color: #666666"&gt;6&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;7&lt;/span&gt;, &lt;span style="color: #666666"&gt;8&lt;/span&gt;, &lt;span style="color: #666666"&gt;9&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;112&lt;/span&gt;]: y
Out[&lt;span style="color: #666666"&gt;112&lt;/span&gt;]:
matrix([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;0&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;1&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;113&lt;/span&gt;]: A[:,&lt;span style="color: #666666"&gt;0&lt;/span&gt;]
Out[&lt;span style="color: #666666"&gt;113&lt;/span&gt;]:
matrix([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;4&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;7&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;102&lt;/span&gt;]: A[:, &lt;span style="color: #666666"&gt;0&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;shape
Out[&lt;span style="color: #666666"&gt;102&lt;/span&gt;]: (&lt;span style="color: #666666"&gt;3&lt;/span&gt;,&lt;span style="color: #666666"&gt;1&lt;/span&gt;)

In [&lt;span style="color: #666666"&gt;114&lt;/span&gt;]: A[:,&lt;span style="color: #666666"&gt;0&lt;/span&gt;][y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;]
Out[&lt;span style="color: #666666"&gt;114&lt;/span&gt;]: matrix([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #666666"&gt;7&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;114&lt;/span&gt;]: A[:,&lt;span style="color: #666666"&gt;0&lt;/span&gt;][y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;shape
Out[&lt;span style="color: #666666"&gt;114&lt;/span&gt;]: (&lt;span style="color: #666666"&gt;1&lt;/span&gt;,&lt;span style="color: #666666"&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来还不错。不过槽点就来了。Out [114] 我们预期的输入结果应该是一个 2 x 1 的列向量，可是这里变成了 1 x 2 的行向量！&lt;/p&gt;
&lt;p&gt;为什么我会在意行向量和列向量？在矩阵运算里，行向量和列向量是不同的。比如一个 m x 3 的矩阵可以和 3 x 1 的列向量叉乘，结果是 m x 1 的列向量。而如果一个 m x 3 的矩阵和 1 x 3 的行向量叉乘是会报错的。&lt;/p&gt;
&lt;h2 id="_2"&gt;陷阱二：数据处理能力不足，语言效率低&lt;/h2&gt;
&lt;p&gt;我们再看个例子。假设 X 是 5 x 2 的矩阵，Y 是 5 X 1 的 bool 矩阵，我们想用 Y 来过滤 X ，即取出 Y 值为 True 的项的索引，拿这些索引去 X 里找出对应的行，再组合成一个新矩阵。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;In [&lt;span style="color: #666666"&gt;79&lt;/span&gt;]: X
Out[&lt;span style="color: #666666"&gt;79&lt;/span&gt;]:
matrix([[ &lt;span style="color: #666666"&gt;34.62365962&lt;/span&gt;,  &lt;span style="color: #666666"&gt;78.02469282&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;30.28671077&lt;/span&gt;,  &lt;span style="color: #666666"&gt;43.89499752&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;35.84740877&lt;/span&gt;,  &lt;span style="color: #666666"&gt;72.90219803&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;60.18259939&lt;/span&gt;,  &lt;span style="color: #666666"&gt;86.3085521&lt;/span&gt; ],
        [ &lt;span style="color: #666666"&gt;79.03273605&lt;/span&gt;,  &lt;span style="color: #666666"&gt;75.34437644&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;80&lt;/span&gt;]: Y
Out[&lt;span style="color: #666666"&gt;80&lt;/span&gt;]:
matrix([[ &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;],
        [&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;],
        [ &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;],
        [ &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;],
        [&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;]], dtype&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;bool&lt;/span&gt;)

In [&lt;span style="color: #666666"&gt;81&lt;/span&gt;]: X[Y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;]
Out[&lt;span style="color: #666666"&gt;81&lt;/span&gt;]: matrix([[ &lt;span style="color: #666666"&gt;34.62365962&lt;/span&gt;,  &lt;span style="color: #666666"&gt;35.84740877&lt;/span&gt;,  &lt;span style="color: #666666"&gt;60.18259939&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;85&lt;/span&gt;]: X[Y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;, :]
&lt;span style="color: #666666"&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #D2413A; font-weight: bold"&gt;IndexError&lt;/span&gt;                                Traceback (most recent call last)
&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;ipython&lt;span style="color: #666666"&gt;-&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;input&lt;/span&gt;&lt;span style="color: #666666"&gt;-85-2&lt;/span&gt;aeabbc2bcc5&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;module&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;()
&lt;span style="color: #666666"&gt;----&amp;gt;&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt; X[Y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;, :]

C:\Python27\lib\site&lt;span style="color: #666666"&gt;-&lt;/span&gt;packages\numpy\matrixlib\defmatrix&lt;span style="color: #666666"&gt;.&lt;/span&gt;pyc &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; __getitem__(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, index)
    &lt;span style="color: #666666"&gt;314&lt;/span&gt;
    &lt;span style="color: #666666"&gt;315&lt;/span&gt;         &lt;span style="color: #AA22FF; font-weight: bold"&gt;try&lt;/span&gt;:
&lt;span style="color: #666666"&gt;--&amp;gt;&lt;/span&gt; &lt;span style="color: #666666"&gt;316&lt;/span&gt;             out &lt;span style="color: #666666"&gt;=&lt;/span&gt; N&lt;span style="color: #666666"&gt;.&lt;/span&gt;ndarray&lt;span style="color: #666666"&gt;.&lt;/span&gt;__getitem__(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, index)
    &lt;span style="color: #666666"&gt;317&lt;/span&gt;         &lt;span style="color: #AA22FF; font-weight: bold"&gt;finally&lt;/span&gt;:
    &lt;span style="color: #666666"&gt;318&lt;/span&gt;             &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;_getitem &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;

&lt;span style="color: #D2413A; font-weight: bold"&gt;IndexError&lt;/span&gt;: too many indices &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; array

In [&lt;span style="color: #666666"&gt;86&lt;/span&gt;]: X[:, &lt;span style="color: #666666"&gt;0&lt;/span&gt;][Y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;]
Out[&lt;span style="color: #666666"&gt;86&lt;/span&gt;]: matrix([[ &lt;span style="color: #666666"&gt;34.62365962&lt;/span&gt;,  &lt;span style="color: #666666"&gt;35.84740877&lt;/span&gt;,  &lt;span style="color: #666666"&gt;60.18259939&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;87&lt;/span&gt;]: X[:, &lt;span style="color: #666666"&gt;1&lt;/span&gt;][Y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;]
Out[&lt;span style="color: #666666"&gt;87&lt;/span&gt;]: matrix([[ &lt;span style="color: #666666"&gt;78.02469282&lt;/span&gt;,  &lt;span style="color: #666666"&gt;72.90219803&lt;/span&gt;,  &lt;span style="color: #666666"&gt;86.3085521&lt;/span&gt; ]])

In [&lt;span style="color: #666666"&gt;88&lt;/span&gt;]: np&lt;span style="color: #666666"&gt;.&lt;/span&gt;column_stack((x[:, &lt;span style="color: #666666"&gt;0&lt;/span&gt;][y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;reshape(&lt;span style="color: #666666"&gt;3&lt;/span&gt;,&lt;span style="color: #666666"&gt;1&lt;/span&gt;), x[:, &lt;span style="color: #666666"&gt;1&lt;/span&gt;][y &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;]&lt;span style="color: #666666"&gt;.&lt;/span&gt;reshape(&lt;span style="color: #666666"&gt;3&lt;/span&gt;,&lt;span style="color: #666666"&gt;1&lt;/span&gt;)))
Out[&lt;span style="color: #666666"&gt;88&lt;/span&gt;]:
matrix([[ &lt;span style="color: #666666"&gt;34.62365962&lt;/span&gt;,  &lt;span style="color: #666666"&gt;78.02469282&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;35.84740877&lt;/span&gt;,  &lt;span style="color: #666666"&gt;72.90219803&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;60.18259939&lt;/span&gt;,  &lt;span style="color: #666666"&gt;86.3085521&lt;/span&gt; ]])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们预期 X 过滤完是 3 x 2 列的矩阵，但不幸的是从 Out[81] 来看 numpy 这样过滤完只会保留第一列的数据，且把它转化成了行向量，即变成了 1 x 3 的行向量。不知道你有没有抓狂的感觉。如果按照 In [85] 的写法，还会报错。如果要正确地过滤不同的列，需要写成 In [86] 和 In [87] 的形式。但是即使写成 In [86] 和 In [87] 的样式，还是一样把列向量转化成了行向量。所以，要实现这个目的，得复杂到按照 In [88] 那样才能达到目的。实际上，这个还达不到目的，因为那里面写了好多硬编码的数字，要处理通用的过滤情况，还需要写个函数来实现。而这个任务在 matlab/octave 里只需要写成 &lt;code&gt;X(Y==1, :)&lt;/code&gt; 即可完美达成目的。&lt;/p&gt;
&lt;h2 id="_3"&gt;陷阱三：数值运算句法混乱&lt;/h2&gt;
&lt;p&gt;在机器学习算法里，经常要做一些矩阵运算。有时候要做叉乘，有时候要做点乘。我们看一下 numpy 是如何满足这个需求的。&lt;/p&gt;
&lt;p&gt;假设 x, y, theta 的值如下，我们要先让 x 和 y 点乘，再让结果与 theta 叉乘，最后的结果我们期望的是一个 5 x 1 的列向量。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;In [&lt;span style="color: #666666"&gt;22&lt;/span&gt;]: x
Out[&lt;span style="color: #666666"&gt;22&lt;/span&gt;]:
matrix([[  &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;34.62365962&lt;/span&gt;,  &lt;span style="color: #666666"&gt;78.02469282&lt;/span&gt;],
        [  &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;30.28671077&lt;/span&gt;,  &lt;span style="color: #666666"&gt;43.89499752&lt;/span&gt;],
        [  &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;35.84740877&lt;/span&gt;,  &lt;span style="color: #666666"&gt;72.90219803&lt;/span&gt;],
        [  &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;60.18259939&lt;/span&gt;,  &lt;span style="color: #666666"&gt;86.3085521&lt;/span&gt; ],
        [  &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;79.03273605&lt;/span&gt;,  &lt;span style="color: #666666"&gt;75.34437644&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;23&lt;/span&gt;]: y
Out[&lt;span style="color: #666666"&gt;23&lt;/span&gt;]:
matrix([[&lt;span style="color: #666666"&gt;1&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;2&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;3&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;2&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;2&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;24&lt;/span&gt;]: theta
Out[&lt;span style="color: #666666"&gt;24&lt;/span&gt;]:
matrix([[&lt;span style="color: #666666"&gt;2&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;2&lt;/span&gt;],
        [&lt;span style="color: #666666"&gt;2&lt;/span&gt;]])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;直观地讲，我们应该会想这样做：(x 点乘 y) 叉乘 theta。但很不幸，当你输入 &lt;code&gt;x * y&lt;/code&gt; 时妥妥地报错。那好吧，我们这样做总行了吧，&lt;code&gt;x[:, 0] * y&lt;/code&gt; 这样两个列向量就可以点乘了吧，不幸的还是不行，因为 numpy 认为这是 matrix，所以执行的是矩阵相乘（叉乘），要做点乘，必须转为 array 。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;In [&lt;span style="color: #666666"&gt;37&lt;/span&gt;]: x &lt;span style="color: #666666"&gt;*&lt;/span&gt; y
&lt;span style="color: #666666"&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #D2413A; font-weight: bold"&gt;ValueError&lt;/span&gt;                                Traceback (most recent call last)
&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;ipython&lt;span style="color: #666666"&gt;-&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;input&lt;/span&gt;&lt;span style="color: #666666"&gt;-37-&lt;/span&gt;ae1a0a4af750&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;module&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;()
&lt;span style="color: #666666"&gt;----&amp;gt;&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt; x &lt;span style="color: #666666"&gt;*&lt;/span&gt; y

&lt;span style="color: #666666"&gt;/&lt;/span&gt;System&lt;span style="color: #666666"&gt;/&lt;/span&gt;Library&lt;span style="color: #666666"&gt;/&lt;/span&gt;Frameworks&lt;span style="color: #666666"&gt;/&lt;/span&gt;Python&lt;span style="color: #666666"&gt;.&lt;/span&gt;framework&lt;span style="color: #666666"&gt;/&lt;/span&gt;Versions&lt;span style="color: #666666"&gt;/2.7/&lt;/span&gt;Extras&lt;span style="color: #666666"&gt;/&lt;/span&gt;lib&lt;span style="color: #666666"&gt;/&lt;/span&gt;python&lt;span style="color: #666666"&gt;/&lt;/span&gt;numpy&lt;span style="color: #666666"&gt;/&lt;/span&gt;matrixlib&lt;span style="color: #666666"&gt;/&lt;/span&gt;defmatrix&lt;span style="color: #666666"&gt;.&lt;/span&gt;pyc &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; __mul__(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, other)
    &lt;span style="color: #666666"&gt;339&lt;/span&gt;         &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;isinstance&lt;/span&gt;(other, (N&lt;span style="color: #666666"&gt;.&lt;/span&gt;ndarray, &lt;span style="color: #AA22FF"&gt;list&lt;/span&gt;, &lt;span style="color: #AA22FF"&gt;tuple&lt;/span&gt;)) :
    &lt;span style="color: #666666"&gt;340&lt;/span&gt;             &lt;span style="color: #008800; font-style: italic"&gt;# This promotes 1-D vectors to row vectors&lt;/span&gt;
&lt;span style="color: #666666"&gt;--&amp;gt;&lt;/span&gt; &lt;span style="color: #666666"&gt;341&lt;/span&gt;             &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; N&lt;span style="color: #666666"&gt;.&lt;/span&gt;dot(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, asmatrix(other))
    &lt;span style="color: #666666"&gt;342&lt;/span&gt;         &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; isscalar(other) &lt;span style="color: #AA22FF; font-weight: bold"&gt;or&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;not&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;hasattr&lt;/span&gt;(other, &lt;span style="color: #BB4444"&gt;&amp;#39;__rmul__&amp;#39;&lt;/span&gt;) :
    &lt;span style="color: #666666"&gt;343&lt;/span&gt;             &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; N&lt;span style="color: #666666"&gt;.&lt;/span&gt;dot(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, other)

&lt;span style="color: #D2413A; font-weight: bold"&gt;ValueError&lt;/span&gt;: matrices are &lt;span style="color: #AA22FF; font-weight: bold"&gt;not&lt;/span&gt; aligned

In [&lt;span style="color: #666666"&gt;38&lt;/span&gt;]: x[:, &lt;span style="color: #666666"&gt;0&lt;/span&gt;] &lt;span style="color: #666666"&gt;*&lt;/span&gt; y
&lt;span style="color: #666666"&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #D2413A; font-weight: bold"&gt;ValueError&lt;/span&gt;                                Traceback (most recent call last)
&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;ipython&lt;span style="color: #666666"&gt;-&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;input&lt;/span&gt;&lt;span style="color: #666666"&gt;-38-&lt;/span&gt;d55ad841fa29&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;module&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;()
&lt;span style="color: #666666"&gt;----&amp;gt;&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt; x[:, &lt;span style="color: #666666"&gt;0&lt;/span&gt;] &lt;span style="color: #666666"&gt;*&lt;/span&gt; y

&lt;span style="color: #666666"&gt;/&lt;/span&gt;System&lt;span style="color: #666666"&gt;/&lt;/span&gt;Library&lt;span style="color: #666666"&gt;/&lt;/span&gt;Frameworks&lt;span style="color: #666666"&gt;/&lt;/span&gt;Python&lt;span style="color: #666666"&gt;.&lt;/span&gt;framework&lt;span style="color: #666666"&gt;/&lt;/span&gt;Versions&lt;span style="color: #666666"&gt;/2.7/&lt;/span&gt;Extras&lt;span style="color: #666666"&gt;/&lt;/span&gt;lib&lt;span style="color: #666666"&gt;/&lt;/span&gt;python&lt;span style="color: #666666"&gt;/&lt;/span&gt;numpy&lt;span style="color: #666666"&gt;/&lt;/span&gt;matrixlib&lt;span style="color: #666666"&gt;/&lt;/span&gt;defmatrix&lt;span style="color: #666666"&gt;.&lt;/span&gt;pyc &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; __mul__(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, other)
    &lt;span style="color: #666666"&gt;339&lt;/span&gt;         &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;isinstance&lt;/span&gt;(other, (N&lt;span style="color: #666666"&gt;.&lt;/span&gt;ndarray, &lt;span style="color: #AA22FF"&gt;list&lt;/span&gt;, &lt;span style="color: #AA22FF"&gt;tuple&lt;/span&gt;)) :
    &lt;span style="color: #666666"&gt;340&lt;/span&gt;             &lt;span style="color: #008800; font-style: italic"&gt;# This promotes 1-D vectors to row vectors&lt;/span&gt;
&lt;span style="color: #666666"&gt;--&amp;gt;&lt;/span&gt; &lt;span style="color: #666666"&gt;341&lt;/span&gt;             &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; N&lt;span style="color: #666666"&gt;.&lt;/span&gt;dot(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, asmatrix(other))
    &lt;span style="color: #666666"&gt;342&lt;/span&gt;         &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; isscalar(other) &lt;span style="color: #AA22FF; font-weight: bold"&gt;or&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;not&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;hasattr&lt;/span&gt;(other, &lt;span style="color: #BB4444"&gt;&amp;#39;__rmul__&amp;#39;&lt;/span&gt;) :
    &lt;span style="color: #666666"&gt;343&lt;/span&gt;             &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; N&lt;span style="color: #666666"&gt;.&lt;/span&gt;dot(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, other)

&lt;span style="color: #D2413A; font-weight: bold"&gt;ValueError&lt;/span&gt;: matrices are &lt;span style="color: #AA22FF; font-weight: bold"&gt;not&lt;/span&gt; aligned

In [&lt;span style="color: #666666"&gt;39&lt;/span&gt;]: sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(x[:,&lt;span style="color: #666666"&gt;0&lt;/span&gt;]) &lt;span style="color: #666666"&gt;*&lt;/span&gt; sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(y)
Out[&lt;span style="color: #666666"&gt;39&lt;/span&gt;]:
array([[ &lt;span style="color: #666666"&gt;1.&lt;/span&gt;],
       [ &lt;span style="color: #666666"&gt;2.&lt;/span&gt;],
       [ &lt;span style="color: #666666"&gt;3.&lt;/span&gt;],
       [ &lt;span style="color: #666666"&gt;2.&lt;/span&gt;],
       [ &lt;span style="color: #666666"&gt;2.&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;42&lt;/span&gt;]: xy &lt;span style="color: #666666"&gt;=&lt;/span&gt; sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;column_stack(((sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(x[:,&lt;span style="color: #666666"&gt;0&lt;/span&gt;]) &lt;span style="color: #666666"&gt;*&lt;/span&gt; sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(y)), (sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(x[:,&lt;span style="color: #666666"&gt;1&lt;/span&gt;]) &lt;span style="color: #666666"&gt;*&lt;/span&gt; sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(y)), (sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(x[:,&lt;span style="color: #666666"&gt;2&lt;/span&gt;]) &lt;span style="color: #666666"&gt;*&lt;/span&gt; sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(y))))

In [&lt;span style="color: #666666"&gt;43&lt;/span&gt;]: xy
Out[&lt;span style="color: #666666"&gt;43&lt;/span&gt;]:
array([[   &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,   &lt;span style="color: #666666"&gt;34.62365962&lt;/span&gt;,   &lt;span style="color: #666666"&gt;78.02469282&lt;/span&gt;],
       [   &lt;span style="color: #666666"&gt;2.&lt;/span&gt;        ,   &lt;span style="color: #666666"&gt;60.57342154&lt;/span&gt;,   &lt;span style="color: #666666"&gt;87.78999504&lt;/span&gt;],
       [   &lt;span style="color: #666666"&gt;3.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;107.54222631&lt;/span&gt;,  &lt;span style="color: #666666"&gt;218.70659409&lt;/span&gt;],
       [   &lt;span style="color: #666666"&gt;2.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;120.36519878&lt;/span&gt;,  &lt;span style="color: #666666"&gt;172.6171042&lt;/span&gt; ],
       [   &lt;span style="color: #666666"&gt;2.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;158.0654721&lt;/span&gt; ,  &lt;span style="color: #666666"&gt;150.68875288&lt;/span&gt;]])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以，我们需要象 In [39] 那样一列列转为 array 和 y 执行点乘，然后再组合回 5 x 3 的矩阵。好不容易算出了 x 和 y 的点乘了，终于可以和 theta 叉乘了。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;In [&lt;span style="color: #666666"&gt;44&lt;/span&gt;]: xy &lt;span style="color: #666666"&gt;*&lt;/span&gt; theta
Out[&lt;span style="color: #666666"&gt;44&lt;/span&gt;]:
matrix([[ &lt;span style="color: #666666"&gt;227.29670488&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;300.72683316&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;658.4976408&lt;/span&gt; ],
        [ &lt;span style="color: #666666"&gt;589.96460596&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;621.50844996&lt;/span&gt;]])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来结果还不错，但实际上这里面也是陷阱重重。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;In [&lt;span style="color: #666666"&gt;45&lt;/span&gt;]: xy &lt;span style="color: #666666"&gt;*&lt;/span&gt; sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(theta)
&lt;span style="color: #666666"&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #D2413A; font-weight: bold"&gt;ValueError&lt;/span&gt;                                Traceback (most recent call last)
&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;ipython&lt;span style="color: #666666"&gt;-&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;input&lt;/span&gt;&lt;span style="color: #666666"&gt;-45-5&lt;/span&gt;ea2f7324fbe&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;module&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;()
&lt;span style="color: #666666"&gt;----&amp;gt;&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt; xy &lt;span style="color: #666666"&gt;*&lt;/span&gt; sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(theta)

&lt;span style="color: #D2413A; font-weight: bold"&gt;ValueError&lt;/span&gt;: operands could &lt;span style="color: #AA22FF; font-weight: bold"&gt;not&lt;/span&gt; be broadcast together &lt;span style="color: #AA22FF; font-weight: bold"&gt;with&lt;/span&gt; shapes (&lt;span style="color: #666666"&gt;5&lt;/span&gt;,&lt;span style="color: #666666"&gt;3&lt;/span&gt;) (&lt;span style="color: #666666"&gt;3&lt;/span&gt;,&lt;span style="color: #666666"&gt;1&lt;/span&gt;)

In [&lt;span style="color: #666666"&gt;46&lt;/span&gt;]: sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;dot(xy, sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;array(theta))
Out[&lt;span style="color: #666666"&gt;46&lt;/span&gt;]:
array([[ &lt;span style="color: #666666"&gt;227.29670488&lt;/span&gt;],
       [ &lt;span style="color: #666666"&gt;300.72683316&lt;/span&gt;],
       [ &lt;span style="color: #666666"&gt;658.4976408&lt;/span&gt; ],
       [ &lt;span style="color: #666666"&gt;589.96460596&lt;/span&gt;],
       [ &lt;span style="color: #666666"&gt;621.50844996&lt;/span&gt;]])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In [45] 会报错，因为在 array 里 &lt;code&gt;*&lt;/code&gt; 运算符是点乘，而在 matrix 里 &lt;code&gt;*&lt;/code&gt; 运算符是叉乘。如果要在 array 里算叉乘，需要用 &lt;code&gt;dot&lt;/code&gt; 方法。看起来提供了灵活性，实际上增加了使用者的大脑负担。而我们的需求在 matlab/octave 里只需要写成 &lt;code&gt;x .* y * theta&lt;/code&gt; ，直观优雅。&lt;/p&gt;
&lt;h2 id="_4"&gt;陷阱四：语法复杂，不自然&lt;/h2&gt;
&lt;p&gt;比如，我们要在一个 5 x 2 的矩阵的前面加一列全部是 1 的数据，变成一个 5 x 3 的矩阵，我们必须这样写&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;In [&lt;span style="color: #666666"&gt;11&lt;/span&gt;]: x
Out[&lt;span style="color: #666666"&gt;11&lt;/span&gt;]:
matrix([[ &lt;span style="color: #666666"&gt;34.62365962&lt;/span&gt;,  &lt;span style="color: #666666"&gt;78.02469282&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;30.28671077&lt;/span&gt;,  &lt;span style="color: #666666"&gt;43.89499752&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;35.84740877&lt;/span&gt;,  &lt;span style="color: #666666"&gt;72.90219803&lt;/span&gt;],
        [ &lt;span style="color: #666666"&gt;60.18259939&lt;/span&gt;,  &lt;span style="color: #666666"&gt;86.3085521&lt;/span&gt; ],
        [ &lt;span style="color: #666666"&gt;79.03273605&lt;/span&gt;,  &lt;span style="color: #666666"&gt;75.34437644&lt;/span&gt;]])

In [&lt;span style="color: #666666"&gt;18&lt;/span&gt;]: sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;column_stack(((sp&lt;span style="color: #666666"&gt;.&lt;/span&gt;ones((&lt;span style="color: #666666"&gt;5&lt;/span&gt;,&lt;span style="color: #666666"&gt;1&lt;/span&gt;)), x)))
Out[&lt;span style="color: #666666"&gt;18&lt;/span&gt;]:
matrix([[  &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;34.62365962&lt;/span&gt;,  &lt;span style="color: #666666"&gt;78.02469282&lt;/span&gt;],
        [  &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;30.28671077&lt;/span&gt;,  &lt;span style="color: #666666"&gt;43.89499752&lt;/span&gt;],
        [  &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;35.84740877&lt;/span&gt;,  &lt;span style="color: #666666"&gt;72.90219803&lt;/span&gt;],
        [  &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;60.18259939&lt;/span&gt;,  &lt;span style="color: #666666"&gt;86.3085521&lt;/span&gt; ],
        [  &lt;span style="color: #666666"&gt;1.&lt;/span&gt;        ,  &lt;span style="color: #666666"&gt;79.03273605&lt;/span&gt;,  &lt;span style="color: #666666"&gt;75.34437644&lt;/span&gt;]])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有兴趣的人可以数数 In [18] 里有多少个括号，还别不服，括号写少了妥妥地报错。而这个需求在 matlab/octave 里面只需要写成 &lt;code&gt;[ones(5,1) x]&lt;/code&gt; ，瞬间脑袋不短路了，直观优雅又回来了。&lt;/p&gt;
&lt;h2 id="_5"&gt;结论&lt;/h2&gt;
&lt;p&gt;有人说 python 是机器学习和数据分析的新贵，但和专门的领域语言 matlab/octave 相比，用起来确实还是比较别扭的。当然有些槽点是因为语言本身的限制，比如 python 不支持自定义操作符，导致 numpy 的一些设计不够优雅和直观，但默认把列向量转化为行向量的做法只能说是 numpy 本身的设计问题了。这或许就是 Andrew Ng 在他的 Machine Learning 课程里用 matlab/octave ，而不用 python 或其他的语言的原因吧。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>标准方程 Normal Equations</title><link href="http://blog.kamidox.com/normal-equations.html" rel="alternate"></link><updated>2015-09-29T23:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-09-29:normal-equations.html</id><summary type="html">&lt;h2 id="_1"&gt;标准方程&lt;/h2&gt;
&lt;p&gt;线性回归里的梯度下降算法，通过不停地迭代求参数，从而不停地逼近成本函数的最小值来求解。另外一个方法是直接计算成本函数的微分，令微分算子为零，求解这个方程，即可得到线性回归的解。&lt;/p&gt;
&lt;p&gt;回忆一下线性回归算法的成本函数：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = \frac{1}{2m} \sum_{(i=0)}^n \left( h_\theta(x^{(i)}) - y^{(i)} \right)^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;我们让 $\frac{\delta}{\delta \theta} J(\theta) = 0$，求解这个方程最终可以得到：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta = \left( X^T X \right)^{-1} X^T y&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这个就是我们的标准方程。它通过矩阵运算，直接从训练样本里求出参数 $\theta$ 的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从成本函数的微分方程推导出标准议程的过程比较复杂，涉及到较多的矩阵运算和矩阵微分运算。感兴趣的可以参考 &lt;a href="http://cs229.stanford.edu/notes/cs229-notes1.pdf"&gt;cs229-notes1.pdf&lt;/a&gt;。另外 &lt;a href="http://cs229.stanford.edu/section/cs229-linalg.pdf"&gt;&lt;/a&gt; 里面有线性代数的复习资料。&lt;/li&gt;
&lt;li&gt;$X$ 是训练样本的变量，它是个 m x n 矩阵。其中 m 是训练样本的个数，n 是变量个数。&lt;/li&gt;
&lt;li&gt;$y$ 是训练样本的结果数据，它是个 m x 1 的列向量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;奇异矩阵&lt;/h2&gt;
&lt;p&gt;当训练数据集较少时，利用矩阵运算可以较快的算出参数 $\theta$ 的值。但如果 $X^T X$ 是奇异矩阵的话，它就没有逆矩阵存在，这个时候通用方程的解是什么呢？答案是，在 octave 里用 &lt;code&gt;pinv&lt;/code&gt; 来代替 &lt;code&gt;inv&lt;/code&gt; 来计算逆矩阵。这样即使 $X^T X$ 是奇异矩阵，&lt;code&gt;pinv&lt;/code&gt; 也能算出其&amp;rdquo;伪&amp;rdquo;逆矩阵，从而顺利算出通用方向的解。&lt;/p&gt;
&lt;p&gt;那么，物理上讲，$X^T X$ 如果为奇异矩阵的话，到底代表什么意思呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模型变量之间线性相关&lt;br /&gt;
  比如，在房价预测模型里，$x_1$ 代表房子的长度，$x_2$ 代表房子的宽度，而 $x_3$ 代表房子的面积，这里假设房子是方形的，那么实际上 $x_3$ 和 $x_1, x_2$ 是线性相关的。&lt;/li&gt;
&lt;li&gt;训练样例少于变量个数，即 m &amp;lt; n&lt;br /&gt;
  这种情况下，需要减少变量个数来解决问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，如果 $\left( X^T X \right)$ 是奇异矩阵的话，在其他编程语言里是没有办法逆的。所以需要其他的办法来解决这个问题。在逻辑回归算法里，使用了另外一个方法来解决奇异矩阵的问题，即正则化 (Regularization) 。有关正则化的信息后文写到逻辑回归算法时再来详细介绍。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>习得性无助与自信心的建立</title><link href="http://blog.kamidox.com/helpless.html" rel="alternate"></link><updated>2015-09-29T00:13:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-09-29:helpless.html</id><summary type="html">&lt;p&gt;女儿将近四周半了，给她报了个舞蹈班。有一次课程老师是教小朋友做前滚翻。看着小家伙在课堂上非常努力地偿试，总是翻不好，要嘛翻不过去，要嘛勉强翻过去了，但是翻歪了。由于一个班级小朋友太多，老师也没有精力一个个小朋友耐心指导。只能叫家长回家教小朋友练习。&lt;/p&gt;
&lt;p&gt;一天晚上闲来无事，就想教小家伙练习前滚翻。可无论怎么鼓励，小家伙总是不愿意偿试。甚至用她最喜欢的早教机诱惑她：“你只要翻五次，就给你看半小时早教机。”小家伙嘟着嘴说：“可是五次太多了。我会翻歪掉。”最后我自己翻了几次给她看，然后再很认真地对她说：“你看，很容易翻的，你跟着爸爸练习肯定不会再翻歪了，如果歪了，爸爸扶一下你就不会歪了。”小家伙将信将疑地答应了我的要求。&lt;/p&gt;
&lt;p&gt;我先把技巧告诉她，弯腰准备翻时，手离脚要尽量近，头要夹在两只手中间，然后脚用力蹬一下就翻过去了，还示范了一次给她看。小家伙第一次翻的时候，还是有点歪，但我扶着她的腰确保她能较规范地翻过去。小家伙感受到自己的进步，主动要求再翻一次，这次她把动作做得很规范，我基本不用扶着就能很漂亮地翻了。小家伙高兴地手舞足蹈，连连要求再翻，还主动跟说：“爸爸，我们翻二十次吧。”结果后面越翻动作越麻利，再后面基本手都不用怎么用力撑都能很轻松地翻过去。整个晚上，都开心地要翻给外婆看，翻给妈妈看。&lt;/p&gt;
&lt;p&gt;塞利格曼早期研究习得性无助时做过实验，分别电击两组老鼠，第一组无论做什么，都无法逃避电击。另外一组只要跑到一条细长的管道里把开关关掉就不会被电击了。实验发现，第一组在刚开始时也会偿试各种方法逃避电击，但都无济于事，最后只要电击一开始，就无精打采地缩在角落里，不愿意再做任何的偿试了。而第二组老鼠刚开始时不断地偿试去逃避电击，偿试多次后终于找到逃避电击的方法，到最后，只要电击一开始，就会很快地穿过细长的管道用脚去按压开关，从而逃避电击。&lt;/p&gt;
&lt;p&gt;生活中充满着电击，特别是创业的路上，陷阱星罗密布。我们怎么找到逃避电击的方法呢？我们怎么样不陷入习得性无助状态？怎么样保持不断试错的精神？或许文章开头小家伙练习前滚翻的故事可以有些小小的启发。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>常用的微分运算法则</title><link href="http://blog.kamidox.com/computation-rules-for-derivative.html" rel="alternate"></link><updated>2015-09-28T23:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-09-28:computation-rules-for-derivative.html</id><summary type="html">&lt;p&gt;机器学习涉及到较多的数学知识，在工程应用领域，这些数学知识不是必要的，其实很多算法都是数值运算专家写好了的。然而知其然知其所以然，了解这些数学公式的来龙去脉是帮助理解算法的关键。本文直接给出常用的微分运算法则，并运用这些法则来计算分类回归算法 (Logistic Regression) 预测模型 Sigmoid Function 的微分公式。&lt;/p&gt;
&lt;h2 id="_1"&gt;基础函数的微分运算法则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;幂函数法则&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} x^n = nx^{n-1} \end{align}$$&lt;/li&gt;
&lt;li&gt;指数函数法则&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} e^x = e^x \end{align}$$&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} a^x = ln(a)a^x \end{align}$$&lt;/li&gt;
&lt;li&gt;对数函数法则&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} ln(x) = \frac{1}{x} \end{align}$$&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} log_a(x) = \frac{1}{xln(a)} \end{align}$$&lt;/li&gt;
&lt;li&gt;三角函数法则&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} sin(x) = cos(x) \end{align}$$&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} cos(x) = -sin(x) \end{align}$$&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} tan(x) = sin^2(x) = \frac{1}{cos^2(x)} = 1 + tan^2(x) \end{align}$$&lt;/li&gt;
&lt;li&gt;反三角函数法则&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} arcsin(x) = \frac{1}{\sqrt{1-x^2}}, -1 &amp;lt; x &amp;lt; 1 \end{align}$$&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} arccos(x) = -\frac{1}{\sqrt{1-x^2}}, -1 &amp;lt; x &amp;lt; 1 \end{align}$$&lt;br /&gt;
  $$\begin{align} \frac{d}{dx} arctan(x) = \frac{1}{1+x^2} \end{align}$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;组合函数的微分运算法则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;常数法则：如果 $f(x) = n$，n 是常数，则&lt;br /&gt;
  $$\begin{align} f&amp;rsquo; = 0 \end{align}$$&lt;/li&gt;
&lt;li&gt;加法法则&lt;br /&gt;
  $$\begin{align} (\alpha f + \beta g)&amp;rsquo; = \alpha f&amp;rsquo; + \beta g&amp;rsquo; \end{align}$$&lt;/li&gt;
&lt;li&gt;乘法法则&lt;br /&gt;
  $$\begin{align} (fg)&amp;rsquo; = f&amp;rsquo;g + fg&amp;rsquo; \end{align}$$&lt;/li&gt;
&lt;li&gt;除法法则&lt;br /&gt;
  $$\begin{align} \left( \frac{f}{g} \right)&amp;rsquo; = \frac{f&amp;rsquo;g - fg&amp;rsquo;}{g^2} \end{align}$$&lt;br /&gt;
  根据除法法则和指数法则，可以得出推论&lt;br /&gt;
  $$\frac{d}{dx} e^{-x} = \frac{d}{dx} \frac{1}{e^x} = \frac{0-e^x}{e^{2x}} = -\frac{1}{e^x} = -e^{-x}$$&lt;/li&gt;
&lt;li&gt;链接法则：如果 $f(x) = h(g(x))$，则&lt;br /&gt;
  $$\begin{align} f&amp;rsquo;(x) = h&amp;rsquo;(g(x)) g&amp;rsquo;(x) \end{align}$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="sigmoid-function"&gt;计算 Sigmoid Function 的微分&lt;/h2&gt;
&lt;p&gt;$g(x) = \frac{1}{1+e^{-x}}$ 是分类算法的预测函数，也称为 Sigmoid Function 或 Logistic Function。我们利用上文介绍的微分运算法则来证明 Sigmoid Function 的一个特性：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\frac{d}{dx} g(x) = g(x) (1 - g(x))&lt;br /&gt;
$$&lt;/p&gt;
&lt;h3 id="_3"&gt;方法一&lt;/h3&gt;
&lt;p&gt;假设 $f(x) = \frac{1}{x}$，则 $f(g(x)) = \frac{1}{g(x)}$，根据除法法则得到&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
f&amp;rsquo;(g(x)) &amp;amp; = \left( \frac{1}{g(x)} \right)&amp;rsquo; = \frac{1&amp;rsquo; g(x) - 1 g&amp;rsquo;(x)}{g(x)^2} \\&lt;br /&gt;
&amp;amp; = - \frac{g&amp;rsquo;(x)}{g(x)^2}&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 (17) 是根据除法法则得出的结论，除数是常数函数 1，被除数是 $g(x)$。(18) 是根据常数法则得出的结论。&lt;/p&gt;
&lt;p&gt;另一方面，$f(g(x)) = \frac{1}{g(x)} = 1 + e^{-x}$，根据指数法则直接计算微分得到&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
f&amp;rsquo;(g(x)) &amp;amp; = \frac{d}{dx} (1 + e^{-x}) \\&lt;br /&gt;
&amp;amp; = -e^{-x} \\&lt;br /&gt;
&amp;amp; = 1 - \frac{1}{g(x)} \\&lt;br /&gt;
&amp;amp; = \frac{g(x) - 1}{g(x)}&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;(18) 和 (22) 两式是相等的，即&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
- \frac{g&amp;rsquo;(x)}{g(x)^2} &amp;amp; = \frac{g(x) - 1}{g(x)} \\&lt;br /&gt;
g&amp;rsquo;(x) &amp;amp; = g(x)(1 - g(x))&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这样就得到了我们的结果。&lt;/p&gt;
&lt;h3 id="_4"&gt;方法二&lt;/h3&gt;
&lt;p&gt;由 $g(x) = \frac{1}{1+e^{-x}}$ 的定义可知&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
&amp;amp; (1+e^{-x})g(x) = 1 \\&lt;br /&gt;
\Rightarrow &amp;amp; \frac{d}{dx} \left( (1+e^{-x})g(x) \right) = 0  \\&lt;br /&gt;
\Rightarrow &amp;amp; -e^{-x}g(x) + (1+e^{-x})\frac{d}{dx}g(x) = 0    \\&lt;br /&gt;
\Rightarrow &amp;amp; \frac{d}{dx}g(x) = g(x) \frac{e^{-x}}{1+e^{-x}} \\&lt;br /&gt;
\Rightarrow &amp;amp; \frac{d}{dx}g(x) = g(x) \frac{(1 + e^{-x}) - 1}{1+e^{-x}} \\&lt;br /&gt;
\Rightarrow &amp;amp; \frac{d}{dx}g(x) = g(x) \left[ 1 - \frac{1}{1+e^{-x}}\right] \\&lt;br /&gt;
\Rightarrow &amp;amp; \frac{d}{dx}g(x) = g(x) (1 - g(x)) \\&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;(26) 两边取微分；(27) 根据微分的乘法法则。&lt;/p&gt;
&lt;h3 id="_5"&gt;方法三&lt;/h3&gt;
&lt;p&gt;根据除法法则直接计算微分：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
\frac{d}{dx} g(x) &amp;amp; = \frac{d}{dx} \left( \frac{1}{1 + e^{-x}} \right) \\&lt;br /&gt;
&amp;amp; = \frac{0 - (- e^{-x})}{(1 + e^{-x})^2} \\&lt;br /&gt;
&amp;amp; = \frac{e^{-x}}{(1 + e^{-x})^2} \\&lt;br /&gt;
&amp;amp; = \frac{1}{(1 + e^{-x})} \frac{e^{-x}}{(1 + e^{-x})} \\&lt;br /&gt;
&amp;amp; = \frac{1}{(1 + e^{-x})} \frac{(1 + e^{-x}) - 1}{(1 + e^{-x})} \\&lt;br /&gt;
&amp;amp; = \frac{1}{(1 + e^{-x})} \left[1 - \frac{1}{(1 + e^{-x})} \right] \\&lt;br /&gt;
&amp;amp; = g(x) (1 - g(x)) \\&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;(33) 是根据除法法则得出的，其中除数是常数 1，被除数是 $1 + e^{-x}$。&lt;/p&gt;
&lt;h2 id="_6"&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;StackExchange 上有个 &lt;a href="http://math.stackexchange.com/questions/78575/derivative-of-sigmoid-function-sigma-x-frac11e-x"&gt;Sigmoid Function 微分计算的问题及答案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;WikiPedia 上有关&lt;a href="https://en.wikipedia.org/wiki/Derivative#Rules_of_computation"&gt;微分运算法则&lt;/a&gt;的资料&lt;/li&gt;
&lt;/ul&gt;</summary><category term="machine-learning"></category></entry><entry><title>机器学习入门指南</title><link href="http://blog.kamidox.com/ml-getting-started.html" rel="alternate"></link><updated>2015-09-11T20:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-09-11:ml-getting-started.html</id><summary type="html">&lt;p&gt;前段时间微软的年龄识别网站风靡全球，它的核心算法就是机器学习领域的内容。机器学习看起来高深莫测，学习曲线比较陡，实际上优秀的入门资料不但可以降低学习门槛，还可以激发学习乐趣。&lt;/p&gt;
&lt;h2 id="_1"&gt;机器学习算法&lt;/h2&gt;
&lt;p&gt;Coursera 上面 Stanford 的 &lt;a href="https://zh.coursera.org/learn/machine-learning"&gt;机器学习&lt;/a&gt; 课程是优质的算法相关入门课程。Andrew Ng 是 Coursera 的创始人，也是 Stanford 的老师。这个课程最大的特点是对机器学习算法的推导和介绍，从数学层面去推导一些经典的机器学习算法。如果你微积分，矩阵运算，概率论等大学数学都还给老师了也没关系。课程中会介绍用到的最基础的数学知识，包括微积分，矩阵运算，概率论等。真正做到了深入浅出以及零基础。&lt;/p&gt;
&lt;p&gt;算法是理解机器学习原理的非常基础的知识，在实践中我们可能根本不用去推导或实现这些算法，但不代表我们不需要理解这些算法。理解这些算法对我们选择机器学习的模型以及对数据进行分析都有非常有益的。&lt;/p&gt;
&lt;h2 id="_2"&gt;编程语言&lt;/h2&gt;
&lt;p&gt;适合机器学习的编程语言不少，这里推荐使用 Python。Python 是免费开源的语言，并且有非常丰富的库，而且学习 Python 语言的门槛比较低，是全民编程运动的推荐语言。&lt;a href="http://scipy-lectures.github.io/intro/intro.html#why-python"&gt;这篇文章&lt;/a&gt;罗列了目前主流的机器学习语言以及各自的优劣。&lt;/p&gt;
&lt;p&gt;学习 Python 除了官方的教程之外，推荐一本书 &lt;a href="http://www.diveintopython.net/"&gt;Dive Into Python&lt;/a&gt; 有中文版，也有英文版。中文版翻译质量也很高。当然，&lt;a href="http://learnpythonthehardway.org/book/"&gt;Learn Python The Hard Way&lt;/a&gt; 也不错。不过建议选择一本照着练习，一个月掌握这个语言的基础特性问题不大。&lt;/p&gt;
&lt;h2 id="python"&gt;Python 机器学习工具箱&lt;/h2&gt;
&lt;p&gt;Python 用来实现科学计算的软件包是 scipy, numpy, matplotlib，其中 numpy 提供高性能的数值去处；scipy 实现机器学习的算法；matplotlib 提供数据可视化。&lt;/p&gt;
&lt;p&gt;这三个库都挺大的，内容也比较多。这里重点推荐一个非常优质地适合入门的网站：&lt;a href="http://scipy-lectures.github.io/"&gt;Python Scientific Lecture Notes&lt;/a&gt;。一个网站把机器学习想着的 Python 工具全部搞定，并且内容易懂，很适合初学者。&lt;/p&gt;
&lt;h2 id="_3"&gt;机器学习入门书籍&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ituring.com.cn/book/1192"&gt;《机器学习系统设计》&lt;/a&gt;是图灵社区翻译引进的机器学习入门书籍。书中使用 Python 作为机器学习算法的编程语言，从易到难，从实际问题出发，去探索怎么样用机器学习算法去解决实际问题。当然，如果需要自己实现书中的案例，需要掌握 Python 语言以及 Python 机器学习工具箱的几个库的用法。&lt;/p&gt;
&lt;p&gt;这本书的最大特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单易懂，从易到难&lt;/li&gt;
&lt;li&gt;内容比较精简&lt;/li&gt;
&lt;li&gt;让你跳出机器学习的算法，真正从工程角度去理解机器学习，包括数据清洗，模型筛选，模型验证等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_4"&gt;总结&lt;/h2&gt;
&lt;p&gt;建议 Coursera 上的算法课程和《机器学习系统设计》结合起来，并行来看，这样即了解了工程应用的方法，又理解了背后的算法原理。这里介绍了不少英文资料，学习机器学习的过程中还学了英文，一举两得。再花个几十美刀从 Coursera 上弄个课程证书（ Coursera 上课程都是免费学的，但如果要证书则需要交几十美刀不等），瞬间高大上有没有，喝洋墨水有没有。去美帝读书也不就是这样的体验嘛。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>线性回归算法</title><link href="http://blog.kamidox.com/gradient-descent.html" rel="alternate"></link><updated>2015-09-03T20:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-09-03:gradient-descent.html</id><summary type="html">&lt;p&gt;本文总结了线性回归算法里用到的一些微积分知识，接着根据最小均方差推导出梯度下降算法以及优化后的随机梯度下降算法。&lt;/p&gt;
&lt;h2 id="_1"&gt;微积分基本运算法则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;法则一&lt;/strong&gt;：对 $y(x)=cx^n$ ，其针对 x 的偏导数为 $\frac{\partial}{\partial x}f(x)=cnx^{n-1}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;法则二&lt;/strong&gt;：常数的微分为 0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;法则三&lt;/strong&gt;：偏导数可以穿透累加器，即 $$\frac{\partial}{\partial x_0}\sum_{i=0}^nF(x_i) = \sum_{i=0}^n\frac{\partial}{\partial x_0}F(x_i)$$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;法则四&lt;/strong&gt;：微分链接法则，比如 $f(x)$ 是以 x 为自变量的函数，令 $J(x)=g(f(x))$ ，则 $J(x)$ 的微分方程为 $$\frac{\partial}{\partial x}J(x) = g&amp;rsquo;(f(x))\times f&amp;rsquo;(x)$$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;法则五&lt;/strong&gt;：计算偏导数时，把求导变量当作变量，其他的变量当作常数，比如对方程 $f(x, y) = ax^n + by^m$，则 $$\frac{\partial}{\partial x}f(x, y) = na x^{n-1}$$ 因为是对 x 求导，所以可以把 y 当成常数，即 $by^m$ 整个算子就是一个常数，根据第二个法则，常数的导数为 0。同理，$$\frac{\partial}{\partial y}f(x, y) = mby^{m-1}$$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;维基百科上有教程可以参考，比如 &lt;a href="https://en.wikipedia.org/wiki/Chain_rule"&gt;Chain Rule&lt;/a&gt; 和 &lt;a href="https://en.wikipedia.org/wiki/Partial_derivatives"&gt;Partial Derivatives&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="_2"&gt;线性回归算法&lt;/h2&gt;
&lt;p&gt;假设我们&lt;strong&gt;训练数据集 (training data set)&lt;/strong&gt; 有 m 个数据 $(x_0, y_0), (x_1, y_1), &amp;hellip; (x_m, y_m)$ ，我们用线性方程 $h(x) = \theta_0 + \theta_1 x$ 来拟合这组数据，怎么样来选取参数 $\theta_0$ 和 $\theta_1$ 来最优拟合这组数据呢？&lt;/p&gt;
&lt;p&gt;我们可以把这 m 个点画在二维坐标系里，然后计算这 m 个点到我们的线性方程所描述的直线的最短距离，当这些点到我们的拟合直线的距离总和最小时，那么我们就找到了最优的拟合方案了。所以，问题转化为求下面函数的最小值：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = J(\theta_0, \theta_1) = \frac{1}{2m}\sum_{i=1}^m(h(x^{(i)}) - y^{(i)})^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;上面的公式叫&lt;strong&gt;成本函数 (Cost Function)&lt;/strong&gt;，其中 $h(x_i)$ 是我们的拟合函数针对 $x_i$ 这个点预测出来的值。乘以 $\frac12$ 是为了计算方便，后文我们会看到。&lt;/p&gt;
&lt;p&gt;上面我们只考虑了一个变量 $x$ ，即决定这组数据 $y$ 值的只有一个变量。考虑更一般的情况，有 n 个变量 $x_1, x_2, x_3, &amp;hellip; x_n$ 决定 $y$ 的值，那么我们的预测函数模型可以改写如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
h(x) = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + &amp;hellip; + \theta_n x_n&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;我们让 $x_0$ 为常数 1，用累加器运算符重写上面的预测函数&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
h(x) = \sum_{j=0}^n \theta_j x_j&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;$\theta_0, \theta_1, &amp;hellip; \theta_n$ 我们统称为 $\theta$，是我们的预测函数的 n 个&lt;strong&gt;参数 (parameters)&lt;/strong&gt;。即一组 $\theta$ 值就决定了一个预测函数，我们记作 $h_\theta(x)$，为了简便起见，在不引起误解的情况下我们也把它简写为 $h(x)$。理论上，预测函数有无穷多个，我们求解的目标就是找出一个最优的 $\theta$ 值。&lt;/p&gt;
&lt;div class="admonition hint"&gt;
&lt;p class="admonition-title"&gt;考考你&lt;/p&gt;
&lt;p&gt;当有 n 个变量 $x_1, x_2, &amp;hellip; x_n$ 决定 y 的值的时候，训练数据集应该长什么样呢？&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;为了计算 $J(\theta)$ 的最小值，我们选取一组初始的 $\theta$ ，然后逐步调整 $\theta$ 的值，以便让 $J(\theta)$ 逐渐变小，最后我们希望能让 $J(\theta)$ 收敛在一个极值附近，这样我们就找到了最优或局部最优的解。$\theta$ 的迭代公式为：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_j = \theta_j - \alpha \frac\partial{\partial{\theta_j}}J(\theta)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;$\alpha$&lt;/strong&gt; 是叫&lt;strong&gt;学习率 (learning rate)&lt;/strong&gt;，表示我们一次要让 $\theta_j$ 往前迈多大步子。如果步子太小，意味着要计算很多次才能到达目的地，如果步子太大，可以会直接跨过目的地，从而无法收敛。$\frac\partial{\partial{\theta_j}}J(\theta)$ 就是成本函数的&lt;strong&gt;偏导数 (partial derivatives)&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="admonition hint"&gt;
&lt;p class="admonition-title"&gt;偏导数的物理意义&lt;/p&gt;
&lt;p&gt;在这个公式里，可以简单地把偏导数理解为斜率。我们要让 $\theta_j$ 不停地迭代，则根据当前 $\theta_j$ 的值，我们算出 $J(\theta)$ 在 $\theta_j$ 上的斜率，然后再乘以我们的学习率 $\alpha$ 就让我们的 $\theta_j$ 往前迈了一小步。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;现在问题转化为求 $J(\theta)$ 的偏导数，这个推导过程会用到文章开头部分介绍的几个微积分运算基本法则。&lt;/p&gt;
&lt;p&gt;根据成本函数的定义，以及文章开头的几个微积分基本运算法则，我们可以求解参数迭代公式里偏微分算子。&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
\frac\partial{\partial{\theta_j}}J(\theta) &amp;amp; = \frac\partial{\partial{\theta_j}} \frac{1}{2m}\sum_{i=1}^m(h(x^{(i)}) - y^{(i)})^2 \\&lt;br /&gt;
&amp;amp; = \frac{1}{2m}\sum_{i=1}^m \frac\partial{\partial{\theta_j}} (h(x^{(i)}) - y^{(i)})^2 \\&lt;br /&gt;
&amp;amp; = 2 \frac{1}{2m} \sum_{i=1}^m \left((h(x^{(i)}) - y^{(i)}) \frac\partial{\partial{\theta_j}} \left(h(x^{(i)}) - y^{(i)}\right)\right) \\&lt;br /&gt;
&amp;amp; = \frac{1}{m} \sum_{i=1}^m \left(\left(h(x^{(i)}) - y^{(i)}\right) \frac\partial{\partial{\theta_j}} \left(\sum_{j=0}^n \theta_j x_j^{(i)} - y^{(i)}\right)\right) \\&lt;br /&gt;
&amp;amp; = \frac{1}{m} \sum_{i=1}^m \left(\left(h(x^{(i)}) - y^{(i)}\right) x_j^{(i)}\right) \\&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;式子 (2) 是根据上文的法则三得到的。式子 (3) 是根据上文的法则四得到的，这里也可以看到之前除以 2 的目的是为了抵消计算偏导数时乘以 2。式子 (5) 是根据上文的法则五得到的。&lt;/p&gt;
&lt;p&gt;最后得出我们的参数迭代函数&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\begin{align}&lt;br /&gt;
\theta_j &amp;amp; = \theta_j - \frac{\alpha}{m} \sum_{i=1}^m \left(\left(h(x^{(i)}) - y^{(i)}\right) x_j^{(i)}\right)&lt;br /&gt;
\end{align}&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这个就是 &lt;strong&gt;LSM&lt;/strong&gt; (Least Mean Squares) 迭代算法，也叫 &lt;strong&gt;Widrow-Hoff&lt;/strong&gt; 学习算法。&lt;/p&gt;
&lt;p&gt;解析一下这个公式几个关键部分的含义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$h(x^{(i)})$: 这个是按照我们的给定的参数的预测值，只要 $\theta$ 确定了，我们就可以根据预测函数算出这个值&lt;/li&gt;
&lt;li&gt;$y^{(i)}$: 这个是&lt;strong&gt;训练数据集 (training data set)&lt;/strong&gt; 的目标值&lt;/li&gt;
&lt;li&gt;$x_j^{(i)}$: 这个是训练数据集里第 j 个变量的值&lt;/li&gt;
&lt;li&gt;$\sum_{i=1}^m$: 这个是对所有训练数据集求和。从这个也可以看到每迭代一次就要遍历一次全部训练数据集。所以这个算法也称为&lt;strong&gt;批量梯度下降算法 (Batch Gradient Descent) &lt;/strong&gt;。对训练数据集比较大的场景下，计算成本是很高的。后面我们会介绍另外一个提高运算效率的算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个公式有些符合直觉的地方，比如 $\left(h(x^{(i)}) - y^{(i)}\right)$ 表示的是预测值与真实值的误差，当误差比较大时，经过一轮的迭代，$\theta_j$ 的步幅就迈得比较大。即当我们的参数 $\theta$ 离我们的目标值很远的时候，迭代一次的值变化比较大，可以快速地收敛，而当 $\theta$ 离目标值比较近的时候，迭代一次的值变化比较小，即慢慢地收敛到目标值。&lt;/p&gt;
&lt;p&gt;这个公式怎么样用编程语言来实现呢？在编写机器学习算法的时候，一般步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;确定学习率 $\alpha$ &lt;/strong&gt;&lt;br /&gt;
  $\alpha$ 太大可能会使成本函数无法收敛，太小计算太多，机器学习算法效率就比较低。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确定参数起始点&lt;/strong&gt;&lt;br /&gt;
  比如让所有的参数都为 1 作为起点，即 $\theta_0 := 1, \theta_1 := 1, &amp;hellip; \theta_n := 1$。这样就得到了我们的预测函数：$h_\theta(x) = \sum_{i=1}^m x^{(i)}$。根据预测值和我们的成本函数，就可以算出我们在参数起始位置的成本。需要注意的是，参数起始点可以根据实际情况灵活选择，以便让机器学习算法的性能更高，比如选择比较靠近极点的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算参数的下一组值&lt;/strong&gt;&lt;br /&gt;
  根据 LSM 算法，&lt;strong&gt;分别同时算出&lt;/strong&gt;新的 $\theta_j$ 的值。然后用新的 $\theta$ 值得到新的预测函数 $h_\theta(x)$，再根据新的预测函数，代入成本函数就可以算出新的成本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确认成本函数是否收敛&lt;/strong&gt;&lt;br /&gt;
  拿新的成本和旧的成本进行比较，看成本是不是变得越来越小。如果两次成本之间的差异小于误差范围，即说明我们已经非常靠近最小成本附近了。就可以近似地认为我们找到了最小成本了。如果两次成本之间的差异在误差范围之外，重复步骤 3 继续计算下一组参数 $\theta$。直到找到我们的最优解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;随机梯度下降算法&lt;/h2&gt;
&lt;p&gt;批量梯度下降算法对参数进行一次迭代运算，就需要遍历所有的训练数据集。当训练数据集比较大时，这个算法的效率会很低。考虑另外一个算法：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_j = \theta_j - \alpha \left(\left(h(x^{(i)}) - y^{(i)}\right) x_j^{(i)}\right)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这就是 &lt;strong&gt;随机梯度下降算法&lt;/strong&gt; (stochastic gradient descent)。这个算法的关键点是不去遍历所有的训练数据集，而是改成每次随机地从训练数据集里取一个数据进行参数迭代计算。&lt;/p&gt;
&lt;div class="admonition hint"&gt;
&lt;p class="admonition-title"&gt;怎么理解随机&lt;/p&gt;
&lt;p&gt;为什么这么神奇呢？为什么随机从训练数据集里选取一个数据来迭代，不但不影响最终计算结果，还大大地提高了效率。看数学时最怕的就是 &lt;strong&gt;我们考虑 bla bla bla&lt;/strong&gt;，作者说出 “我们考虑 bla bla bla” 时背后的过程是怎么样的？坦白讲，怎么样从数学上证明随机梯度下降算法和批量梯度下降算法是等价的，我也不知道。不过我有个直观的可以帮助理解的解释。回到成本函数的定义：$J(\theta) = \frac{1}{2m} \sum_{i=1}^m \left(h(x^{(i)}) - y^{(i)}\right)^2$。我们说过，这里累加后除以 2 是为了计算方便，那么我们除以 m 是什么意思呢？答案是平均值，即所有训练数据集上的点到我们预测函数的距离的&lt;strong&gt;平均值&lt;/strong&gt;。再回到&lt;strong&gt;随机选取训练数据集里的一个数据&lt;/strong&gt;这个做法来看，如果计算次数足够多，并且是真正随机，那么随机选取出来的这组数据从概率的角度来看，和&lt;strong&gt;平均值&lt;/strong&gt;是相当的。打个比方，有一个储钱罐里有 1 角的硬币 10 枚，5 角的硬币 2 枚，1 元的硬币 1 枚，总计 3 元，13 枚硬币。你随机从里面取 1000 次，每次取出来的硬币把币值记录下来，然后放回储钱罐里。这样最后去算这 1000 次取出来的钱的平均值 (1000 次取出来的币值总和除以 1000) 和储钱罐里每枚硬币的平均值 (3/13 元) 应该是近似相等的。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这样，我们基本上把线性回归算法，最小均方差，随机梯度下降算法的来龙去脉理了一遍。&lt;/p&gt;</summary><category term="machine-learning"></category></entry><entry><title>使用 Markdown + MathJax 在博客里插入数学公式</title><link href="http://blog.kamidox.com/write-math-formula-with-mathjax.html" rel="alternate"></link><updated>2018-06-20T22:52:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-09-01:write-math-formula-with-mathjax.html</id><summary type="html">&lt;p&gt;在书写数值计算类文章，特别是机器学习相关算法时，难免需要插入复杂的数学公式。一种是用图片在网页上展示，另外一种是使用 &lt;a href="https://www.mathjax.org"&gt;MathJax&lt;/a&gt; 来展示复杂的数学公式。它直接使用 Javascript 使用矢量字库或 SVG 文件来显示数学公式。优点是效果好，比如在 Retina 屏幕上也不会变得模糊。并且可以直接把公式写在 Markdown 文章里。本文介绍使用 MathJax 在 Markdown 文件里直接插入数学公式。并且附带一个简单的书写数学公式的 LaTex 教程。&lt;/p&gt;
&lt;h2 id="_1"&gt;工具&lt;/h2&gt;
&lt;h3 id="markdown-preview-mathjax"&gt;配置 Markdown Preview 来支持 MathJax&lt;/h3&gt;
&lt;p&gt;使用 Sublime + Markdown Preview 插件来写博客时。需要开启 Markdown Preview 对 MathJax 的支持，这样在预览界面才能正确地显示数学公式。方法是打开在 Markdown Preview 的用户配置文件 (Package Settings -&amp;gt; Markdown Preview -&amp;gt; Setting) 里添加如下内容：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;enable_mathjax&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;true&lt;/span&gt;,
&lt;span style="color: #BB4444"&gt;&amp;quot;js&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt; [
        &lt;span style="color: #BB4444"&gt;&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #BB4444"&gt;&amp;quot;res://MarkdownPreview/js/math_config.js&amp;quot;&lt;/span&gt;,
]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着，需要安装 &lt;a href="https://github.com/skuroda/PackageResourceViewer"&gt;Package​Resource​Viewer&lt;/a&gt;，打开 Markdown Preview 包里的 &lt;code&gt;math_config.js&lt;/code&gt; 文件，修改为如下内容：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;MathJax.Hub.Config({
  config&lt;span style="color: #666666"&gt;:&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;quot;MMLorHTML.js&amp;quot;&lt;/span&gt;],
  extensions&lt;span style="color: #666666"&gt;:&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;quot;tex2jax.js&amp;quot;&lt;/span&gt;],
  jax&lt;span style="color: #666666"&gt;:&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;quot;input/TeX&amp;quot;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;quot;output/HTML-CSS&amp;quot;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;quot;output/NativeMML&amp;quot;&lt;/span&gt;],
  tex2jax&lt;span style="color: #666666"&gt;:&lt;/span&gt; {
    inlineMath&lt;span style="color: #666666"&gt;:&lt;/span&gt; [ [&lt;span style="color: #BB4444"&gt;&amp;#39;$&amp;#39;&lt;/span&gt;,&lt;span style="color: #BB4444"&gt;&amp;#39;$&amp;#39;&lt;/span&gt;], [&lt;span style="color: #BB4444"&gt;&amp;quot;\\(&amp;quot;&lt;/span&gt;,&lt;span style="color: #BB4444"&gt;&amp;quot;\\)&amp;quot;&lt;/span&gt;] ],
    displayMath&lt;span style="color: #666666"&gt;:&lt;/span&gt; [ [&lt;span style="color: #BB4444"&gt;&amp;#39;$$&amp;#39;&lt;/span&gt;,&lt;span style="color: #BB4444"&gt;&amp;#39;$$&amp;#39;&lt;/span&gt;], [&lt;span style="color: #BB4444"&gt;&amp;quot;\\[&amp;quot;&lt;/span&gt;,&lt;span style="color: #BB4444"&gt;&amp;quot;\\]&amp;quot;&lt;/span&gt;] ],
    processEscapes&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;true&lt;/span&gt;
  },
  TeX&lt;span style="color: #666666"&gt;:&lt;/span&gt; {
    extensions&lt;span style="color: #666666"&gt;:&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;quot;AMSmath.js&amp;quot;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;quot;AMSsymbols.js&amp;quot;&lt;/span&gt;],
    TagSide&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;right&amp;quot;&lt;/span&gt;,
    TagIndent&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;.8em&amp;quot;&lt;/span&gt;,
    MultLineWidth&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;85%&amp;quot;&lt;/span&gt;,
    equationNumbers&lt;span style="color: #666666"&gt;:&lt;/span&gt; {
      autoNumber&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;AMS&amp;quot;&lt;/span&gt;,
    },
    unicode&lt;span style="color: #666666"&gt;:&lt;/span&gt; {
      fonts&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;STIXGeneral,&amp;#39;Arial Unicode MS&amp;#39;&amp;quot;&lt;/span&gt;
    }
  },
  displayAlign&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;center&amp;quot;&lt;/span&gt;,
  showProcessingMessages&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;false&lt;/span&gt;,
  messageStyle&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;none&amp;#39;&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只要打开 &lt;code&gt;Option + P&lt;/code&gt; 就可以打开预览。&lt;/p&gt;
&lt;h3 id="pelican-mathjax"&gt;配置 Pelican 主题模板来支持 MathJax&lt;/h3&gt;
&lt;p&gt;我使用的主题是 &lt;code&gt;foundation-default-colours&lt;/code&gt;，它默认是支持 MathJax 的。我们可以在模板 &lt;code&gt;base.html&lt;/code&gt; 找到如下内容：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;script &lt;/span&gt;&lt;span style="color: #BB4444"&gt;type=&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span style="color: #BB4444"&gt;src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
MathJax.Hub.Config({
  config&lt;span style="color: #666666"&gt;:&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;quot;MMLorHTML.js&amp;quot;&lt;/span&gt;],
  extensions&lt;span style="color: #666666"&gt;:&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;quot;tex2jax.js&amp;quot;&lt;/span&gt;],
  jax&lt;span style="color: #666666"&gt;:&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;quot;input/TeX&amp;quot;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;quot;output/HTML-CSS&amp;quot;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;quot;output/NativeMML&amp;quot;&lt;/span&gt;],
  tex2jax&lt;span style="color: #666666"&gt;:&lt;/span&gt; {
    inlineMath&lt;span style="color: #666666"&gt;:&lt;/span&gt; [ [&lt;span style="color: #BB4444"&gt;&amp;#39;$&amp;#39;&lt;/span&gt;,&lt;span style="color: #BB4444"&gt;&amp;#39;$&amp;#39;&lt;/span&gt;], [&lt;span style="color: #BB4444"&gt;&amp;quot;\\(&amp;quot;&lt;/span&gt;,&lt;span style="color: #BB4444"&gt;&amp;quot;\\)&amp;quot;&lt;/span&gt;] ],
    displayMath&lt;span style="color: #666666"&gt;:&lt;/span&gt; [ [&lt;span style="color: #BB4444"&gt;&amp;#39;$$&amp;#39;&lt;/span&gt;,&lt;span style="color: #BB4444"&gt;&amp;#39;$$&amp;#39;&lt;/span&gt;], [&lt;span style="color: #BB4444"&gt;&amp;quot;\\[&amp;quot;&lt;/span&gt;,&lt;span style="color: #BB4444"&gt;&amp;quot;\\]&amp;quot;&lt;/span&gt;] ],
    processEscapes&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;true&lt;/span&gt;
  },
  TeX&lt;span style="color: #666666"&gt;:&lt;/span&gt; {
    extensions&lt;span style="color: #666666"&gt;:&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;quot;AMSmath.js&amp;quot;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;quot;AMSsymbols.js&amp;quot;&lt;/span&gt;],
    TagSide&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;right&amp;quot;&lt;/span&gt;,
    TagIndent&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;.8em&amp;quot;&lt;/span&gt;,
    MultLineWidth&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;85%&amp;quot;&lt;/span&gt;,
    equationNumbers&lt;span style="color: #666666"&gt;:&lt;/span&gt; {
      autoNumber&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;AMS&amp;quot;&lt;/span&gt;,
    },
    unicode&lt;span style="color: #666666"&gt;:&lt;/span&gt; {
      fonts&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;STIXGeneral,&amp;#39;Arial Unicode MS&amp;#39;&amp;quot;&lt;/span&gt;
    }
  },
  displayAlign&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;center&amp;quot;&lt;/span&gt;,
  showProcessingMessages&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;false&lt;/span&gt;,
  messageStyle&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;none&amp;#39;&lt;/span&gt;
});
&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果模板不支持，也可以直接添加上面的脚本来支持 MathJax。&lt;/p&gt;
&lt;h2 id="latex"&gt;LaTex 简明教程&lt;/h2&gt;
&lt;h3 id="_2"&gt;例子&lt;/h3&gt;
&lt;p&gt;先来看个例子：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;$$
J(\theta) = \frac 1 2 \sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})^2
$$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面用 LaTex 格式书写的数学公式经过 MathJax 展示后效果如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
J(\theta) = \frac 1 2 \sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})^2&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;这个公式是线性回归算法里的成本函数。&lt;/p&gt;
&lt;h3 id="_3"&gt;规则&lt;/h3&gt;
&lt;p&gt;关于在 Markdown 书写 LaTex 数学公式有几个规则常用规则需要记住：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行内公式&lt;/strong&gt;&lt;br /&gt;
行内公式使用 &lt;code&gt;$&lt;/code&gt; 号作为公式的左右边界，如 $h(x) = \theta_0 + \theta_1 x$ 公式的 LaTex 内容如下&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;$h(x) = \theta_0 + \theta_1 x$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;行间公式&lt;/strong&gt;&lt;br /&gt;
公式需要独立显示一行时，使用 &lt;code&gt;$$&lt;/code&gt; 来作为公式的左右边界，如&lt;/p&gt;
&lt;p&gt;$$&lt;br /&gt;
\theta_i = \theta_i - \alpha\frac\partial{\partial\theta_i}J(\theta)&lt;br /&gt;
$$&lt;/p&gt;
&lt;p&gt;的 LaTex 代码为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;$$
\theta_i = \theta_i - \alpha\frac\partial{\partial\theta_i}J(\theta)
$$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;常用 LaTex 代码&lt;/strong&gt;&lt;br /&gt;
需要记住的几个常用的符号，这样书写起来会快一点&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\frac&lt;/td&gt;
&lt;td&gt;分子分母之间的横线&lt;/td&gt;
&lt;td&gt;$\frac1x$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_&lt;/td&gt;
&lt;td&gt;用下划线来表示下标&lt;/td&gt;
&lt;td&gt;$x_i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;次方运算符来表示上标&lt;/td&gt;
&lt;td&gt;$x^i$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\sum&lt;/td&gt;
&lt;td&gt;累加器，上下标用上面介绍的编码来书写&lt;/td&gt;
&lt;td&gt;$\sum$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\alpha&lt;/td&gt;
&lt;td&gt;希腊字母 alpha&lt;/td&gt;
&lt;td&gt;$y := \alpha x$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;记住这几个就差不多了，倒回去看一下线性回归算法的成本函数的公式及其 LaTex 代码，对着练习个10分钟基本就可以掌握常用公式的写法了。要特别注意公式里空格和 &lt;code&gt;{}&lt;/code&gt; 的运用规则。基本原则是，空格可加可不加，但如果会引起歧义，最好加上空格。&lt;code&gt;{}&lt;/code&gt; 是用来组成群组的。比如写一个分式时，分母是一个复杂公式时，可以用 &lt;code&gt;{}&lt;/code&gt; 包含起来，这样整个复杂公式都会变成分母了。&lt;/p&gt;
&lt;h3 id="_4"&gt;几个非常有用的资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;这是一篇质量很高的&lt;a href="http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/"&gt;介绍 MathJax 的中文博客文章&lt;/a&gt;，需要注意的是如果是用 markdown 编写 MathJax 公式，当公式里需要两个斜杠 \ 时要写四个斜杠 \。因为 \ 会被 markdown 转义一次。&lt;/li&gt;
&lt;li&gt;Github 上有个&lt;a href="https://kerzol.github.io/markdown-mathjax/editor.html"&gt;在线 Markdown MathJax 编辑器&lt;/a&gt;，可以在这里练习，平时写公式时也可以在这里先写好再拷贝到文章里&lt;/li&gt;
&lt;li&gt;这是 &lt;a href="http://www.forkosh.com/mathtextutorial.html"&gt;LaTex 完整教程&lt;/a&gt;，包含完整的 LaTex 数学公式的内容，包括更高级的格式控制等&lt;/li&gt;
&lt;li&gt;这是一份PDF 格式的 &lt;a href="http://mirrors.ctan.org/info/symbols/math/maths-symbols.pdf"&gt;MathJax 支持的数学符号表&lt;/a&gt;，当需要书写复杂数学公式时，一些非常特殊的符号的转义字符可以从这里查到&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好啦，这样差不多就可以写出优美的数学公式啦。&lt;/p&gt;</summary><category term="markdown"></category><category term="machine-learning"></category></entry><entry><title>使用 Github Pages 来托管 Pelican 生成的博客</title><link href="http://blog.kamidox.com/serve-pelican-on-github-pages.html" rel="alternate"></link><updated>2015-08-22T23:52:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-08-22:serve-pelican-on-github-pages.html</id><summary type="html">&lt;h2 id="github-pages"&gt;关于 Github Pages&lt;/h2&gt;
&lt;p&gt;Github Pages 是 Github 提供的免费的空间来展现静态网页。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Websites for you and your projects. Hosted directly from your GitHub repository. Just edit, push, and your changes are live.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;依照&lt;a href="https://pages.github.com"&gt;官方文档&lt;/a&gt;很容易做出一个 Github Pages 网页。使用 Github Pages 来写博客的主流方法是使用 &lt;a href="http://jekyllrb.com"&gt;Jekyll&lt;/a&gt; 来作为 SSG (Static Site Generator)。&lt;/p&gt;
&lt;h2 id="pelican-github-pages"&gt;把 Pelican 生成的博客托管在 Github Pages 上&lt;/h2&gt;
&lt;p&gt;由于历史原因使用了 Pelican 作为 SSG 并托管在 AWS 主机上。切换到 Github Pages + Jekyll 意味着更换 SSG ，这样必须把所有符合 Pelican 规则的 markdown 文件转换为符合 Jekyll 规则的 markdown 文件。于是想到了一个更偷懒的方法：直接用 Pelican 生成的静态网页放在 Github 上作为 Github Pages。最后再绑定我们自己的域名。这样就完成了迁移工作。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/davisp/ghp-import"&gt;ghp-import&lt;/a&gt; 是做这个事情的最佳工具。 &lt;/p&gt;
&lt;p&gt;发布博客时，输入下面的命令即可：&lt;code&gt;ghp-import -p output&lt;/code&gt;。这个命令做以下几件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把 Pelican 生成的静态网页所在目录 &lt;code&gt;output&lt;/code&gt; 下的所有文件写入 Git 的 &lt;code&gt;gh-pages&lt;/code&gt; 分支&lt;/li&gt;
&lt;li&gt;带 &lt;code&gt;-p&lt;/code&gt; 选项会把 &lt;code&gt;gh-pages&lt;/code&gt; 分支上的内容 push 到 Github 上&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;打开 &lt;code&gt;YourUserName.github.io/YourRepoName&lt;/code&gt; 就可以看到最新的博客内容了。比如 &lt;a href="http://kamidox.github.io/blogs"&gt;kamidox.github.io/blogs&lt;/a&gt; 就是我使用 Github Pages 的托管的博客了。&lt;/p&gt;
&lt;p&gt;关于如何使用 Pelican 来写博客，可以参阅&lt;a href="http://kamidox.com/build-blog-system-by-pelican.html"&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="_1"&gt;定制域名&lt;/h2&gt;
&lt;p&gt;关于 Github Pages 定制域名可以参阅&lt;a href="https://help.github.com/articles/adding-a-cname-file-to-your-repository/"&gt;官方教程&lt;/a&gt;。我们使用 Github 强烈推荐的子域名的形式来定制域名。&lt;/p&gt;
&lt;h3 id="cname"&gt;创建 CNAME&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;gh-pages&lt;/code&gt; 分支根目录提交一个 &lt;code&gt;CNAME&lt;/code&gt; 文件，而 &lt;code&gt;ghp-import&lt;/code&gt; 又会完全覆盖掉 gh-pages 分支。如何解决这个矛盾呢？阳光下没有新鲜事，具体可以参阅 &lt;a href="http://docs.getpelican.com/en/latest/tips.html#extra-tips"&gt;Pelican 的 Tips&lt;/a&gt;。归纳起来，就是先在 &lt;code&gt;content/extra&lt;/code&gt; 目录下新建一个叫 &lt;code&gt;CNAME&lt;/code&gt; 的文件，其内容就是自定义域名的内容，如 &lt;code&gt;blog.kamidox.com&lt;/code&gt;。然后在 Pelican 的配置文件 &lt;code&gt;publishconf.py&lt;/code&gt; 下添加如下内容：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;STATIC_PATHS &lt;span style="color: #666666"&gt;=&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;#39;extra&amp;#39;&lt;/span&gt;]
EXTRA_PATH_METADATA &lt;span style="color: #666666"&gt;=&lt;/span&gt; {
    &lt;span style="color: #BB4444"&gt;&amp;#39;extra/CNAME&amp;#39;&lt;/span&gt;: {&lt;span style="color: #BB4444"&gt;&amp;#39;path&amp;#39;&lt;/span&gt;: &lt;span style="color: #BB4444"&gt;&amp;#39;CNAME&amp;#39;&lt;/span&gt;},   &lt;span style="color: #008800; font-style: italic"&gt;# 这是个路径映射，即会把 `content/extra/CNAME` 文件拷贝到 `output/CNAME`&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;留意一下上面的路径映射。如果没有这个映射，则 Pelican 会把 &lt;code&gt;content/extra&lt;/code&gt; 目录下的内容原封不动的拷贝到 &lt;code&gt;output/extra&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;h3 id="dns"&gt;修改 DNS 解析&lt;/h3&gt;
&lt;p&gt;添加一条 CNAME 记录，指向 username.github.io。比如，我需要把博客地址定为 blog.kamidox.com，则我添加一条 CNAME 解析为 blog 的记录，指向 kamidox.github.io。&lt;/p&gt;
&lt;p&gt;至此，我们完成了博客迁移工作。&lt;/p&gt;
&lt;div class="admonition notes"&gt;
&lt;p class="admonition-title"&gt;域名是如何解析的&lt;/p&gt;
&lt;p&gt;域名解析时，我们实际上创建了两个 CNAME 。一个是在域名提供商那边，把 blog.kamidox.com 子域名使用 CNAME 指向了 kamidox.github.io；另外一个是在 Github Pages 里的 &lt;code&gt;gh-pages&lt;/code&gt; 分支的根目录下有个内容为 blog.kamidox.com 的 CNAME 文件。当我们在浏览器里输入 blog.kamidox.com 时，浏览会先进行 DNS 解析，这个 DNS 解析和普通网络 DNS 解析没有区别，由于我们在域名提供商那边设置了 CNAME 跳转，所以这个 DNS 解析就跳转到 kamidox.github.io 上；接着进行第二次解析是在 Github 内部进行的，Github 会搜索用户下面所有的 Repo 的 &lt;code&gt;gh-pages&lt;/code&gt; 分支下的 CNAME，查找和 blog.kamidox.com 匹配的条目，在本文的例子里，Github 找到了 blogs 这个 Repo 的 &lt;code&gt;gh-pages&lt;/code&gt; ，于是最终跳转到了 kamidox.github.io/blogs 上面。这样就完成了域名绑定工作。&lt;/p&gt;
&lt;/div&gt;</summary><category term="github"></category><category term="pelican"></category></entry><entry><title>如何保持工作的激情</title><link href="http://blog.kamidox.com/be-passion.html" rel="alternate"></link><updated>2015-07-27T20:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-07-27:be-passion.html</id><summary type="html">&lt;p&gt;不少人都有这样的感觉：工作不停地重复，已经麻木了，工作就是在熬，在杀时间，然后领一份工资。身边不少做做技术的工程师，都比较羡慕硅谷的那种充满激情工作氛围。那么我们的工作为什么会变得无趣呢？&lt;/p&gt;
&lt;h2 id="_1"&gt;建立一个内化的目标&lt;/h2&gt;
&lt;p&gt;为什么要加上&lt;strong&gt;内化&lt;/strong&gt;这两个字呢？&lt;strong&gt;内化的目标，是我们的信仰，它确保我们在迷雾中航行时不失去方向；确保在迷茫，困难面前能坚定地前行，这是内在驱动力的主要来源。&lt;/strong&gt;创业团队的 CEO 的一个最重要的工作，就是确保把公司的目标内化到团队所有成员身上。让所有人知道我们的目标是什么，并建立起实现目标的信心。&lt;/p&gt;
&lt;h2 id="_2"&gt;建立即时反馈系统&lt;/h2&gt;
&lt;p&gt;即时反馈系统确保我们每走一小步都得到一个结果反馈，让我们知道我们哪里做好了，哪里还没做好。它确保让我们持续地改进和思考，而这种持续的反馈会带给我们持续的激励。比如我们在运营一个 App，通过在 App 内部埋点，可以看到用户的行为，看到用户是怎么使用我们的软件的，哪个功能是用户常用的，能不能优化？通过这些数据去改进我们的软件，改进后继续观察用户的使用情况，包括软件的用户增加数和活跃情况。当我们的改进能带来一些正向反馈时，这无疑对我们是最大的激励。&lt;/p&gt;
&lt;p&gt;相反，如果不知道如何测量我们的工作成果，那么很大的机会会让我们缺乏工作激情。因为我们不知道怎么做会让事情变得更加美好。所以，要建立一个即时反馈系统，首要任务是让工作成果可测量。&lt;/p&gt;
&lt;h2 id="_3"&gt;学会接纳&lt;/h2&gt;
&lt;p&gt;其实更多的时候，大部分人都处在工作没有激情的状态。考验一个人的，往往是在那些在迷茫困惑不解的时候，依然坚韧前行，做好自己该做的事情的能力。引用马云的一句鸡汤文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任何团队的核心骨干，都必须学会在没有鼓励，没有认可，没有帮助，没有理解，没有宽容，没有退路，只有压力的情况下，一起和团队获得胜利。成功，只有一个定义，就是对结果负责。如果你靠别人的鼓励才能发光，你最多算个灯泡。我们必须成为发动机，去影响其他人发光，你自然就是核心。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经常在网络上看到一些文章，描述硅谷的一些创业公司，感觉他们的工作都是充满激情的。实际上这个跟围城类似，外面的人看很精彩，但如果在围城内部来看，都是一堆细节和问题组成的一个意大利面条系统，系统里大部分人做的，就是持续地解决这些困难，优化细节。&lt;/p&gt;
&lt;p&gt;境由心生，你心中有什么样的世界，你看到的世界就长什么样。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>利用 LeakCanary 来检查 Android 内存泄漏</title><link href="http://blog.kamidox.com/leakcanary.html" rel="alternate"></link><updated>2015-05-12T22:57:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-05-12:leakcanary.html</id><summary type="html">&lt;h3 id="_1"&gt;前言&lt;/h3&gt;
&lt;p&gt;你被概率性的 OOM 困扰么？有时候，OOM 像幽灵一样，挥之不去，可真想把它揪出来时，又捉之不着。或许，是时候用 &lt;a href="https://github.com/square/leakcanary"&gt;LeakCanary&lt;/a&gt; 来诊断一下了。它是一个用来检查 Android 下内存泄漏的开源库，这篇文章主要介绍其用法、架构和其背后的实现原理。&lt;/p&gt;
&lt;p&gt;Square &lt;a href="https://corner.squareup.com/2015/05/leak-canary.html"&gt;有篇文章&lt;/a&gt;介绍了开发这个库的原因。他们的一个付款流程里，需要用到用户的签名，他们直接用 Bitmap 来画签名，Bitmap 大小和屏幕分辨率是一样的。问题来了，在试图创建这个 Bitmap 对象时，概率性 OOM 如幽灵般相随。他们试了几个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;Bitmap.Config.ALPHA_8&lt;/code&gt; 来节省内存&lt;/li&gt;
&lt;li&gt;捕获 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 异常，调用 gc 清理内存，然后重试几次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终这些都不起作用。最终他们发现他们在错误的方向上走得太远了。当存在&lt;strong&gt;内存泄漏&lt;/strong&gt;时，可用内存越来越少，这个时候 OOM 可以发生在任何地方，特别是试图创建一些大内存对象，如 Bitmap 的时候。&lt;/p&gt;
&lt;p&gt;我们在上一篇文章&lt;a href="http://kamidox.com/android-memory-guide.html"&gt;《Android 内存与性能》&lt;/a&gt;里介绍了使用 &lt;a href="http://www.eclipse.org/mat/downloads.php"&gt;MAT&lt;/a&gt; 来分析内存泄漏的方法。概括起来核心步骤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发生 OOM 或做一些可能存在内存泄漏的操作后，导出 HPROF 文件&lt;/li&gt;
&lt;li&gt;利用 MAT 结合代码分析，来发现一些引用异常，比如哪些对象本来应该被回收的，却还在系统堆中，那么它就是内存泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果有一个工具能自动完成这些事情，甚至在发生 OOM 之前，就把内存泄漏报告给你，那是多么美好的一件事情啊。&lt;/strong&gt;LeakCanary 就是用来干这个事情的。在测试你的 App 时，如果发生了内存泄漏，状态栏上会有通知告诉你。logcat 上也会有相应的 log 通知你。&lt;/p&gt;
&lt;div class="admonition notes"&gt;
&lt;p class="admonition-title"&gt;启发&lt;/p&gt;
&lt;p&gt;LeakCanary 产生的背后有几个有意思的启发。一是像 Square 这样公司一样会被 OOM 这种问题困扰；二是他们也会犯错，试了几种方法都不起作用；三是他们最终用一个优雅的方式解决了这个问题，并且通过开源库的方式让所有人共享他们的工作成果。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="_2"&gt;用法&lt;/h3&gt;
&lt;h4 id="activity"&gt;监控 Activity 泄露&lt;/h4&gt;
&lt;p&gt;我们经常把 Activity 当作为 Context 对象使用，在不同场合由各种对象引用 Activity。所以，Activity 泄漏是一个重要的需要检查的内存泄漏之一。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;ExampleApplication&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;extends&lt;/span&gt; Application &lt;span style="color: #666666"&gt;{&lt;/span&gt;

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;static&lt;/span&gt; RefWatcher &lt;span style="color: #00A000"&gt;getRefWatcher&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;Context context&lt;span style="color: #666666"&gt;)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
        ExampleApplication application &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;ExampleApplication&lt;span style="color: #666666"&gt;)&lt;/span&gt; context&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getApplicationContext&lt;/span&gt;&lt;span style="color: #666666"&gt;();&lt;/span&gt;
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; application&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;refWatcher&lt;/span&gt;&lt;span style="color: #666666"&gt;;&lt;/span&gt;
    &lt;span style="color: #666666"&gt;}&lt;/span&gt;

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;private&lt;/span&gt; RefWatcher refWatcher&lt;span style="color: #666666"&gt;;&lt;/span&gt;

    &lt;span style="color: #AA22FF"&gt;@Override&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #00BB00; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00A000"&gt;onCreate&lt;/span&gt;&lt;span style="color: #666666"&gt;()&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;super&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;onCreate&lt;/span&gt;&lt;span style="color: #666666"&gt;();&lt;/span&gt;
        refWatcher &lt;span style="color: #666666"&gt;=&lt;/span&gt; LeakCanary&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;install&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;this&lt;/span&gt;&lt;span style="color: #666666"&gt;);&lt;/span&gt;
    &lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;LeakCanary.install()&lt;/code&gt; 返回一个配置好了的 &lt;code&gt;RefWatcher&lt;/code&gt; 实例。它同时安装了 &lt;code&gt;ActivityRefWatcher&lt;/code&gt; 来监控 Activity 泄漏。即当 &lt;code&gt;Activity.onDestroy()&lt;/code&gt; 被调用之后，如果这个 Activity 没有被销毁，logcat 就会打印出如下信息告诉你内存泄漏发生了。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    * com.example.leakcanary.MainActivity has leaked:
    * GC ROOT thread java.lang.Thread.&amp;lt;Java Local&amp;gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;named &lt;span style="color: #BB4444"&gt;&amp;#39;AsyncTask #1&amp;#39;&lt;/span&gt;&lt;span style="color: #666666"&gt;)&lt;/span&gt;
    * references com.example.leakcanary.MainActivity&lt;span style="color: #B8860B"&gt;$2&lt;/span&gt;.this&lt;span style="color: #B8860B"&gt;$0&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;anonymous class extends android.os.AsyncTask&lt;span style="color: #666666"&gt;)&lt;/span&gt;
    * leaks com.example.leakcanary.MainActivity instance
    * Reference Key: c4d32914-618d-4caf-993b-4b835c255873
    * Device: Genymotion generic Google Galaxy Nexus - 4.2.2 - API &lt;span style="color: #666666"&gt;17&lt;/span&gt; - 720x1280 vbox86p
    * Android Version: 4.2.2 API: 17
    * Durations: &lt;span style="color: #B8860B"&gt;watch&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;5100ms, &lt;span style="color: #B8860B"&gt;gc&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;104ms, heap &lt;span style="color: #B8860B"&gt;dump&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;82ms, &lt;span style="color: #B8860B"&gt;analysis&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;3008ms
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="admonition notes"&gt;
&lt;p class="admonition-title"&gt;Notes&lt;/p&gt;
&lt;p&gt;LeakCanary 自动检测 Activity 泄漏只支持 Android ICS 以上版本。因为 &lt;code&gt;Application.registerActivityLifecycleCallbacks()&lt;/code&gt; 是在 API 14 引入的。如果要在 ICS 之前监测 Activity 泄漏，可以重载 &lt;code&gt;Activity.onDestroy()&lt;/code&gt; 方法，然后在这个方法里调用 &lt;code&gt;RefWatcher.watch(this)&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="fragment"&gt;监控 Fragment 泄漏&lt;/h4&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;abstract&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;BaseFragment&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;extends&lt;/span&gt; Fragment &lt;span style="color: #666666"&gt;{&lt;/span&gt;

    &lt;span style="color: #AA22FF"&gt;@Override&lt;/span&gt; 
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #00BB00; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00A000"&gt;onDestroy&lt;/span&gt;&lt;span style="color: #666666"&gt;()&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;super&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;onDestroy&lt;/span&gt;&lt;span style="color: #666666"&gt;();&lt;/span&gt;
        RefWatcher refWatcher &lt;span style="color: #666666"&gt;=&lt;/span&gt; ExampleApplication&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getRefWatcher&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;getActivity&lt;span style="color: #666666"&gt;());&lt;/span&gt;
        refWatcher&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;watch&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;this&lt;/span&gt;&lt;span style="color: #666666"&gt;);&lt;/span&gt;
    &lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当 &lt;code&gt;Fragment.onDestroy()&lt;/code&gt; 被调用之后，如果这个 fragment 实例没有被销毁，那么就会从 logcat 里看到相应的泄漏信息。&lt;/p&gt;
&lt;h4 id="_3"&gt;监控其他泄漏&lt;/h4&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    &lt;span style="color: #666666"&gt;...&lt;/span&gt;
    RefWatcher refWatcher &lt;span style="color: #666666"&gt;=&lt;/span&gt; ExampleApplication&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getRefWatcher&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;getActivity&lt;span style="color: #666666"&gt;());&lt;/span&gt;
    refWatcher&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;watch&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;someObjNeedGced&lt;span style="color: #666666"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当 &lt;code&gt;someObjNeedGced&lt;/code&gt; 还在内存中时，就会在 logcat 里看到内存泄漏的提示。&lt;/p&gt;
&lt;h4 id="leakcanary"&gt;集成 LeakCanary 库&lt;/h4&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;dependencies {
    debugCompile &amp;#39;com.squareup.leakcanary:leakcanary-android:1.3&amp;#39;
    releaseCompile &amp;#39;com.squareup.leakcanary:leakcanary-android-no-op:1.3&amp;#39;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 debug 版本上，集成 LeakCanary 库，并执行内存泄漏监测，而在 release 版本上，集成一个无操作的 wrapper ，这样对程序性能就不会有影响。&lt;/p&gt;
&lt;h3 id="_4"&gt;原理&lt;/h3&gt;
&lt;h4 id="leakcanary_1"&gt;LeakCanary 流程图&lt;/h4&gt;
&lt;p&gt;&lt;img alt="leakcanary" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/leakcanary.png" /&gt;&lt;/p&gt;
&lt;p&gt;LeakCanary 的机制如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;RefWatcher.watch()&lt;/code&gt; 会以监控对象来创建一个 &lt;code&gt;KeyedWeakReference&lt;/code&gt; 弱引用对象&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;AndroidWatchExecutor&lt;/code&gt; 的后台线程里，来检查弱引用已经被清除了，如果没被清除，则执行一次 GC&lt;/li&gt;
&lt;li&gt;如果弱引用对象仍然没有被清除，说明内存泄漏了，系统就导出 hprof 文件，保存在 app 的文件系统目录下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HeapAnalyzerService&lt;/code&gt; 启动一个单独的进程，使用 &lt;code&gt;HeapAnalyzer&lt;/code&gt; 来分析 hprof 文件。它使用另外一个开源库 &lt;a href="https://github.com/square/haha"&gt;HAHA&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HeapAnalyzer&lt;/code&gt; 通过查找 &lt;code&gt;KeyedWeakReference&lt;/code&gt; 弱引用对象来查找内在泄漏&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HeapAnalyzer&lt;/code&gt; 计算 &lt;code&gt;KeyedWeakReference&lt;/code&gt; 所引用对象的最短强引用路径，来分析内存泄漏，并且构建出对象引用链出来。&lt;/li&gt;
&lt;li&gt;内存泄漏信息送回给 &lt;code&gt;DisplayLeakService&lt;/code&gt;，它是运行在 app 进程里的一个服务。然后在设备通知栏显示内存泄漏信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="_5"&gt;几个有意思的代码&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;如何导出 hprof 文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;File heapDumpFile &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;new&lt;/span&gt; File&lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;heapdump.hprof&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;);&lt;/span&gt;
Debug&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;dumpHprofData&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;heapDumpFile&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getAbsolutePath&lt;/span&gt;&lt;span style="color: #666666"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以参阅 &lt;a href="https://github.com/square/leakcanary/blob/master/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java"&gt;AndroidHeapDumper.java&lt;/a&gt; 的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何分析 hprof 文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是个比较大的话题，感兴趣的可以移步另外一个开源库 &lt;a href="https://github.com/square/haha"&gt;HAHA&lt;/a&gt;，它的祖先是 &lt;a href="http://www.eclipse.org/mat/downloads.php"&gt;MAT&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何使用 HandlerThread&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以参阅 &lt;a href="https://github.com/square/leakcanary/blob/master/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java"&gt;AndroidWatchExecutor.java&lt;/a&gt;的代码，特别是关于 Handler, Loop 的使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么知道某个变量已经被 GC 回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以参阅 &lt;a href="http://www.plantuml.com"&gt;RefWatcher.java&lt;/a&gt; 的 &lt;code&gt;ensureGone()&lt;/code&gt; 函数。最主要是利用 &lt;code&gt;WeakReference&lt;/code&gt; 和 &lt;code&gt;ReferenceQueue&lt;/code&gt; 机制。简单地讲，就是当弱引用 &lt;code&gt;WeakReference&lt;/code&gt; 所引用的对象被回收后，这个 &lt;code&gt;WeakReference&lt;/code&gt; 对象就会被添加到 &lt;code&gt;ReferenceQueue&lt;/code&gt; 队列里，我们可以通过其 &lt;code&gt;poll()&lt;/code&gt; 方法获取到这个被回收的对象的 &lt;code&gt;WeakReference&lt;/code&gt; 实例，进而知道需要监控的对象是否被回收了。&lt;/p&gt;
&lt;h3 id="_6"&gt;关于内存泄漏&lt;/h3&gt;
&lt;p&gt;内存泄漏可能很容易发现，比如 Cursor 没关闭；比如在 &lt;code&gt;Activity.onResume()&lt;/code&gt; 里 register 了某个需要监听的事件，但在 &lt;code&gt;Activity.onPause()&lt;/code&gt; 里忘记 unregister 了；内存泄漏也可能很难发现，比如 &lt;a href="https://github.com/square/leakcanary/blob/master/library/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java"&gt;LeakCanary 示例代码&lt;/a&gt;，隐含地引用，并且只有在旋转屏幕时才会发生。还有更难发现，甚至无能为力的内存泄漏，比如 Android SDK 本身的 BUG 导致内存泄漏。&lt;a href="https://github.com/square/leakcanary/blob/master/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java"&gt;AndroidExcludedRefs.java&lt;/a&gt; 里就记录了一些己知的 AOSP 版本的以及其 OEM 实现版本里存在的内存泄漏。&lt;/p&gt;
&lt;h3 id="_7"&gt;本期推荐&lt;/h3&gt;
&lt;p&gt;推荐一个画图工具 &lt;a href="http://www.plantuml.com"&gt;planUML&lt;/a&gt;，其最大的特色是使用脚本来画图。它和 &lt;a href="http://staruml.io"&gt;starUML&lt;/a&gt; 的最大区别是，前者是画图工具，类似于微软的 visio，而且支持脚本画图，后者是建模工具。&lt;a href="http://www.plantuml.com/PlantUML_Language_Reference_Guide.pdf"&gt;这里&lt;/a&gt;是 planUML 的官方文档。它还支持一堆&lt;a href="http://www.plantuml.com/running.html"&gt;扩展&lt;/a&gt;，比如 &lt;a href="https://github.com/jvantuyl/sublime_diagram_plugin"&gt;Sublime Text&lt;/a&gt;等。本文的&lt;a href="https://raw.githubusercontent.com/kamidox/blogs/master/images/leakcanary.wsd"&gt;流程图&lt;/a&gt;就是用 planUML 画的。&lt;/p&gt;</summary><category term="android"></category></entry><entry><title>Android 内存与性能</title><link href="http://blog.kamidox.com/android-memory-guide.html" rel="alternate"></link><updated>2015-04-22T23:30:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-04-22:android-memory-guide.html</id><summary type="html">&lt;h3 id="_1"&gt;官方教程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://www.udacity.com/course/ud825"&gt;Android Performance&lt;/a&gt; 是 GOOGLE 近期发布在 Udacity 上的官方教程&lt;br /&gt;
   不方便科学上网的同学可以从我的&lt;a href="http://pan.baidu.com/s/1sjPZbxr"&gt;百度网盘&lt;/a&gt;里下载。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.youku.com/playlist_show/id_23494296.html"&gt;Android Performance Patterns&lt;/a&gt; 是 GOOGLE 在 2015 年初发布在 Facebook 上的专题课程&lt;br /&gt;
   这部分内容 &lt;a href="http://www.youku.com/playlist_show/id_23494296.html"&gt;CDGChina&lt;/a&gt; 加了中文字幕，并放在 &lt;a href="http://www.youku.com/playlist_show/id_23494296.html"&gt;Youku&lt;/a&gt; 上了。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition notes"&gt;
&lt;p class="admonition-title"&gt;Notes&lt;/p&gt;
&lt;p&gt;看来 Android 生态圈的性能和电量消耗等问题，已经严重到让 Google 不得不重视的地步啦 ~~&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="_2"&gt;关于内存的几个理论知识&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GC 的工作机制&lt;/strong&gt;&lt;br /&gt;
当 GC 工作时，虚拟机停止其他工作。频繁地触发 GC 进行内存回收，会导致系统性能严重下降。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存抖动&lt;/strong&gt;&lt;br /&gt;
在极短的时间内，分配大量的内存，然后又释放它，这种现象就会造成内存抖动。典型地，在 View 控件的 onDraw 方法里分配大量内存，又释放大量内存，这种做法极易引起内存抖动，从而导致性能下降。因为 onDraw 里的大量内存分配和释放会给系统堆空间造成压力，触发 GC 工作去释放更多可用内存，而 GC 工作起来时，又会吃掉宝贵的帧时间 (帧时间是 16ms) ，最终导致性能问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存泄漏&lt;/strong&gt;&lt;br /&gt;
Java 语言的内存泄漏概念和 C/C++ 不太一样，在 Java 里是指不正确地引用导致某个对象无法被 GC 释放，从而导致可用内存越来越少。比如，一个图片查看程序，使用一个静态 Map 实例来缓存解码出来的 Bitmap 实例来加快加载进度。这个时候就可能存在内存泄漏。&lt;/p&gt;
&lt;p&gt;内存泄漏会导致可用内存越来越少，从而导致频繁触发 GC 回收内存，进而导致性能下降。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调试工具&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Memory Monitor Tool: 可以查阅 GC 被触发起来的时间序列，以便观察 GC 是否影响性能。&lt;/li&gt;
&lt;li&gt;Allocation Tracker Tool: 从 Android Studio 的这个工具里查看一个函数调用栈里，是否有大量的相同类型的 Object 被分配和释放。如果有，则其可能引起性能问题。&lt;/li&gt;
&lt;li&gt;MAT: 这是 Eclipse 的一个插件，也有 &lt;a href="http://www.eclipse.org/mat/downloads.php"&gt;stand alone&lt;/a&gt; 的工具可以下载使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;几个原则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;别在循环里分配内存 (创建新对象)&lt;/li&gt;
&lt;li&gt;尽量别在 View 的 onDraw 函数里分配内存&lt;/li&gt;
&lt;li&gt;实在无法避免在这些场景里分配内存时，考虑使用对象池 (Object Pool)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_3"&gt;两个简单的实例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内存抖动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过一个非常简单的例子来演示内存抖动。这个例子里，在自定义 View 的 onDraw 方法里大量分配内存来演示内存抖动和性能之间的关系。&lt;/p&gt;
&lt;p&gt;版本一：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    &lt;span style="color: #AA22FF"&gt;@Override&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;protected&lt;/span&gt; &lt;span style="color: #00BB00; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00A000"&gt;onDraw&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;Canvas canvas&lt;span style="color: #666666"&gt;)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;super&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;onDraw&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;canvas&lt;span style="color: #666666"&gt;);&lt;/span&gt;

        String msg &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;;&lt;/span&gt;
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #00BB00; font-weight: bold"&gt;int&lt;/span&gt; i &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #666666"&gt;0;&lt;/span&gt; i &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color: #666666"&gt;500;&lt;/span&gt; i&lt;span style="color: #666666"&gt;++)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;i &lt;span style="color: #666666"&gt;!=&lt;/span&gt; &lt;span style="color: #666666"&gt;0)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
                msg &lt;span style="color: #666666"&gt;+=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;, &amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;;&lt;/span&gt;
            &lt;span style="color: #666666"&gt;}&lt;/span&gt;
            msg &lt;span style="color: #666666"&gt;+=&lt;/span&gt; Integer&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;toString&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;i &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;1);&lt;/span&gt;
        &lt;span style="color: #666666"&gt;}&lt;/span&gt;
        Log&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;d&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;DEBUG&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; msg&lt;span style="color: #666666"&gt;);&lt;/span&gt;
    &lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;版本二：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    &lt;span style="color: #AA22FF"&gt;@Override&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;protected&lt;/span&gt; &lt;span style="color: #00BB00; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00A000"&gt;onDraw&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;Canvas canvas&lt;span style="color: #666666"&gt;)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;super&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;onDraw&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;canvas&lt;span style="color: #666666"&gt;);&lt;/span&gt;

        StringBuilder sb &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;new&lt;/span&gt; StringBuilder&lt;span style="color: #666666"&gt;();&lt;/span&gt;
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #00BB00; font-weight: bold"&gt;int&lt;/span&gt; i &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #666666"&gt;0;&lt;/span&gt; i &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color: #666666"&gt;500;&lt;/span&gt; i &lt;span style="color: #666666"&gt;++)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;i &lt;span style="color: #666666"&gt;!=&lt;/span&gt; &lt;span style="color: #666666"&gt;0)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
                sb&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;append&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;, &amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;);&lt;/span&gt;
            &lt;span style="color: #666666"&gt;}&lt;/span&gt;
            sb&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;append&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;i &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #666666"&gt;1);&lt;/span&gt;
        &lt;span style="color: #666666"&gt;}&lt;/span&gt;
        Log&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;d&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;DEBUG&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; sb&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;toString&lt;/span&gt;&lt;span style="color: #666666"&gt;());&lt;/span&gt;
    &lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;内存抖动的特征：&lt;/p&gt;
&lt;p&gt;从 Memory Monitor 来看，有毛刺出现。即短时间内分配大量的内存并触发 GC。&lt;br /&gt;
&lt;img alt="memory_churn" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/memory_churn.gif" /&gt;&lt;/p&gt;
&lt;p&gt;从 Allocation Tracker 里看，一次操作会有大量的内存分配产生。&lt;br /&gt;
&lt;img alt="memory_tracker" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/memory_tracker.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存泄漏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个例子里，我们简单地让点击 Settings 菜单，就产生一个 100KB 的内存泄漏。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    &lt;span style="color: #AA22FF; font-weight: bold"&gt;private&lt;/span&gt; &lt;span style="color: #00BB00; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00A000"&gt;addSomeCache&lt;/span&gt;&lt;span style="color: #666666"&gt;()&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
        &lt;span style="color: #008800; font-style: italic"&gt;// add 100KB cache&lt;/span&gt;
        &lt;span style="color: #00BB00; font-weight: bold"&gt;int&lt;/span&gt; key &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;new&lt;/span&gt; Random&lt;span style="color: #666666"&gt;().&lt;/span&gt;&lt;span style="color: #BB4444"&gt;nextInt&lt;/span&gt;&lt;span style="color: #666666"&gt;(100);&lt;/span&gt;
        Log&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;d&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;sfox&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;add cache for key &amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; key&lt;span style="color: #666666"&gt;);&lt;/span&gt;
        sCache&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;put&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;key&lt;span style="color: #666666"&gt;,&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;new&lt;/span&gt; &lt;span style="color: #00BB00; font-weight: bold"&gt;byte&lt;/span&gt;&lt;span style="color: #666666"&gt;[102400]);&lt;/span&gt;
    &lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;内存泄漏的特征：&lt;/p&gt;
&lt;p&gt;从 Memory Monitor 来看，内存占用越来越大&lt;br /&gt;
&lt;img alt="memory_tracker" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/memory_leak.png" /&gt;&lt;/p&gt;
&lt;p&gt;利用 &lt;a href="http://www.eclipse.org/mat/downloads.php"&gt;MAT&lt;/a&gt; 工具进行专业分析。这是个很大的话题。几乎可以独立成几个章节来讲。可以参阅 MAT 本身自带的 Tutorials 来学习。另外，&lt;a href="http://android-developers.blogspot.hk/2011/03/memory-analysis-for-android.html"&gt;这篇文章&lt;/a&gt;里的分析方法是个不错的开始。&lt;/p&gt;
&lt;p&gt;示例代码使用 Android Studio 开发环境，可以从&lt;a href="http://pan.baidu.com/s/1sj3Exsx"&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;h3 id="mat"&gt;利用 MAT 分析内存问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内存泄漏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个典型的问题是 Android 系统越用越慢。这种典型地是由内存泄漏引起的。一个很有用的解决这种问题的办法是：比较前后两个阶段的内存的使用情况。一般流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用 ddms 工具 dump HPROF file&lt;/li&gt;
&lt;li&gt;利用 hprof-conv 把 dalvik 格式的转换为普通 jvm 格式&lt;/li&gt;
&lt;li&gt;重复步骤 1 和 2 抓出两份 LOG。&lt;/li&gt;
&lt;li&gt;利用 MAT 对两份 HRPOF 文件进行分析，结合代码找出可能存在的内存泄漏&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如针对拨号盘越来越慢的问题，我们可以开机后启动拨号盘，打进打出10个电话。然后抓个 HPROF 文件。接着，再打进打出10个电话，再抓一个 HPROF 文件。接着拿这两个文件对比分析，看是不是会造成电话打进打出越多，内存占用越多的情况发生。&lt;/p&gt;
&lt;div class="admonition notes"&gt;
&lt;p class="admonition-title"&gt;HPROF文件&lt;/p&gt;
&lt;p&gt;HPROF 简单地理解，就是从 jvm 里 dump 出来的内存和 CPU 使用情况的一个二进制文件。它的英文全名叫 A Heap/CPU Profiling Tool。&lt;a href="http://docs.oracle.com/javase/7/docs/technotes/samples/hprof.html"&gt;这里&lt;/a&gt;有它完整的官方文档和它的历史介绍。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;打开 MAT 后，会有一个 Tutorials 来教大家怎么用。这里列出几个操作步骤及其注意事项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 DDMS 里导出 HPROF 文件前，最好手动执行一下 GC。目的是让导出的内存全部是被引用的。否则在做内存占用对比时，会有很多不必要的内存占用被标识出来，干扰我们进行分析。&lt;/li&gt;
&lt;li&gt;进行对比时，最好是选择操作较多的和操作较少的对比，这样得出的 delta 是正数&lt;/li&gt;
&lt;li&gt;通过对比，发现内存泄漏时，可以用 OQL 来查询，并通过 Root to GC 功能来找到发生泄漏的源代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我们的示例程序里面，每次点击 Settings 菜单，都会导致一次100KB的内存泄漏。下面是我们利用上面介绍的流程来查找内存泄漏问题。我们先点击 5 次 Settings 菜单，然后手动触发一次 GC，再导出 HPROF 文件。接着，我们再点击 6 次 Settings 菜单，然后手动触发一次 GC，再导出第二份 HPROF 文件。我们拿这两份 HPROF 就可以做一些对比。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mat_diff.png" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/mat_diff.png" /&gt;&lt;/p&gt;
&lt;p&gt;通过上图可以看到，两次操作确实导致了某些类的实例增加了。图中可以清楚地看到 byte[] 和 java.util.HashMap$HashMapEntry 两个类增加得比较明显。这样，我们随便选择一个，通过 OQL 来查询系统中的这个内存。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mat_qql.png" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/mat_qql.png" /&gt;&lt;/p&gt;
&lt;p&gt;从上图可以找到，本次 dump 出来的内存里，确实有很多个这个类的实例。在图上右击任何一个实例，右击，选择 &lt;code&gt;Paths to GC roots&lt;/code&gt;，可以找到这个实例是被谁引用的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mat_gc_root.png" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/mat_gc_root.png" /&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出来，这个内存是被 MainActivity 里的 sCache 引用的。通过阅读代码，我们就可以找到这个漏洞了。即每次都往 sCache 里保存一个引用。&lt;/p&gt;
&lt;h3 id="_4"&gt;总结&lt;/h3&gt;
&lt;p&gt;Google 视频介绍的内容是硬知识，了解这些知识可以帮助我们写出高质量，高性能的代码。而 MAT, HPROF, Memory Monitor, Allocation Tracker 提供了一个“破案”的工具给我们。我们利用这些工具，倒回来去发现代码里的问题。&lt;/p&gt;
&lt;h3 id="_5"&gt;延伸阅读&lt;/h3&gt;
&lt;p&gt;关于 Android 性能优化，网络上有几篇比较好的文章，基本按照 GOOGLE 的官方教程翻译过来的，质量比较高。可以参考一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://hukai.me/android-performance-memory/"&gt;Android 性能优化内存篇&lt;/a&gt;－&lt;a href="http://hukai.me"&gt;胡凯的博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hukai.me/android-performance-patterns/"&gt;Android性能优化典范&lt;/a&gt;－&lt;a href="http://hukai.me"&gt;胡凯的博客&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;冷知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GC 是在 1959 年由 John McCarthy 发明的，此发明是为了解决 Lisp 编程语言里的内存问题的。&lt;a href="http://book.douban.com/subject/6021440/"&gt;《黑客和画家》&lt;/a&gt;作者，硅谷最有影响力的孵化器公司 YC 创立者 Paul Graham 高度评价 Lisp 语言，认为编程语言发展到现在，还是没有跳出 Lisp 语言在上世纪 60 年代所倡导的那些理念。并且，他还把自己当初创业，实现财务自由的项目 Viaweb 的成功归功于 Lisp 语言。详细可阅读 Paul Graham 的&lt;a href="http://www.paulgraham.com/hundred.html"&gt;这篇博客&lt;/a&gt;和&lt;a href="http://www.paulgraham.com/diff.html"&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;</summary><category term="android"></category></entry><entry><title>《欲望之源》读书笔记</title><link href="http://blog.kamidox.com/mean-genes-notes.html" rel="alternate"></link><updated>2015-03-27T23:30:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-03-27:mean-genes-notes.html</id><summary type="html">&lt;h3 id="_1"&gt;有趣&lt;/h3&gt;
&lt;p&gt;这是本有趣的书。最了不起的地方是把我们身上种种难以忍受的缺点，从基因进化的角度给出了合理地解释，让我们了解到这些缺点不但不讨厌，而且还在人类漫长的进化过程中，帮助我们从残酷地竞争中生存了下来。&lt;/p&gt;
&lt;p&gt;为什么我们对美食没有抵抗力？为什么存钱这么困难？为什么香烟，可卡因让人难以割舍？为什么我们能从冒险中找到刺激？为什么人生来就贪得无厌，不知满足？为什么男女有别？男人什么时候最容易出轨？女人为什么会红杏出墙？为什么我们会爱我们的家人？为什么人生下来就是自私的？&lt;/p&gt;
&lt;p&gt;没错，我们就是这些问题人类的一份子。这是我们的基因为了完成他的终极目标而设计的一整套系统，我们就是个基因系统的载体，只有符合这套系统的基因才能得到终极大奖：复制。&lt;/p&gt;
&lt;p&gt;我们的祖先大部分时间都生活在饥寒交迫中，遇到卡路里，总是想办法尽最大的努力把它们吃到肚子里，变成脂肪储存到肚子或大腿，以便能捱过食物短缺的艰辛。我们生活在物质极大丰富的工业社会，但我们的基因还停留在山顶洞时期，时刻指导着我们的大脑储存卡路里。在进化的早期，类人猿从相对安全的树上走到要面对凶猛野兽的威胁的平原，我们在冒险。我们从山洞里走出来，走出非洲，向欧洲和亚洲迁移，跨过白令海峡，到达北美，进入南美。我们就是这些爱冒险的远古人的后代，我们从他们身上继承了爱冒险的基因。那些不爱冒险的远古人，无法适应环境的变化，在进化过程中被淘汰掉了，他们的基因没有机会得到复制。我们总是倾向把赚来的钱全部花掉，因为基因认为在他那个年代，没有冰箱和银行，所有的财富就是吃到肚子里的食物，那些没有马上消费掉的食物，最终会成为秃鹰的食物。我们明知道彩票中奖概率低得离谱，比被雷电击中的概率还要低N倍，但我们还是乐此不彼地买彩票，因为我们的祖先生活范围很小，最多几百人的规模，看到别人中奖，我们的基因根据他过往的经验，总是高佑了自己的中奖概率。看到蛇，不管有没有毒，总是让我们紧张害怕，而面对更危险的枪，我们却没有害怕的感觉。基因根据它的老经验，在他生活的年代，被蛇咬死的人占了很高的比例，而他不了解的是，在现代社会，枪才是致命地武器，一年中被蛇咬死的人的数量还不足死在枪口下的人的数量的万分之一。&lt;/p&gt;
&lt;p&gt;基因自私且聪明，它利用多巴胺等“快乐神经传递素”作为激励，控制着情绪系统，操纵着我们按照他们的意图行事。我们是成了基因的傀儡，所有的行为都指向了唯一的终极目标：基因复制。&lt;/p&gt;
&lt;h3 id="_2"&gt;救赎&lt;/h3&gt;
&lt;p&gt;这是一本自我救赎的书。我们的所有缺点，都是我们可爱的基因为了完成自我复制耍的小把戏。我们所有的缺点，都是因为我们的基因进化跟不上环境变化导致的一系列误会。我们戴上了智慧的眼镜，看透了它。坦然接受了这些缺点，在需要的时候，我们也可以耍点小聪明戏弄一下基因。你要去一次食物丰盛的应酬，但又不想给肥胖的身体增加负担，可以在去之前吃两个馒头下去。想要体验血脉喷张的刺激，不需要再去体验狮口脱脸了，坐个过山车依然可以让你的肾上腺素激烈上扬。&lt;/p&gt;
&lt;p&gt;作为基因载体的人，从进化角度，基因给我们定义了角色，其终极目标是为了完成基因复制。作为有自由意志的个体的人，我们想定义自己的角色，而不愿意成为基因的傀儡，我们的一生，在进化的历史进程中实在短得不值一提。通过这本书，我们明白了我们在进化历史上的角色，让我们看透基因的小把戏，让我们更好地定义作为自由意志的个体的角色。&lt;/p&gt;
&lt;p&gt;正如本书导言所写：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最大的敌人是自己&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知己知彼，虽不一定百战百胜，既然注定了这是一场长期的战争，至少让我们有机会了解一下驻扎在我们体内的基因敌人。&lt;/p&gt;
&lt;h3 id="_3"&gt;今日推荐&lt;/h3&gt;
&lt;p&gt;推荐&lt;a href="http://mindhacks.cn"&gt;刘未鹏的博客&lt;/a&gt;以及他的一本书&lt;a href="http://book.douban.com/subject/6709809/"&gt;《暗时间》&lt;/a&gt;。关于编程，心理学，方法论。你会惊叹作者的思考深度。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>福流理论</title><link href="http://blog.kamidox.com/flow-experience.html" rel="alternate"></link><updated>2015-03-22T23:24:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-03-22:flow-experience.html</id><summary type="html">&lt;h3 id="_1"&gt;福流体验&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;人们对快乐的追求是为了快乐本身，而对其他所有的目标 - 比如健康，金钱，权力等，却是只有在我们认为会让自身快乐时才会得到重视。&amp;mdash; 米哈里·奇克森特米哈伊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;米哈里·奇克森特米哈伊 (&lt;a href="http://en.wikipedia.org/wiki/Mihaly_Csikszentmihalyi"&gt;Mihaly Csikszentmihalyi&lt;/a&gt;) 为感到快乐的境界想出了一个新的词汇来形容，他将此称为&lt;strong&gt;福流体验&lt;/strong&gt; (&lt;a href="http://zh.m.wikipedia.org/wiki/心流理論"&gt;Flow Experience&lt;/a&gt;)。根据米哈里·奇克森特的研究，能产生沉浸或心流体验的活动通常具备以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;专注&lt;/strong&gt;：密切地专注于某件活动&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自主&lt;/strong&gt;：这些活动是我们自己的选择&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挑战&lt;/strong&gt;：这项活动难度不能低到让我们感到无聊，也不能高到让我们过劳而无所适从&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标明确&lt;/strong&gt;：这项活动必须具备明确的目标&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;即时反馈&lt;/strong&gt;：活动的成果必须得到立即反馈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;置身于&lt;strong&gt;沉浸心流&lt;/strong&gt;体验的人们，不但会感觉到深深的满足，也会无视时间的流逝，而且会因为手中的工作而彻底忘记了自己。这些人沉浸于往往会让人筋疲力尽的工作时，反倒是他们最快乐的时候。&lt;/p&gt;
&lt;h3 id="_2"&gt;福流模型&lt;/h3&gt;
&lt;p&gt;程序员是幸福的，我想不出有比程序员更容易产生沉浸体验的工作了。唯一的问题似乎是在工作难度上。如果你是个程序员，但没有体验到沉浸心流，问题多半是出现在工作难度和你的能力上，下图是米哈里·奇克森的福流模型 (flow model):&lt;/p&gt;
&lt;p&gt;&lt;img alt="flow model" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Challenge_vs_skill.svg/600px-Challenge_vs_skill.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;上述模型可以发现很有意思的推论。做相同难度的工作，个人能力的高低会影响情绪体验。比如，对于长期从事&lt;strong&gt;低挑战性&lt;/strong&gt;的工作的人，如果个人能力较低，较容易产生&lt;a href="http://en.wikipedia.org/wiki/Apathy"&gt;冷淡 (Apathy)&lt;/a&gt;情绪体验，而个人能力较高时，却是产生&lt;a href="http://en.wikipedia.org/wiki/Relaxation_(psychology)"&gt;消遣 (Relaxation)&lt;/a&gt; 体验。想起了&lt;a href="http://www.douban.com/note/356146835/"&gt;渔夫和富翁晒太阳&lt;/a&gt;的笑话，虽然最终大家都在晒太阳，但晒太阳时产生的情绪体验是不一样的。如果一个事情让你很痛苦，想想看是自己能力不足还是能力过剩。&lt;/p&gt;
&lt;h3 id="_3"&gt;个人体验&lt;/h3&gt;
&lt;p&gt;我有一次较深刻的时间跨度较长的福流体验大概是在2006年，那个时候我在做一个 side project：用 C 语言实现手机上的浏览器，彩信，电子邮件客户端，目标是在各个功能手机平台上通用。这一目标在那个时候面临的挑战不小。主要手机开发环境不象现在的智能手机这样规范。MTK，TI，朗讯和展讯等平台的图形系统千差万别，类似现在苹果和 Android 的差别。系统框架层也比较弱，大部分系统只提供 TCP/IP 接口，连 HTTP 协议都没有。所幸，基本所有平台都是基于 C/C++ ，所以 C 语言基本可以通吃。为实现这样的目标需要做以下几个事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一套可移植的的轻量级的图形系统&lt;/li&gt;
&lt;li&gt;系统基础设施及其封装。如文件系统接口封装，基础图形原语封装，内存管理算法，BASE64 编解码等&lt;/li&gt;
&lt;li&gt;基础网络协议。包括 HTTP 协议，WSP/WTP 协议，SMTP/POP3/IMAP 协议，XML 解析等&lt;/li&gt;
&lt;li&gt;应用协议。MMS 解析和打包，RFC822/RFC2822 Message 解析和打包，HTML 解析和渲染等&lt;/li&gt;
&lt;li&gt;内存及性能。特别是内存，那个时候整个浏览器一般只能使用不超过 2MB 的内存。我试验过在浏览像新浪这种将近 200KB 的 HTML 网页时只使用不到 2MB 的内存，当然，只支持 HTML，不支持 JavaScript&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那个时候刚毕业 2 年多，工作中一直在接触网络协议，在阅读 GNU 的一些开源代码。而这一 side project 在当时看起来也比较有市场需求，因为很多手机公司都从供应商处购买浏览器/彩信软件，授权费达到1刀每台。在这样的背影下，我每天写代码到零晨 2-3 点，第二天一大早照样精神抖擞地挤公交去上班。那个时候其实不是真正想写代码到 2-3 点，而是写着写着不知不觉就到那个点了，只好很不情愿地去睡觉。每天看着自己脑中的蓝图一点地画出来，这是最好地即时反馈系统。那个时候我女朋友 (现在的老婆) 很不理解我的行为，也心疼，觉得我这样太累了。但我觉得那段时间真的是我最快乐的时光。我甚至到现在都无法想象那个时候的我有那么强的耐心和定力。&lt;/p&gt;
&lt;p&gt;那个时候，经常对女朋友说，以后买房子就靠这个软件了。当然最终证明这是个笑话，不是软件没做出来，而是世界变化太快，智能手机把功能手机赶出了历史舞台。最终这个软件除了给我积累了一点吹牛的素材外，其实还是有两个很大的价值，一是让我有了福流体验，二是造了这么多轮子，让我编程的基本功有了长足的进步。&lt;/p&gt;
&lt;h3 id="_4"&gt;今日推荐&lt;/h3&gt;
&lt;p&gt;推荐一个程序员的微信公众号&lt;a href="http://zhuanlan.zhihu.com/prattle"&gt;程序人生&lt;/a&gt;，微信搜索 programmer_life 可以关注。篇篇原汁原味，关于技术，关于管理。&lt;/p&gt;</summary></entry><entry><title>除了编程语言，程序员还需要知道哪些东西</title><link href="http://blog.kamidox.com/more-than-programe-languages.html" rel="alternate"></link><updated>2015-03-13T23:34:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-03-13:more-than-programe-languages.html</id><summary type="html">&lt;p&gt;最近在讨论 2015 年的团队培训计划问题，Quora 上的&lt;a href="https://www.quora.com/What-are-the-things-that-a-programmer-must-know-obviously-besides-programming-languages"&gt;一篇文章&lt;/a&gt;给了我不少启发。排行第一的回答中有几个很有意思的见解。&lt;/p&gt;
&lt;h3 id="_1"&gt;抽像思维能力&lt;/h3&gt;
&lt;p&gt;作者认为这是程序员最重要的能力。我们在编程时，用到的都是一些抽像的概念。作者认为应该把培养抽像思维能力作为平时练习最重要的事情长期做下去。&lt;/p&gt;
&lt;h3 id="_2"&gt;问题分解能力&lt;/h3&gt;
&lt;p&gt;现实编程时，我们要解决的问题往往都比较大，比较复杂。怎么样把复杂的大问题分解成一个个小问题，再逐个去解决这些小问题。这个就是问题分解能力。缺少问题分解能力的人，拿到问题时总会没有思路，因为他们不懂地把问题分解成一个个简单地可解决的问题。&lt;/p&gt;
&lt;h3 id="_3"&gt;模式识别&lt;/h3&gt;
&lt;p&gt;作者举了个笑话：在一个程序员的面试过程中，面试官问被试者，微波炉着火了怎么办？被试者说把微波炉扔到窗外。面试官继续问如果咖啡机着火了怎么办？被试者说把咖啡机装在微波炉里，然后扔到窗外。&lt;/p&gt;
&lt;p&gt;这里作者想提的其实是一种问题转换的思路。把遇到的一个问题分解后，把子问题使用已经有成熟解决方案的方法来解决。其实模式识别就是抽像思维的一种。我在教女儿算数时，就用了这个方法，我先问她你有三个苹果，妈妈吃掉一个还剩下几个。等她理解后，再问她你有三个桃子，妈妈吃掉一个还剩下几个。所以，实际上我是在教我女儿抽像思维的能力，问题的重点不是苹果或桃子，而是三和一。&lt;/p&gt;
&lt;h3 id="_4"&gt;判断代码质量的能力&lt;/h3&gt;
&lt;p&gt;这里作者讲的是不要过早，过度去优化代码，不要片面去追求完美解决方案。代码的性能和质量要和问题的复杂度相当。&lt;/p&gt;
&lt;p&gt;怎么样去判断代码的质量和效率刚刚好呢？作者没有提，我觉得这个需要有一些 benchmark 工具来测量以及实际使用来衡量。在这一点上，其实我比较少看到程序员犯这方面的毛病，看到更多的是完全没有优化或没去思考性能问题的低级错误。&lt;/p&gt;
&lt;h3 id="_5"&gt;练习&lt;/h3&gt;
&lt;p&gt;练习，练习，练习。没有捷径。10000 小时理论在编程这件事情上一定是真理。可能有天才，但只要你不是特别笨，在一个细分领域持续练习，投入时间，一定会成为专家。当然，这里有些人是工作一年，学了三年的经验，有些人是工作了五年，只学了一年的经验。&lt;/p&gt;
&lt;h3 id="_6"&gt;基本原理&lt;/h3&gt;
&lt;p&gt;这条是我加的。当学会用 Java 读写文件后, 不管是 Swift 还是 Python ，他们的读写文件的方法都类似。当熟练使用 Java 的多线程编程，并且理解线程的运作方式之后，要用其他语言实现多线程编程，只需要查看 API DOC 很快就可以写出多线程代码。通过学习 Flask，理解 template, orm, auth, memcached, migration, forms 等 web 开发模型的概念和原理之后，再学习 Django 框架，你会觉得所有的东西都这么熟悉并且相似。类似的概念还有网络编程，内存管理，进程间通信，设计模式等等。新技术层出不穷，但基本原理却发展异常缓慢，而且基本保持不变。&lt;/p&gt;
&lt;h3 id="_7"&gt;今日推荐&lt;/h3&gt;
&lt;p&gt;那么问题来了，怎么样提高这些能力呢？作者没有给出答案。&lt;a href="https://www.hackerrank.com"&gt;hackerrank&lt;/a&gt; 是个不错的选择，长期练习一些有趣的算法题是对这些能力的培养很有帮助。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>知易行难</title><link href="http://blog.kamidox.com/easy-to-understand-while-hard-to-apply.html" rel="alternate"></link><updated>2015-01-08T23:24:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-02-26:easy-to-understand-while-hard-to-apply.html</id><summary type="html">&lt;p&gt;网上流传一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;懂得很多道理，却依然过不好这一生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讲的就是知易行难。《闻香识女人》里也有一句经典的台词：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我知道哪条路是正确的，不要问我为什么知道，我就是知道。但我就是不想走，因为太他妈的难了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们生活中也经常有这样的体验。我们明知道要做好一个产品，必须深挖用户体验和产品细节，但实际工作中，却经常做一些非理性妥协。我们明知道要维护好一个博客，必须长期坚持写有价值的文章，但实际上能坚持思考，坚持写作的人少之又少。我们明知道要提高技术能力，必须多看多练，经过时间的积累逐步提高，但往往在现实生活中，我们总是希望找到快速提高技术能力的捷径，恨不得一天吃成胖子。我们明知道情绪控制的方法是，遇到情绪时用觉察去代替抵抗，但往往情绪一上来，就本色表演，根本谈不上控制和思考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感性大脑和理性大脑&lt;/strong&gt;&lt;br /&gt;
刘未鹏在《暗时间》里有一篇文章《遇见20万年前的自己》系统地谈了这个问题。感性大脑在人类进化的早期阶段形成的，主要控制情绪，并根据情绪去指导人类的行为，比如遇见狮子，会害怕，进行产生规避这种危险的逃跑行为。而理性大脑是新近进化出来的大脑皮层。主要负责逻辑思维和理性分析。我们可以把感性大脑和理性大脑理解成大脑中的两个有独立人格的自己。他们经常意见不一致，当意见不一致时，你会觉得痛苦，最终要么感性大脑说服理性大脑，要么理性大脑说服感性大脑，让他们的认识统一，才能避免痛苦。现实生活中，有冲突时，感性大脑往往会战胜理性大脑。比如我们知道保持规律地运动对身体健康很有好处，但如果你的感性大脑没有体验到运动带来的成就感和快乐，那么即使你的理性大脑强迫你去跑步，也难以长期坚持下去。&lt;/p&gt;
&lt;p&gt;另外，由于感性大脑是人类进化早期形成的，经过长时间的使用，其神经通路比较宽，信号传递比较快，可以理解成其 CPU 频率比较高。而理性大脑是人类进化过程中新近形成的，其神经通路比较窄。往往一个事情，感性大脑会先反映过来，然后马上去指导行动，接着理性大脑才慢吞吞地把他的计算结果反馈上来。古语有云：三思而后行，其实就是告诫大家给你的理性大脑留点时间思考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;训练&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;知&lt;/strong&gt;表示理解和认同，要从&lt;strong&gt;知&lt;/strong&gt;到&lt;strong&gt;行&lt;/strong&gt;，中间还有很长的路要走。学过数学的人都知道，看到一个定理的证明过程时，觉得证明得好巧妙，你已经完全理解了他的来龙去脉。过一小段时间，让你来重新证明一遍，你很有可能证明不出来。另外一个例子是学编程语言，看教科书或视频教程时，觉得全部都理解了，关闭教科书或视频后，让你重新把里面的例子程序写出来，大部分人是写不出来的。所以某件事情你达到了&lt;strong&gt;知&lt;/strong&gt;的程度，其实这些知识还只是表层，还是别人的，不是你自己的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知&lt;/strong&gt;怎么转化为&lt;strong&gt;行&lt;/strong&gt;呢？答案是训练，通过训练让这些知识变成你自己的。还是编程的例子，如果你看视频学编程，边看边记，关闭视频后，通过回忆关键知识点把视频里的例子程序自己输入进去。如果忘记，重新打开视频查看。输入一遍后运行成功后。再自己创造一个类似的问题，不借助视频解决它。下次在实际产品开发的过程中，你很容易就能想起视频教程里针对某个总是的解决方案，进而运用这个解决方案来解决问题。&lt;/p&gt;
&lt;p&gt;上面的视频编程的例子里，不单单是记忆问题。他的模式是&lt;strong&gt;知&lt;/strong&gt;后，强迫自己通过&lt;strong&gt;行&lt;/strong&gt;来强化&lt;strong&gt;知&lt;/strong&gt;。进而转化为自己的知识。哈佛公开课《幸福课》里有个形象的比喻，人的思维模式就像河流，当河流里流过的水越多，时间越长，河道就越宽，下次发洪水时，都会优先从比较宽的河道里流过。这里的关键点是&lt;strong&gt;多&lt;/strong&gt;和&lt;strong&gt;长&lt;/strong&gt;，通过有意识地长期训练，我们可以把某个我们认知的道理固化到大脑里，升级成自己的认知模式。下次遇到问题时，就会优先运用这个认知模式来解决问题。这也解释了为什么我们的感性大脑往往比理性大脑反映更快。感性大脑在人类进化过程中最先出现，经过长时间的强化，这个“河道”很宽，“洪水”发生时，就会最先就从这个“河道”里流过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;冥想&lt;/strong&gt;&lt;br /&gt;
改变是困难的。假设那个宽的河道是你原来的思维模式，而窄的河道是你的理性大脑认可的思维模式。想像一下，洪水发生时，有两个河道，一个宽，一个窄，你要控制让水多往窄的河道流是，这是一件很困难的事情。是一定需要外力干涉的。&lt;/p&gt;
&lt;p&gt;改变是可能的。假设我们能控制我们的思维，那么通过有意识地让洪水多流一点到窄的河道上，长期坚持下去，窄的河道的变宽速度就会比宽的河道快，久而久之，窄的河道就会变得比宽的河道宽，从而你的理性大脑战胜了你的感性大脑。干涉的途径就是控制你自己的思想，有意识地让洪水多流向窄的那个河道。通过冥想，我们可以训练控制自己思维的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;br /&gt;
知易行难其实是我们的天性决定的。把知转化为行是可能的，但需要付出很多的努力。我见过一些很聪明的人，他们思维转得特别快，一个事情一下子就看到本质，出的招也是招招打到蛇的七寸。他们可以很理性地控制住自己的感性大脑，或许他们代表的就是我们人类的进化方向吧，他们进化地比较快罢了。我们也可以通过训练来加快我们的进化速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;br /&gt;
今天推荐一个国内的 Android 开发者都会喜欢的网站&lt;a href="http://www.androiddevtools.cn"&gt;androiddevtools.cn&lt;/a&gt;。不管你是用 Windows/Linux/Mac 都可以在这上面下载全套的 Android 开发工具，而且速度非常快。而且网站上还有很多优秀的设计资源和开发资料。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>从导游身上学管理</title><link href="http://blog.kamidox.com/learn-from-tour-guide.html" rel="alternate"></link><updated>2015-02-25T23:26:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-02-25:learn-from-tour-guide.html</id><summary type="html">&lt;p&gt;春节期间和老婆跟团走了一趟云南，认真观察了一下导游，发现可以从他们身上学到很多管理技能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义规则&lt;/strong&gt;&lt;br /&gt;
一上车，就和大家套近乎，拉家常，活跃氛围。这些外围工作做完，就开始定义规则，小到车厢卫生，大到一些安全注意事项等。全部说明一遍，并且每个规则都举一个某次带团的的例子作为案例来加深印象。比如，某游客把榴莲带到车上吃，导致全车几天都有一股臭味，再比如某游客一上车就把鞋子脱了，再如某游客旅游到酒吧喝酒和当地人冲突等等，不一而足。&lt;/p&gt;
&lt;p&gt;只有把规则定义清楚了，所有的成员才知道什么是团队鼓励的，什么是团队不允许。这对团队价值导向，以及奖赏打下了基础。管理一个公司或团队不也是这个道理么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树立权威&lt;/strong&gt;&lt;br /&gt;
利用介绍自己以及自己所在的旅游公司的机会，给自己树立了很好地权威。一上来就介绍旅游局的一些法律法规，投诉电话。其中介绍到班车的车牌号时印象特别深刻：“大家知道我们的车牌号是云ALXXXX，L是旅游专用车，外面一个牌照50W+。如果大家随便在小店报个很便宜的团，肯定不是用旅游专用车，那么你的所有权益是得不到保障的”。“大家出来玩，我是来工作的。我希望大家配合我的工作，我说句不客气的话，大家这几天玩得开不开心，完全掌握在我手中，我做得好一点事情，你们可以少踩很多坑，少吃很多亏，毕竟我是当地人，对这里的情况非常熟悉 balabala &amp;hellip;”。&lt;/p&gt;
&lt;p&gt;这些树立威信地做法，很好地把游客可能存在的一些不合理的想法甚至是合理的想法全部扼杀在摇篮里。带团队不就是这样的吗？有了规则后，还要让大家知道，这些规则我是有能力保障它得到贯彻执行的！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小题大作&lt;/strong&gt;&lt;br /&gt;
第一天早上集合，有个家庭迟到了5分钟。导游板着脸点名批评。“大家想想看，如果你迟到5分钟，全车人都在等你，几十个人加起来是多长时间？下次如果有人迟到超过10分钟，你自己想办法坐车到我们下个地点和大家汇合！”&lt;/p&gt;
&lt;p&gt;这种利用第一次的小错误来杀鸡儆狗，确实有效。后面整个团队时间观念都很强。从小事着手，从小事树立规则的权威性。这对团队建设非常重要。不单如此，有时候和供应商沟通也需要会小题大作。比如遇到一个问题，需要协调供应商解决，如果你把问题的严重程度和紧迫感放大十倍，然后想办法把放大了之后的严重性和紧迫感传达给供应商，基本上能收到事半功倍的支持效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;收买人心&lt;/strong&gt;&lt;br /&gt;
在大家坐车的无聊时光里，导游确实还是讲述了不少当地的一些习俗以及一些陷阱，特别是那些陷阱，听起来帮助确实是很大。比如在丽江，街上有人找你绑彩辫，不要去绑，因为其实那是纳西族的“寡妇头”。再比如，打车的时候，黄金周大部分的士是不打表的，价格是平常的两倍，但正常在30元以内，超过30块一定要讲价。诸如此类的 TIP 很多，大家都感觉这个导游很值得依赖。&lt;/p&gt;
&lt;p&gt;管理团队也是类似的道理，需要从细节，从团队成员的切身利益出发，做出切切实实对团队成员有利的事，最大化公司和个人的共同利益，争取信任感。团队成员之间只有相互信任，才能走得更远，走得更长久。如果只有大棒，没有胡萝卜，一定是没法带好团队的。&lt;/p&gt;
&lt;p&gt;总结的这些虽然有点厚黑学的味道，但其实从人性的角度还是很容易解释得通的。另外一个收获是成功说服老婆，以后旅游绝不报团了。老婆是路痴，对自由行非常没安全感。通过这次不断地演绎导游的话中话，包括一些推销的伎俩，结合路途中跟团的种种不便，成功说服老婆以后绝不报团。我总结起来，报团除了行程上不自由，还有一点我无法忍受，就是在整个过程中，有时&lt;strong&gt;明明知道导游把大家当猴耍，但你还要配合着他当猴让他来耍&lt;/strong&gt;。除非你真去投诉或闹得不愉快。而且这样的较真也确实没必要，很多事情是潜规则，是导游们吃饭的技能，赤祼祼地揭穿他显得很不人道，不揭穿他又觉得自己是傻子。&lt;/p&gt;
&lt;p&gt;惹不起咱就躲呗！下次一定自由行。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>Macbook Pro 初体验</title><link href="http://blog.kamidox.com/macbookpro.html" rel="alternate"></link><updated>2015-01-22T00:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-01-22:macbookpro.html</id><summary type="html">&lt;p&gt;长这么大，终于奢侈了一把，入手了 Macbook Pro。虽然我远不是果粉，对 IPhone 和 IPad 也不感冒，但还是被 Macbook Pro 震撼到了。是的，我确认用&lt;strong&gt;震撼&lt;/strong&gt;这个词&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;做工太精细了&lt;br /&gt;
   老婆买过 IPhone 和 IPad，但没有打动我。而 Macbook Pro 的外观和质感确实非常赞。&lt;/li&gt;
&lt;li&gt;屏幕显示效果&lt;br /&gt;
   简单地说，看完 Macbook Pro 的显示效果后，再看别的电脑简直不忍直视。&lt;/li&gt;
&lt;li&gt;超级便捷的触摸板&lt;br /&gt;
   简单学习触摸板的一些操作后，就很容易爱上它。甚至觉得鼠标都是多余的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Windows 自不必说，玩过比较久的 Ubuntu ，刚一进入 OS X 操作系统还是要习惯一下，不过还好，基本花两小时就可以习惯这些操作了。总结起来无非就是下面一些内容。&lt;/p&gt;
&lt;p&gt;Windows/Ubuntu 上的一些系统设施 Macbook Pro 上没有，但有一些简单的替代：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;鼠标右键：双指点击触控面板即可。不过这项需要进 System Preference 设置一下。&lt;/li&gt;
&lt;li&gt;Home 键：Command + Left&lt;/li&gt;
&lt;li&gt;End 键：Command + Right&lt;/li&gt;
&lt;li&gt;Page Up 键：Command + Up&lt;/li&gt;
&lt;li&gt;Page Down 键：Command + Down&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;输入法，我用搜狗五笔，感觉还不错，比系统内置的好用。&lt;/p&gt;
&lt;p&gt;之前没有用过 OS X 系统，只是在网上找了一些文章大概看了一下，学习怎么安装软件之类的。试用了几个小时还是感受到了乔帮主的无穷魅力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快速搜索&lt;br /&gt;
   Control + Space 可以快速唤出 Sportlight Search，可以快速查找文档或打开应用程序&lt;/li&gt;
&lt;li&gt;自动关闭屏幕&lt;br /&gt;
   进入 System Preference -&amp;gt; Mission Control -&amp;gt; Hot Corners &amp;hellip; ，选一个屏幕角落设置为 &lt;code&gt;Put Display to Sleep&lt;/code&gt; ，这样如果想省电，要关闭屏幕显示时，直接把鼠标移到屏幕的那个角落屏幕就自动关闭了。&lt;/li&gt;
&lt;li&gt;打开 Launchpad&lt;br /&gt;
   用大拇指和其他三个手指在触控屏上从外往内一收，就可以唤出 Launchpad。&lt;/li&gt;
&lt;li&gt;Safari 的一些快捷操作&lt;br /&gt;
   双指在触控板上上下滑动，可以上下滚动网页，类似鼠标的滑动轮。双指向右滑动，可以后退。大拇指加两个手指向内收，可以快速看到打开的所有 Tab 页，并在网页之间切换。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际上，几个小时的使用，感受远不止这些。慢慢发现吧，我给自己定的规矩是，认真使用，探索 OS X 与众不同的东西。OS X 里能替代之前在 Windows/Ubuntu 里的软件都探索一遍，去发现 Apple 的设计哲学。在网上看到很多人买了 Macbook 后安装 Windows 7 使用，这得多装逼才能干出这种事啊。&lt;/p&gt;
&lt;p&gt;几个 TIPS ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;购买 Macbook Pro 时，可以上苹果官网直接购买，选择教育类优惠。大概可以便宜 700 大洋。而且还支持信用卡分期付款。&lt;/li&gt;
&lt;li&gt;打开 System Preference 看一遍所有的设置项，可以发现很多惊喜。之前用过 Ubuntu 的 Unity 桌面，所以过渡到 OS X 还是很自然的，基本上看着都明白。为了提高逼格，我还特地把系统语言改成英文。&lt;/li&gt;
&lt;li&gt;如果是在官网购买的，首次开机时要求输入 Apple ID 时，请一定输入购买时的 Apple ID ，因为 Pages, iMove 等软件是要单独购买的，你在官网购买 Macbook Pro 时，这些软件是记在你购买时的 Apple ID 名下。如果首次开机时输入了不一样的 Apple ID 后面升级很麻烦。因为这个问题我折腾了好久，升级老出错，到现在还没搞定。&lt;/li&gt;
&lt;li&gt;如果你象我一样是码农，成天和电脑打交道。不仿偿试一下 Macbook Pro ，对设计得这么好的东西，我都有点后悔没有及早用上。&lt;/li&gt;
&lt;/ol&gt;</summary><category term="thought"></category></entry><entry><title>学习开源代码的三个层次</title><link href="http://blog.kamidox.com/three-levels-of-learning-code.html" rel="alternate"></link><updated>2015-01-16T23:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2015-01-16:three-levels-of-learning-code.html</id><summary type="html">&lt;p&gt;网络上有很多优秀的开源代码，学习这些代码是提高自己编程水平的最佳途径。我们在实际项目开发的过程中也会使用很多优秀的开源代码来加快开发速度，避免重复造轮子。优秀开源代码至少可以给我们提供三个层次的学习资料。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一层次：使用开源代码&lt;/strong&gt;&lt;br /&gt;
这一步相对简单，也是大部分人在项目开发过程中最常用的方式。优秀的开源代码一般文档齐全，示例代码丰富。通过简单地学习这些资料，可以较容易地掌握开源代码的用法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二层次：阅读开源代码，理解其实现原理&lt;/strong&gt;&lt;br /&gt;
做到这一步的人就比较少了。这一步需要花很多时间，而且还需要一些必要的基础知识储备。但如果能达到这个层次，能掌握的技能也会比较多，不单单是开源代码本身的核心逻辑及其架构设计，还能掌握软件开发过程中的一些最佳实践法则。比如单元测试，利用&lt;a href="https://travis-ci.org"&gt;travis&lt;/a&gt;进行自动编译测试等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三个层次：吸收并应用开源代码的设计理念到自己的软件开发过程中去&lt;/strong&gt;&lt;br /&gt;
看得懂和懂得灵活应用是两个层次的东西。从看得懂到会灵活应用中间还需要大量的时间去思考，去实践。面试过不少人，讲起来头头是道，真要让他写出来时，却卡壳了。要么类名方法名忘记了（IDE惹的祸），要么写出来的完全变味。要真正掌握一个技能，除了多看，还要多写，更要多总结，多思考。大道至简，总结多了，无非都是那些模式。面向测试的编程，面向对象编程，设计模式，函数式编程，宏等等这些抽象的概念，通过一些优秀的开源代码去总结思考，才能真正地理解这些抽象概念，最终把这些设计理念应用到自己的代码中去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天推荐一个Android开源库&lt;a href="https://github.com/greenrobot/EventBus"&gt;EventBus&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;EventBus is publish/subscribe event bus optimized for Android.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;它和Android的广播通信方式有什么区别？&lt;/li&gt;
&lt;li&gt;它和另外一个开源库&lt;a href="https://github.com/square/otto"&gt;Otto&lt;/a&gt;有什么区别？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答案都在其官方文档里。关于这个库，还有两个很好的学习资源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/android-cn/android-open-project-demo/tree/master/event-bus-demo"&gt;event-bus-demo&lt;/a&gt;&lt;br /&gt;
   这是一个DEMO程序。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/android-cn/android-open-project-analysis/tree/master/event-bus"&gt;EventBus 源码解析&lt;/a&gt;&lt;br /&gt;
   这个分析了其原理和实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网络上的那些XXX源码解析，XXX源码情景分析之类的文章质量还是比较高的，但这些文档不能代替对源码的阅读。这些文档的作用是帮助初学者更好的理解源码，降低学习成本。需要深刻理解设计精髓，还是需要通过阅读源码去深刻领会。阅读一些设计优秀的源码和青春期时阅读汪国真的蒙珑诗一样美。与其走马观花，不如花一些时间深入去学习几个开源代码，自己偿试通过阅读代码总结出其架构和设计的精髓。通过这样的训练，几个月后就会发现编程水平会有长足的进步。&lt;/p&gt;</summary><category term="thought"></category></entry><entry><title>FlaskBB阅读笔记（四）</title><link href="http://blog.kamidox.com/flaskbb-notes-4.html" rel="alternate"></link><updated>2014-12-21T23:00:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-12-21:flaskbb-notes-4.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;开篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#flaskbb"&gt;FlaskBB的测试代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pytest"&gt;通过实例来看pytest的运行机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fixtures"&gt;什么是fixtures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pytest_1"&gt;pytest标准的测试例收集流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#conftestpy"&gt;conftest.py&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pytestini"&gt;pytest.ini&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;结束语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;开篇&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://pytest.org/latest/contents.html#toc"&gt;FlaskBB&lt;/a&gt;是用Flask框架实现的一个轻量级的论坛社区软件，代码托管在GitHub上。本系列文章通过阅读FlaskBB的源代码来深入学习Flask框架，以及在一个产品级的Flask应用里的一些最佳实践规则。&lt;/p&gt;
&lt;p&gt;本文是本系列文章的第四篇，通过分析FlaskBB的自动测试代码，进而介绍Python下的自动化测试工具pytest。自动化测试在开发和重构过程中有着非常重要的地位。甚至还流行一种测试优先的编程方法，即针对一个功能模块，先写测试例，再去实现功能模块。&lt;/p&gt;
&lt;h2 id="flaskbb"&gt;FlaskBB的测试代码&lt;/h2&gt;
&lt;p&gt;FlaskBB的测试代码在tests目录下：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;tests/
├── conftest.py
├── fixtures
│   ├── app.py
│   ├── forum.py
│   ├── __init__.py
│   └── user.py
├── __init__.py
└── unit
    ├── __init__.py
    ├── __pycache__
    ├── test_forum_models.py
    └── utils
        ├── __init__.py
        ├── __pycache__
        ├── test_helpers.py
        ├── test_permissions.py
        ├── test_populate.py
        └── test_widgets.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在FlaskBB项目目录下执行&lt;code&gt;py.test tests&lt;/code&gt;输出以下测试结果：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;.venv&lt;span style="color: #666666"&gt;)&lt;/span&gt;kamidox@kamidox-laptop:~/code/flaskbb&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;py.test &lt;span style="color: #B8860B"&gt;tests&lt;/span&gt;
&lt;span style="color: #666666"&gt;=============================&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;test &lt;/span&gt;session &lt;span style="color: #B8860B"&gt;starts&lt;/span&gt; &lt;span style="color: #666666"&gt;==============================&lt;/span&gt;
platform linux2 -- Python 2.7.6 -- py-1.4.25 -- pytest-2.6.3 -- /home/kamidox/co
de/flaskbb/.venv/bin/python
Tests are shuffled using seed number 362536085265.
plugins: cov, random
collecting ... collected &lt;span style="color: #666666"&gt;42&lt;/span&gt; items

tests/unit/test_forum_models.py::test_topic_save PASSED
tests/unit/test_forum_models.py::test_topic_move PASSED
tests/unit/utils/test_permissions.py::test_super_moderator_permissions PASSED
tests/unit/test_forum_models.py::test_topic_url PASSED
tests/unit/utils/test_permissions.py::test_can_moderate_without_permission PASSED
tests/unit/test_forum_models.py::test_topic_merge PASSED
tests/unit/test_forum_models.py::test_forum_update_read PASSED
tests/unit/test_forum_models.py::test_forum_url PASSED
tests/unit/utils/test_helpers.py::test_slugify PASSED
tests/unit/test_forum_models.py::test_forum_save PASSED
tests/unit/test_forum_models.py::test_forum_get_topics PASSED
tests/unit/test_forum_models.py::test_forum_slugify PASSED
tests/unit/test_forum_models.py::test_forum_delete PASSED
tests/unit/utils/test_helpers.py::test_forum_is_unread PASSED
tests/unit/utils/test_permissions.py::test_moderator_permissions_without_forum PASSED
tests/unit/test_forum_models.py::test_category_delete_with_forum PASSED
tests/unit/test_forum_models.py::test_topic_merge_other_forum PASSED
tests/unit/test_forum_models.py::test_category_get_forums PASSED
tests/unit/test_forum_models.py::test_topic_slug PASSED
tests/unit/utils/test_permissions.py::test_normal_permissions PASSED
tests/unit/utils/test_widgets.py::test_select_date_widget PASSED
tests/unit/test_forum_models.py::test_forumsread PASSED
tests/unit/test_forum_models.py::test_topic_tracker_needs_update_cleared PASSED
tests/unit/test_forum_models.py::test_category_save PASSED
tests/unit/test_forum_models.py::test_category_get_all PASSED
tests/unit/utils/test_permissions.py::test_moderator_permissions_in_forum PASSED
tests/unit/test_forum_models.py::test_forum_update_read_two_topics PASSED
tests/unit/test_forum_models.py::test_category_delete PASSED
tests/unit/utils/test_permissions.py::test_admin_permissions PASSED
tests/unit/test_forum_models.py::test_topicsread PASSED
tests/unit/test_forum_models.py::test_forum_delete_with_user_and_topic PASSED
tests/unit/test_forum_models.py::test_post_save PASSED
tests/unit/test_forum_models.py::test_category_delete_with_user PASSED
tests/unit/test_forum_models.py::test_topic_delete PASSED
tests/unit/test_forum_models.py::test_post_delete PASSED
tests/unit/test_forum_models.py::test_topic_update_read PASSED
tests/unit/test_forum_models.py::test_topic_move_same_forum PASSED
tests/unit/utils/test_populate.py::test_create_default_groups PASSED
tests/unit/test_forum_models.py::test_forum_get_forum PASSED
tests/unit/test_forum_models.py::test_topic_tracker_needs_update PASSED
tests/unit/test_forum_models.py::test_report PASSED
tests/unit/test_forum_models.py::test_forum_update_last_post &lt;span style="color: #B8860B"&gt;PASSED&lt;/span&gt;

&lt;span style="color: #666666"&gt;==========================&lt;/span&gt; &lt;span style="color: #666666"&gt;42&lt;/span&gt; passed in 20.21 &lt;span style="color: #B8860B"&gt;seconds&lt;/span&gt; &lt;span style="color: #666666"&gt;==========================&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以看到总共有42个测试例，全部测试通过了。&lt;/p&gt;
&lt;h2 id="pytest"&gt;通过实例来看pytest的运行机制&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;tests/unit/test_forum_modules.py&lt;/code&gt;里有个删除讨论区版块的单元测试函数：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;test_forum_delete&lt;/span&gt;(forum):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;Test the delete forum method.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    forum&lt;span style="color: #666666"&gt;.&lt;/span&gt;delete()

    forum &lt;span style="color: #666666"&gt;=&lt;/span&gt; Forum&lt;span style="color: #666666"&gt;.&lt;/span&gt;query&lt;span style="color: #666666"&gt;.&lt;/span&gt;filter_by(&lt;span style="color: #AA22FF"&gt;id&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;forum&lt;span style="color: #666666"&gt;.&lt;/span&gt;id)&lt;span style="color: #666666"&gt;.&lt;/span&gt;first()

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;assert&lt;/span&gt; forum &lt;span style="color: #AA22FF; font-weight: bold"&gt;is&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;代码很简单，先调用&lt;code&gt;forum.delete()&lt;/code&gt;来删除一个讨论区版块，接着从&lt;code&gt;Forum&lt;/code&gt;里查询这个讨论区版块，应该是查询不到的，因为这个版块已经被删除了。&lt;/p&gt;
&lt;p&gt;问题来了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单元测试函数&lt;code&gt;test_forum_delete(forum)&lt;/code&gt;运行时的上下文环境是什么？&lt;/li&gt;
&lt;li&gt;单元测试函数的参数&lt;code&gt;forum&lt;/code&gt;是哪里来的？&lt;/li&gt;
&lt;li&gt;pytest怎么发现&lt;code&gt;test_forum_delete(forum)&lt;/code&gt;单元测试函数并执行它的？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要回答这些问题，必须介绍pytest的fixtures的概念。&lt;/p&gt;
&lt;h2 id="fixtures"&gt;什么是fixtures&lt;/h2&gt;
&lt;p&gt;fixtures是指测试的上下文，单元测试函数在运行之前，必须为其创建有效的运行时上下文信息。在xUnit测试框架里，每个测试例运行时都有setup/teardown方法与之匹配，pytest不但支持经典的setup/teardown方法，借助python强大的自省功能，它支持通过测试函数的参数为单元测试函数创建运行时的上下文信息。在上例中，函数参数&lt;code&gt;forum&lt;/code&gt;就是一个fixtures，它定义在&lt;code&gt;tests/fixtures/forum.py&lt;/code&gt;里：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;@pytest.fixture&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;forum&lt;/span&gt;(category, default_settings):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;A single forum in a category.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    forum &lt;span style="color: #666666"&gt;=&lt;/span&gt; Forum(title&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;Test Forum&amp;quot;&lt;/span&gt;, category_id&lt;span style="color: #666666"&gt;=&lt;/span&gt;category&lt;span style="color: #666666"&gt;.&lt;/span&gt;id)
    forum&lt;span style="color: #666666"&gt;.&lt;/span&gt;save()
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; forum
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;code&gt;@pytest.fixture&lt;/code&gt;装饰器告诉pytest，这是一个fixture。函数体很简单，就是创建一个forum，并保存在数据库里，最后返回这个forum实例。我们可以简单地理解成，在执行&lt;code&gt;test_forum_delete(forum)&lt;/code&gt;之前，单元测试例的函数参数&lt;code&gt;forum&lt;/code&gt;就是通过调用定义在&lt;code&gt;tests/fixtures/forum.py&lt;/code&gt;里的fixture函数&lt;code&gt;forum()&lt;/code&gt;创建出来并返回的。而作为fixture函数的&lt;code&gt;forum()&lt;/code&gt;本身也引用了名字叫&lt;code&gt;category&lt;/code&gt;和&lt;code&gt;default_settings&lt;/code&gt;的fixtures。&lt;/p&gt;
&lt;p&gt;到此我们可以总结一下fixtures的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;fixtures有明确的名字，并且通过在单元测试函数，测试类等的声明来调用。&lt;/li&gt;
&lt;li&gt;fixtures使用模块化来实现，一个fixture函数可以引用别的fixture。&lt;/li&gt;
&lt;li&gt;fixtures可以支持简单的单元测试以及复杂的功能测试，还可以配置在不同的测试例之间共用fixture。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FlaskBB的自动测试程序里，其所有的fixtures都定义在&lt;code&gt;tests/fixtures&lt;/code&gt;目录下的三个文件里&lt;code&gt;app.py&lt;/code&gt;，&lt;code&gt;forum.py&lt;/code&gt;和&lt;code&gt;user.py&lt;/code&gt;，其他的fixture都很好理解，定义在&lt;code&gt;app.py&lt;/code&gt;里的&lt;code&gt;application&lt;/code&gt;代码有点特殊：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;@pytest.yield_fixture&lt;/span&gt;(autouse&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;application&lt;/span&gt;():
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;application with context.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    app &lt;span style="color: #666666"&gt;=&lt;/span&gt; create_app(Config)

    ctx &lt;span style="color: #666666"&gt;=&lt;/span&gt; app&lt;span style="color: #666666"&gt;.&lt;/span&gt;app_context()
    ctx&lt;span style="color: #666666"&gt;.&lt;/span&gt;push()

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;yield&lt;/span&gt; app

    ctx&lt;span style="color: #666666"&gt;.&lt;/span&gt;pop()
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这里使用&lt;code&gt;@pytest.yield_fixture&lt;/code&gt;来定义一个生成器fixture。其次注意到使用了&lt;code&gt;autouse=True&lt;/code&gt;的参数，这个参数表示这个fixture在运行任何一个单元测试函数之前都必须先调用。即所有的单元测试函数都信赖这个fixture。从函数内容来看，它创建一个Flask APP的实例，以这个实例作为单元测试的上下文。&lt;/p&gt;
&lt;h2 id="pytest_1"&gt;pytest标准的测试例收集流程&lt;/h2&gt;
&lt;p&gt;pytest在运行测试例前，必须通过一套规则来收集所有的测试例。默认情况下，pytest的测试例收集流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在运行&lt;code&gt;py.test&lt;/code&gt;命令的当前目录或其后第一个参数（可以上目录，或模块名）所指定的位置开始收集测试例&lt;/li&gt;
&lt;li&gt;从起始目录递归查找所有的文件及子文件夹（包含在&lt;code&gt;norecursedirs&lt;/code&gt;配置参数里的文件夹不会被搜索）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test_*.py&lt;/code&gt;或&lt;code&gt;*_test.py&lt;/code&gt;将会按照python包结构被import进测试的上下文&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;Test&lt;/code&gt;开头的类将作为测试类被收集起来&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;test_&lt;/code&gt;开头的函数将作为单元测试函数被收集起来&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，这个测试例收集规则是可以定制的，具体可参阅pytest的&lt;a href="http://pytest.org/latest/contents.html#toc"&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;FlaskBB的单元测试代码都放在&lt;code&gt;tests/unit&lt;/code&gt;目录下。所有以&lt;code&gt;test_&lt;/code&gt;打头的文件都会被import进测试的上下文。同时所有python文件里以&lt;code&gt;test_&lt;/code&gt;打头的函数都被作为单元测试函数被收集起来测试。这样我们前文提到的&lt;code&gt;test_forum_delete(forum)&lt;/code&gt;函数就被作为一个单元测试函数收集起来了。&lt;/p&gt;
&lt;h2 id="conftestpy"&gt;conftest.py&lt;/h2&gt;
&lt;p&gt;pytest在执行任何一个单元测试的时候，最靠近执行目录下的那个&lt;code&gt;conftest.py&lt;/code&gt;将被自动执行。针对FlaskBB，其内容为：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;tests.fixtures.app&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #666666"&gt;*&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;tests.fixtures.forum&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #666666"&gt;*&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;tests.fixtures.user&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #666666"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;从代码来看，它import了我们定义的所有的fixtures。除了自定义的fixtures之外，系统也有一些内置的fixtures，可以运行&lt;code&gt;py.test --fixtures&lt;/code&gt;来查阅所有的可用fixtures。&lt;/p&gt;
&lt;h2 id="pytestini"&gt;pytest.ini&lt;/h2&gt;
&lt;p&gt;pytest在执行时，会读取命令运行目录下的pytest.ini文件，通过这个文件可以定制py.test命令的一些行为。FlaskBB的里pytest.ini的内容为：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;[pytest]&lt;/span&gt;
&lt;span style="color: #BB4444"&gt;norecursedirs&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;docs flaskbb logs migrations whoosh_index&lt;/span&gt;
&lt;span style="color: #BB4444"&gt;addopts&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;--strict --random -vvl&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;norecursedirs&lt;/code&gt;表示在递归查找测试例时，忽略docs flaskbb等目录。&lt;code&gt;addopts&lt;/code&gt;为py.test命令添加一些自定义的选项。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;py.test运行方式&lt;/p&gt;
&lt;p&gt;笔者在第一次运行FlaskBB测试程序时，使用&lt;code&gt;py.test&lt;/code&gt;直接运行，结果发现执行花了很长的时间，而且很多失败项。经查，原来在笔者的环境里，通过virtualenv把&lt;code&gt;.venv&lt;/code&gt;目录放在了项目的根目录下，所以默认情况下pytest会从&lt;code&gt;.venv&lt;/code&gt;里收集其他包的测试例来测试。所以，虽然可以定义&lt;code&gt;norecursedirs&lt;/code&gt;目录，但还是推荐使用&lt;code&gt;py.test tests&lt;/code&gt;这种后面直接跟着测试代码目录的方式来运行测试例。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="_2"&gt;结束语&lt;/h2&gt;
&lt;p&gt;通过上文的分析，可以轻松理解FlaskBB里的自动测试代码。在Quara上看到过一篇介绍Quara的continuous development的文章，Quara的网站每天会更新上百次，这是怎么做到的呢？如果没有自动化测试和自动化布署的工具，这是不可想象的。如果做黑盒测试，光回归测试就要累死人。有兴趣的同学可以&lt;a href="http://engineering.quora.com/Continuous-Deployment-at-Quora"&gt;点击这里&lt;/a&gt;看一下高大上的互联网公司是怎么做自动化测试和布署的。&lt;/p&gt;</summary><category term="python"></category><category term="flask"></category></entry><entry><title>FlaskBB阅读笔记（三）</title><link href="http://blog.kamidox.com/flaskbb-notes-3.html" rel="alternate"></link><updated>2014-12-07T23:00:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-12-07:flaskbb-notes-3.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;开篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orm"&gt;什么是 ORM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;定义表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;定义一对多关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;定义多对多关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;插入及修改记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;删除记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;查询记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#mvc"&gt;MVC 代码结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;结束语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;开篇&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.w3school.com.cn/sql/sql_join.asp"&gt;FlaskBB&lt;/a&gt;是用Flask框架实现的一个轻量级的论坛社区软件，代码托管在GitHub上。本系列文章通过阅读FlaskBB的源代码来深入学习Flask框架，以及在一个产品级的Flask应用里的一些最佳实践规则。&lt;/p&gt;
&lt;p&gt;本文是本系列文章的第三篇，将介绍ORM基础知识，分析Flask-SQLAlchemy及sqlalchemy ORM引擎的一些常用方法，进而介绍FlaskBB用户管理模块的数据库设计。&lt;/p&gt;
&lt;h2 id="orm"&gt;什么是 ORM&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对象关系映射（英语：Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。-百度百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单地说，使用 ORM 来操作数据库，我们基本上不用跟 SQL 打交道了。直接用程序语言的对象来打交道即可。Flask-SQLAlchemy 是 ORM 引擎 sqlalchemy 针对 Flask 的扩展。&lt;/p&gt;
&lt;h2 id="_2"&gt;定义表&lt;/h2&gt;
&lt;p&gt;定义一个表只需要继承自 &lt;code&gt;db.Model&lt;/code&gt; 即可。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;User&lt;/span&gt;(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Model, UserMixin):
    __tablename__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;users&amp;quot;&lt;/span&gt;
    __searchable__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;email&amp;#39;&lt;/span&gt;]

    &lt;span style="color: #AA22FF"&gt;id&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Integer, primary_key&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
    username &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;200&lt;/span&gt;), unique&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;, nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    email &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;200&lt;/span&gt;), unique&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;, nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    _password &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(&lt;span style="color: #BB4444"&gt;&amp;#39;password&amp;#39;&lt;/span&gt;, db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;120&lt;/span&gt;), nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这样我们就定义了一个叫 &lt;code&gt;users&lt;/code&gt; 的表格，表格的名称由 &lt;code&gt;__tablename__&lt;/code&gt; 指定。这样任何对表格的操作，都可以转化为对 &lt;code&gt;User&lt;/code&gt; 类的操作。代码里的 &lt;code&gt;db&lt;/code&gt; 对象是什么呢？在 extensions.py 里创建了 db 对象 &lt;code&gt;db = SQLAlchemy()&lt;/code&gt;。然后在 app.py 里初始化这个 db 对象 &lt;code&gt;db.init_app(app)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="_3"&gt;定义一对多关系&lt;/h2&gt;
&lt;p&gt;一个论坛用户会对应多个论坛主题。论坛主题由类 &lt;code&gt;Topic&lt;/code&gt; 表达。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;Topic&lt;/span&gt;(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Model):
    __tablename__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;topics&amp;quot;&lt;/span&gt;
    __searchable__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;#39;title&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;]

    &lt;span style="color: #AA22FF"&gt;id&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Integer, primary_key&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
    forum_id &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Integer,
                         db&lt;span style="color: #666666"&gt;.&lt;/span&gt;ForeignKey(&lt;span style="color: #BB4444"&gt;&amp;quot;forums.id&amp;quot;&lt;/span&gt;,
                                       use_alter&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;,
                                       name&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;fk_topic_forum_id&amp;quot;&lt;/span&gt;),
                         nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    title &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;255&lt;/span&gt;), nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    user_id &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Integer, db&lt;span style="color: #666666"&gt;.&lt;/span&gt;ForeignKey(&lt;span style="color: #BB4444"&gt;&amp;quot;users.id&amp;quot;&lt;/span&gt;))
    username &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;200&lt;/span&gt;), nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    date_created &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;DateTime, default&lt;span style="color: #666666"&gt;=&lt;/span&gt;datetime&lt;span style="color: #666666"&gt;.&lt;/span&gt;utcnow())
    last_updated &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;DateTime, default&lt;span style="color: #666666"&gt;=&lt;/span&gt;datetime&lt;span style="color: #666666"&gt;.&lt;/span&gt;utcnow())
    locked &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Boolean, default&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    important &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Boolean, default&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    views &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Integer, default&lt;span style="color: #666666"&gt;=0&lt;/span&gt;)
    post_count &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Integer, default&lt;span style="color: #666666"&gt;=0&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;User 类通过 &lt;code&gt;db.relationship&lt;/code&gt; 来定义表 User 和 Topic 的一对多关系。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;User&lt;/span&gt;(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Model, UserMixin):
    __tablename__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;users&amp;quot;&lt;/span&gt;
    __searchable__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;email&amp;#39;&lt;/span&gt;]

    &lt;span style="color: #AA22FF"&gt;id&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Integer, primary_key&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
    username &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;200&lt;/span&gt;), unique&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;, nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    email &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;200&lt;/span&gt;), unique&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;, nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    _password &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(&lt;span style="color: #BB4444"&gt;&amp;#39;password&amp;#39;&lt;/span&gt;, db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;120&lt;/span&gt;), nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    &lt;span style="color: #666666"&gt;...&lt;/span&gt;
    topics &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;relationship(&lt;span style="color: #BB4444"&gt;&amp;quot;Topic&amp;quot;&lt;/span&gt;, backref&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;user&amp;quot;&lt;/span&gt;, lazy&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;dynamic&amp;quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;关键代码在 LINE 10 。这一行代码会在 &lt;code&gt;users&lt;/code&gt; 表里创建一个列叫 &lt;code&gt;topics&lt;/code&gt;，这个列就保存了这个用户发起的所有论坛主题。然后在 &lt;code&gt;topics&lt;/code&gt; 表里创建一个列叫 &lt;code&gt;user&lt;/code&gt;，这是通过 &lt;code&gt;backref&lt;/code&gt; 这个参数实现的，所以我们可以通过 &lt;code&gt;Topic.user&lt;/code&gt; 来引用论坛主题的发起用户。最后一个参数 &lt;code&gt;lazy&lt;/code&gt; 可以有四个值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt;&lt;br /&gt;
  这是默认值，表示 SQLAlchemy 会在必要的时候一次性把所有的数据从数据库里通过 SQL SELECT 语句读取出来。当一对多的数据量比较小时可以用这个值，当数据量比较大时，用这个值会降低程序的性能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;joined&lt;/code&gt;&lt;br /&gt;
  告诉 SQLAlchemy 使用 JOIN 子句一次性地把关系数据从数据库里导出来。关于 JOIN 可参阅&lt;a href="http://www.w3school.com.cn/sql/sql_join.asp"&gt;这篇文章&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subquery&lt;/code&gt;&lt;br /&gt;
  类似 &lt;code&gt;joined&lt;/code&gt;，但 SQLAlchemy 会使用子查询来读取数据库。关于子查询可参阅&lt;a href="http://www.360doc.com/content/11/0407/17/5789627_107867377.shtml"&gt;这篇文章&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic&lt;/code&gt;&lt;br /&gt;
  针对一对多关系里，数据量比较大时，这是个特殊且有用的类型。它不会一次性把所有的关系数据都从数据库里读出来，相反它会返回一个查询对象，在需要数据时，从这个查询对象时进行二次查询，才能获得需要的数据。这种类型可以提高程序性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_4"&gt;定义多对多关系&lt;/h2&gt;
&lt;p&gt;一个用户可以属于多个组，而一个组里也会有多个用户。针对这种多对多的关系，我们需要第三个表来保存这种多对多关系。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;groups_users &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Table(
    &lt;span style="color: #BB4444"&gt;&amp;#39;groups_users&amp;#39;&lt;/span&gt;,
    db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(&lt;span style="color: #BB4444"&gt;&amp;#39;user_id&amp;#39;&lt;/span&gt;, db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Integer(), db&lt;span style="color: #666666"&gt;.&lt;/span&gt;ForeignKey(&lt;span style="color: #BB4444"&gt;&amp;#39;users.id&amp;#39;&lt;/span&gt;)),
    db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(&lt;span style="color: #BB4444"&gt;&amp;#39;group_id&amp;#39;&lt;/span&gt;, db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Integer(), db&lt;span style="color: #666666"&gt;.&lt;/span&gt;ForeignKey(&lt;span style="color: #BB4444"&gt;&amp;#39;groups.id&amp;#39;&lt;/span&gt;)))
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;首先直接使用 &lt;code&gt;db.Table&lt;/code&gt; 定义一个多对多的关系表 &lt;code&gt;groups_users&lt;/code&gt;。这里要注意不要使用继承 &lt;code&gt;db.Model&lt;/code&gt; 来定义这个多对多关系表。然后，在 User 类里使用 &lt;code&gt;db.relationship&lt;/code&gt; 来定义多对多关系：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;User&lt;/span&gt;(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Model, UserMixin):
    __tablename__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;users&amp;quot;&lt;/span&gt;
    __searchable__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;email&amp;#39;&lt;/span&gt;]

    &lt;span style="color: #AA22FF"&gt;id&lt;/span&gt; &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Integer, primary_key&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
    username &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;200&lt;/span&gt;), unique&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;, nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    email &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;200&lt;/span&gt;), unique&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;, nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    _password &lt;span style="color: #666666"&gt;=&lt;/span&gt; db&lt;span style="color: #666666"&gt;.&lt;/span&gt;Column(&lt;span style="color: #BB4444"&gt;&amp;#39;password&amp;#39;&lt;/span&gt;, db&lt;span style="color: #666666"&gt;.&lt;/span&gt;String(&lt;span style="color: #666666"&gt;120&lt;/span&gt;), nullable&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;)
    &lt;span style="color: #666666"&gt;...&lt;/span&gt;
    secondary_groups &lt;span style="color: #666666"&gt;=&lt;/span&gt; \
        db&lt;span style="color: #666666"&gt;.&lt;/span&gt;relationship(&lt;span style="color: #BB4444"&gt;&amp;#39;Group&amp;#39;&lt;/span&gt;,
                    secondary&lt;span style="color: #666666"&gt;=&lt;/span&gt;groups_users,
                    primaryjoin&lt;span style="color: #666666"&gt;=&lt;/span&gt;(groups_users&lt;span style="color: #666666"&gt;.&lt;/span&gt;c&lt;span style="color: #666666"&gt;.&lt;/span&gt;user_id &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;id&lt;/span&gt;),
                    backref&lt;span style="color: #666666"&gt;=&lt;/span&gt;db&lt;span style="color: #666666"&gt;.&lt;/span&gt;backref(&lt;span style="color: #BB4444"&gt;&amp;#39;users&amp;#39;&lt;/span&gt;, lazy&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;dynamic&amp;#39;&lt;/span&gt;),
                    lazy&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;dynamic&amp;#39;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;其中 LINE 10 - 15 使用 &lt;code&gt;db.relationship&lt;/code&gt; 来定义多对多关系。第一个参数表示多对多关系的类为 Group，第二个参数 &lt;code&gt;secondary=groups_users&lt;/code&gt; 表示需要从第三个叫 &lt;code&gt;groups_users&lt;/code&gt; 的表里获取多对多关系，第三个参数 &lt;code&gt;primaryjoin=(groups_users.c.user_id == id)&lt;/code&gt; 表示连接查询时的条件。第四个参数 &lt;code&gt;backref=db.backref('users', lazy='dynamic')&lt;/code&gt; 会在 Group 类里创建一个成员叫 users，其中 &lt;code&gt;db.backref&lt;/code&gt; 的 &lt;code&gt;lazy&lt;/code&gt; 参数为 &lt;code&gt;dynamic&lt;/code&gt; 表示 Group.users 为一个查询对象。第五个参数 &lt;code&gt;lazy='dynamic'&lt;/code&gt; 表示 User.secondary_groups 为一个查询对象，其实这里可以不要使用 &lt;code&gt;dynamic&lt;/code&gt;，因为一个用户所属的组是很有限的，不可能很多，可以一次性全部加载进来。&lt;/p&gt;
&lt;h2 id="_5"&gt;插入及修改记录&lt;/h2&gt;
&lt;p&gt;插入记录时，不用再写 SQL 语句了，直接使用类对象来操作即可。用户注册成功后，需要向 users 表插入一条记录。在 &lt;code&gt;flaskbb.auth.RegisterForm.save()&lt;/code&gt; 里实现：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;save&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;):
    user &lt;span style="color: #666666"&gt;=&lt;/span&gt; User(username&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;username&lt;span style="color: #666666"&gt;.&lt;/span&gt;data,
                email&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;email&lt;span style="color: #666666"&gt;.&lt;/span&gt;data,
                password&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;password&lt;span style="color: #666666"&gt;.&lt;/span&gt;data,
                date_joined&lt;span style="color: #666666"&gt;=&lt;/span&gt;datetime&lt;span style="color: #666666"&gt;.&lt;/span&gt;utcnow(),
                primary_group_id&lt;span style="color: #666666"&gt;=4&lt;/span&gt;)
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; user&lt;span style="color: #666666"&gt;.&lt;/span&gt;save()
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;创建一个 User 对象，然后调用对象的 &lt;code&gt;save()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;save&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, groups&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;Saves a user. If a list with groups is provided, it will add those&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    to the secondary groups from the user.&lt;/span&gt;

&lt;span style="color: #BB4444; font-style: italic"&gt;    :param groups: A list with groups that should be added to the&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;                   secondary groups from user.&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; groups:
        &lt;span style="color: #008800; font-style: italic"&gt;# TODO: Only remove/add groups that are selected&lt;/span&gt;
        secondary_groups &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;secondary_groups&lt;span style="color: #666666"&gt;.&lt;/span&gt;all()
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; group &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; secondary_groups:
            &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;remove_from_group(group)
        db&lt;span style="color: #666666"&gt;.&lt;/span&gt;session&lt;span style="color: #666666"&gt;.&lt;/span&gt;commit()

        &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; group &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; groups:
            &lt;span style="color: #008800; font-style: italic"&gt;# Do not add the primary group to the secondary groups&lt;/span&gt;
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; group&lt;span style="color: #666666"&gt;.&lt;/span&gt;id &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;primary_group_id:
                &lt;span style="color: #AA22FF; font-weight: bold"&gt;continue&lt;/span&gt;
            &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;add_to_group(group)

        &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;invalidate_cache()

    db&lt;span style="color: #666666"&gt;.&lt;/span&gt;session&lt;span style="color: #666666"&gt;.&lt;/span&gt;add(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;)
    db&lt;span style="color: #666666"&gt;.&lt;/span&gt;session&lt;span style="color: #666666"&gt;.&lt;/span&gt;commit()
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;其关键代码是 LINE 24 - 25。其中 &lt;code&gt;db.session&lt;/code&gt; 对象是 Flask-SQLAlchemy 扩展为我们创建的一个事务对象，使用 &lt;code&gt;db.session.add()&lt;/code&gt; 来插入记录，使用 &lt;code&gt;db.session.commit()&lt;/code&gt; 来提交事务，使操作生效。LINE 9 - LINE 22是当需要改变一个用户所属的组时的操作代码，这里就不展开讨论。&lt;/p&gt;
&lt;p&gt;需要说明的是，修改记录时也是使用 &lt;code&gt;db.session.add()&lt;/code&gt; 方法。SQLAlchemy 会自动根据主键的值来判断这是一个新加的记录还是要修改的记录。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;关于db.session.commit()&lt;/p&gt;
&lt;p&gt;User.save() 方法里，当 groups 参数不为空时，会有两个 db.session.commit() 的调用。把一个操作分成两个事务，就达不到保证数据一致性的目的了。这里的代码写法应该可以再考量一下。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="_6"&gt;删除记录&lt;/h2&gt;
&lt;p&gt;当我们需要从 users 表里删除记录里，调用 &lt;code&gt;User.delete()&lt;/code&gt; 方法即可，它的代码是这样的：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;delete&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;Deletes the User.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;# This isn&amp;#39;t done automatically...&lt;/span&gt;
    PrivateMessage&lt;span style="color: #666666"&gt;.&lt;/span&gt;query&lt;span style="color: #666666"&gt;.&lt;/span&gt;filter_by(user_id&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;id)&lt;span style="color: #666666"&gt;.&lt;/span&gt;delete()
    ForumsRead&lt;span style="color: #666666"&gt;.&lt;/span&gt;query&lt;span style="color: #666666"&gt;.&lt;/span&gt;filter_by(user_id&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;id)&lt;span style="color: #666666"&gt;.&lt;/span&gt;delete()
    TopicsRead&lt;span style="color: #666666"&gt;.&lt;/span&gt;query&lt;span style="color: #666666"&gt;.&lt;/span&gt;filter_by(user_id&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;id)&lt;span style="color: #666666"&gt;.&lt;/span&gt;delete()

    db&lt;span style="color: #666666"&gt;.&lt;/span&gt;session&lt;span style="color: #666666"&gt;.&lt;/span&gt;delete(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;)
    db&lt;span style="color: #666666"&gt;.&lt;/span&gt;session&lt;span style="color: #666666"&gt;.&lt;/span&gt;commit()

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;LINE 9 - 10 是用来从 users 表里删除一条记录。LINE 5-7 是用来在删除用户之前，把一些用户相关的数据也一并删除掉。&lt;/p&gt;
&lt;h2 id="_7"&gt;查询记录&lt;/h2&gt;
&lt;p&gt;继承自 &lt;code&gt;db.Model&lt;/code&gt; 的类会引入 &lt;code&gt;query&lt;/code&gt; 属性，这是个可查询对象 &lt;code&gt;Query&lt;/code&gt; 的实例。其常用的方法有 &lt;code&gt;query.filter()&lt;/code&gt;，&lt;code&gt;query.filter_by()&lt;/code&gt;，&lt;code&gt;query.order_by()&lt;/code&gt;，&lt;code&gt;query.limit()&lt;/code&gt;，&lt;code&gt;query.get()&lt;/code&gt;等等。这些函数只是指定了查询的条件，查询真正开始是在调用 &lt;code&gt;query.first()&lt;/code&gt;，&lt;code&gt;query.all()&lt;/code&gt; 等方法后才发生的。&lt;/p&gt;
&lt;p&gt;例如，获取用户的主题个数 &lt;code&gt;User.topic_count()&lt;/code&gt;：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;@property&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;topic_count&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;Returns the thread count&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; Topic&lt;span style="color: #666666"&gt;.&lt;/span&gt;query&lt;span style="color: #666666"&gt;.&lt;/span&gt;filter(Topic&lt;span style="color: #666666"&gt;.&lt;/span&gt;user_id &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;id)&lt;span style="color: #666666"&gt;.&lt;/span&gt;count()
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;再如 &lt;code&gt;User.delete()&lt;/code&gt; 的代码里删除用户相关的数据的代码：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;PrivateMessage&lt;span style="color: #666666"&gt;.&lt;/span&gt;query&lt;span style="color: #666666"&gt;.&lt;/span&gt;filter_by(user_id&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;id)&lt;span style="color: #666666"&gt;.&lt;/span&gt;delete()
ForumsRead&lt;span style="color: #666666"&gt;.&lt;/span&gt;query&lt;span style="color: #666666"&gt;.&lt;/span&gt;filter_by(user_id&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;id)&lt;span style="color: #666666"&gt;.&lt;/span&gt;delete()
TopicsRead&lt;span style="color: #666666"&gt;.&lt;/span&gt;query&lt;span style="color: #666666"&gt;.&lt;/span&gt;filter_by(user_id&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;id)&lt;span style="color: #666666"&gt;.&lt;/span&gt;delete()
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;再如 &lt;code&gt;User.save()&lt;/code&gt; 的代码里关于群组的相关操作代码：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;secondary_groups &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;secondary_groups&lt;span style="color: #666666"&gt;.&lt;/span&gt;all()
&lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; group &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; secondary_groups:
    &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;remove_from_group(group)
db&lt;span style="color: #666666"&gt;.&lt;/span&gt;session&lt;span style="color: #666666"&gt;.&lt;/span&gt;commit()
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;通过 &lt;code&gt;self.secondary_groups.all()&lt;/code&gt; 获取所有的群组，然后在这些群组里把用户移除。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;filter() vs filter_by()&lt;/p&gt;
&lt;p&gt;&lt;code&gt;filter(*criterion)&lt;/code&gt; 使用 SQL 表达式，而 &lt;code&gt;filter_by(**kwargs)&lt;/code&gt; 使用关键字表达式。从函数声明可以看出来 &lt;code&gt;filter()&lt;/code&gt; 接受的参数是一个元组表达式，而 &lt;code&gt;filter_by()&lt;/code&gt; 接受的是一个 dict 表达式。所以，&lt;code&gt;Topic.query.filter(Topic.user_id == self.id).count()&lt;/code&gt; 等价于 &lt;code&gt;Topic.query.filter_by(user_id = self.id).count()&lt;/code&gt;。关于这个区别，还可以进一步查阅 &lt;a href="http://stackoverflow.com/questions/2128505/whats-the-difference-between-filter-and-filter-by-in-sqlalchemy"&gt;StackOverFlow&lt;/a&gt; 及 &lt;a href="http://segmentfault.com/q/1010000000140472"&gt;SegmentFault&lt;/a&gt; 上的文章，还有&lt;a href="http://docs.sqlalchemy.org/en/latest/orm/query.html?highlight=filter_by#sqlalchemy.orm.query.Query.filter"&gt;官方的文档&lt;/a&gt;。顺便吐槽一下，从这个对比可以看出来 StackOverFlow 和国内 SegmentFault 质量差异，顺便再感慨一下，学 IT 的人英文不好你就等着受苦吧，永远接触不到第一手的权威资料。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;关于查询还需要说明的一点，Flask-SQLAlchemy 提供了便利的函数 &lt;code&gt;get_or_404()&lt;/code&gt; 及 &lt;code&gt;first_or_404()&lt;/code&gt; 来替代 &lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;first()&lt;/code&gt; 方法。这两个方法在 view 里特别有用，如找不到这个用户时，直接抛出 404 异常。而不是返回一个 None。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;@user.route&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;/&amp;lt;username&amp;gt;&amp;quot;&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;profile&lt;/span&gt;(username):
    user &lt;span style="color: #666666"&gt;=&lt;/span&gt; User&lt;span style="color: #666666"&gt;.&lt;/span&gt;query&lt;span style="color: #666666"&gt;.&lt;/span&gt;filter_by(username&lt;span style="color: #666666"&gt;=&lt;/span&gt;username)&lt;span style="color: #666666"&gt;.&lt;/span&gt;first_or_404()
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; render_template(&lt;span style="color: #BB4444"&gt;&amp;quot;user/profile.html&amp;quot;&lt;/span&gt;, user&lt;span style="color: #666666"&gt;=&lt;/span&gt;user)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id="mvc"&gt;MVC 代码结构&lt;/h2&gt;
&lt;p&gt;介绍完 ORM，我们可以看一下 FlaskBB 项目 &lt;code&gt;flaskbb/flaskbb&lt;/code&gt; 目录下的核心代码的 MVC 代码结构。它把每个模块封装成一个独立的 bluepoint，每个模块又分为 model，view，form 三个模块。这样整体代码结构非常清晰。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;flaskbb
├── __init__.py
├── _compat.py
├── app.py
├── email.py
├── extensions.py
├── auth
│   ├── __init__.py
│   ├── forms.py
│   └── views.py
├── configs
│   ├── __init__.py
│   ├── default.py
│   ├── development.py
│   ├── development.py.example
│   ├── production.py.example
│   └── testing.py
├── fixtures
│   ├── __init__.py
│   ├── groups.py
│   └── settings.py
├── forum
│   ├── __init__.py
│   ├── forms.py
│   ├── models.py
│   └── views.py
├── management
│   ├── __init__.py
│   ├── forms.py
│   ├── models.py
│   └── views.py
├── user
│   ├── __init__.py
│   ├── forms.py
│   ├── models.py
│   └── views.py
└── utils
    ├── __init__.py
    ├── decorators.py
    ├── helpers.py
    ├── permissions.py
    ├── populate.py
    ├── settings.py
    └── widgets.py
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_8"&gt;结束语&lt;/h2&gt;
&lt;p&gt;本文简单介绍了 ORM 操作数据库的概念和一些基本的用法。可参考的资料很多，这里强烈推荐官方文档，深入浅出。关于入门资料，可参阅 &lt;a href="http://flask-sqlalchemy.pocoo.org/2.0"&gt;Flask-SQLAlchemy 官方文档&lt;/a&gt;。深入阅读可以参考 &lt;a href="http://docs.sqlalchemy.org/en/latest/orm"&gt;sqlalchemy 官方文档&lt;/a&gt;。&lt;/p&gt;</summary><category term="python"></category><category term="flask"></category></entry><entry><title>使用 patchrom 移植 MIUI</title><link href="http://blog.kamidox.com/patchrom-miui.html" rel="alternate"></link><updated>2014-12-06T23:00:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-12-06:patchrom-miui.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;开篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;移植过程&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#miui-patchrom"&gt;下载 MIUI patchrom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;准备移植目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ota"&gt;准备一个 OTA 升级包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#makefile"&gt;准备一个 makefile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#make-workspace"&gt;make workspace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#make-firstpatch"&gt;make firstpatch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reject"&gt;手动合并 reject 目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#make-fullota"&gt;make fullota&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;开篇&lt;/h2&gt;
&lt;p&gt;MIUI 使用代码插桩的方式来移植。即 MIUI 把他们基于 AOSP 的修改的代码全部用 smali 开放出来。这样我们通过对比 MIUI 的 smali 代码和 AOSP 的 smali　代码就可以知道 MIUI 修改了哪些内容，把这些内容移植过去即可完成 MIUI的移植。本文以 jellybean42-mtk 为例，描述使用 patchrom 移植 MIUI的方法以及在过程中遇到的问题及其调试方法。&lt;/p&gt;
&lt;h2 id="_2"&gt;移植过程&lt;/h2&gt;
&lt;p&gt;可以查阅 &lt;a href="http://pan.baidu.com/s/1o6yq4I2"&gt;MIUI 移植的文档&lt;/a&gt;了解一些背景知识。这里将主体步骤描述如下：&lt;/p&gt;
&lt;h3 id="miui-patchrom"&gt;下载 MIUI patchrom&lt;/h3&gt;
&lt;p&gt;下载 repo 工具&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;mkdir ~/bin
curl https://storage.googleapis.com/git-repo-downloads/repo &amp;gt; ~/bin/repo
chmod a+x ~/bin/repo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载 MIUI patchrom 代码&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;mkdir ~/work/patchrom
&lt;span style="color: #AA22FF"&gt;cd&lt;/span&gt; ~/work/patchrom
repo init -u git://github.com/MiCode/patchrom.git -b jellybean42-mtk
repo sync
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;repo sync&lt;/code&gt; 命令需要很长的时间才能把代码下载完，代码总量大于10G。所以，基本上可以玩儿去了，不要傻傻地等了。&lt;/p&gt;
&lt;p&gt;代码下载完成后，我们就可以开始移植工作了。实际的代码目录树结构和内容和文档里描述的会有出入，我们可以忽略文档里的，以实际代码为准。本文使用2014-12-04下载的代码为准。&lt;/p&gt;
&lt;h3 id="_3"&gt;准备移植目录&lt;/h3&gt;
&lt;p&gt;在 patchrom 根目录下创建一个产品的工作目录用来移植时使用。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;cd&lt;/span&gt; ~/work/patchrom
&lt;span style="color: #AA22FF"&gt;source &lt;/span&gt;build/envsetup.sh
mkdir ~/work/patchrom/mtk6582
&lt;span style="color: #AA22FF"&gt;cd &lt;/span&gt;mtk6582
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="ota"&gt;准备一个 OTA 升级包&lt;/h3&gt;
&lt;p&gt;我们直接拿一个要当作底包的 OTA 升级包来作为 stockrom.zip。对这个底包有以下的要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个底包必须是 user 版本且足够稳定。因为根据底包移植完的软件是直接拿来当产品使用的。&lt;/li&gt;
&lt;li&gt;这个底包可以直接在手机里通过 recovery 模式升级。这个对后面移植完手的 miui-ota 包的烧录有帮助。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，我们直接把这个 OTA 升级包 stockrom.zip 放在刚刚我们创建的 mtk6582 目录下。除此之外，我们还需要一台内核 root 过的手机，以便配合整个移植过程。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;关于stockrom.zip&lt;/p&gt;
&lt;p&gt;patchrom 官方移植教程是使用 &lt;code&gt;../tools/ota_target_from_phone -r&lt;/code&gt; 来直接从移植手机里生成 stockrom.zip 。这个命令要求手机先运行在 recovery 模式下。我自己验证过无法运行，没去深究。所以，直接拿一个 OTA 升级包来作为移植的底包。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;user 版本的 OTA 升级包里，apk 文件都是经过 odex 优化的。而 smali 反汇编又需要优化前的 apk　文件。怎么样解决这个问题呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开 stockrom.zip 文件，把 system/framework 下的 pacheCoder.jar, gcm.jar, hpe.jar 从 zip 包里删除。这是因为这三个 jar 包没有经过 odex 优化。即找不到相应的 odex 包。这样的情况在下面的步骤处理时会出错。&lt;/li&gt;
&lt;li&gt;在 patchrom/mtk6582 目录下，执行如下命令　&lt;code&gt;../tools/deodex.sh stockrom.zip&lt;/code&gt; ，执行结束后，原 OTA 包会被覆盖掉，而且里面的 odex 文件将全部被打包回 apk 文件里。&lt;/li&gt;
&lt;li&gt;把步骤 1 删除掉的 3 个 jar 包放回 zip 包里。然后运行下面命令对zip包进行重新签名 &lt;code&gt;java -Xmx2048m -jar signapk.jar -w testkey.x509.pem testkey.pk8 stockrom.zip stockrom-signed.zip&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;把新生成的 ota zip 包放在手机 SD 卡里，进 recovery 模式进行升级。确保制作出来的包没有问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="makefile"&gt;准备一个 makefile&lt;/h3&gt;
&lt;p&gt;下面的 makefile 可以作为模板，里面有详细的注释说明每个字段的含义。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;#&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# Makefile for mtk6582&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;#&lt;/span&gt;

&lt;span style="color: #008800; font-style: italic"&gt;# 指定我们要移植的手机的底包，就是上一步骤里准备的 stockrom.zip&lt;/span&gt;
&lt;span style="color: #B8860B"&gt;local-zip-file&lt;/span&gt;     &lt;span style="color: #666666"&gt;:=&lt;/span&gt; stockrom.zip

&lt;span style="color: #008800; font-style: italic"&gt;# 编译我们移植好的 MIUI ROM 时的输出文件名&lt;/span&gt;
&lt;span style="color: #B8860B"&gt;local-out-zip-file&lt;/span&gt; &lt;span style="color: #666666"&gt;:=&lt;/span&gt; MIUI_MTK6582.zip

&lt;span style="color: #008800; font-style: italic"&gt;# 制作升级差异包时所需要的上一个版本的 ota 包目录，我们暂时还用不着&lt;/span&gt;
&lt;span style="color: #B8860B"&gt;local-previous-target-dir&lt;/span&gt; &lt;span style="color: #666666"&gt;:=&lt;/span&gt; ~/work/ota_base/mtk6582

&lt;span style="color: #008800; font-style: italic"&gt;# All apps from original ZIP, but has smali files chanded&lt;/span&gt;
&lt;span style="color: #B8860B"&gt;local-modified-apps&lt;/span&gt; &lt;span style="color: #666666"&gt;:=&lt;/span&gt;

&lt;span style="color: #B8860B"&gt;local-modified-jars&lt;/span&gt; &lt;span style="color: #666666"&gt;:=&lt;/span&gt;

&lt;span style="color: #008800; font-style: italic"&gt;# 哪些 MIUI 模块不包含在最终生成的 MIUI ROM 里。这里我们默认包含所有的 MIUI 模块。&lt;/span&gt;
&lt;span style="color: #B8860B"&gt;local-miui-removed-apps&lt;/span&gt; &lt;span style="color: #666666"&gt;:=&lt;/span&gt;

&lt;span style="color: #008800; font-style: italic"&gt;# 我们在移植过程中，使用了 MIUI 的 Phone 模块，但对 MIUI 的这个模块进行反编译并修改了部分 smali 代码使其功能正常。&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# 针对 jellybean42-mtk 这个分支，所有的 MIUI 模块定义在 patchrom/build/jellybean42-mtk.mk 文件里。&lt;/span&gt;
&lt;span style="color: #B8860B"&gt;local-miui-modified-apps&lt;/span&gt; &lt;span style="color: #666666"&gt;:=&lt;/span&gt; Phone

&lt;span style="color: #008800; font-style: italic"&gt;# density define&lt;/span&gt;
&lt;span style="color: #B8860B"&gt;local-density&lt;/span&gt; &lt;span style="color: #666666"&gt;:=&lt;/span&gt; XHDPI

&lt;span style="color: #008800"&gt;include phoneapps.mk&lt;/span&gt;

&lt;span style="color: #008800; font-style: italic"&gt;# To include the local targets before and after zip the final ZIP file,&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# and the local-targets should:&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# (1) be defined after including porting.mk if using any global variable(see porting.mk)&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# (2) the name should be leaded with local- to prevent any conflict with global targets&lt;/span&gt;
&lt;span style="color: #B8860B"&gt;local-pre-zip&lt;/span&gt; &lt;span style="color: #666666"&gt;:=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;local&lt;/span&gt;-pre-zip-misc
&lt;span style="color: #B8860B"&gt;local-after-zip&lt;/span&gt;&lt;span style="color: #666666"&gt;:=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;local&lt;/span&gt;-put-to-phone

&lt;span style="color: #008800; font-style: italic"&gt;# The local targets after the zip file is generated, could include &amp;#39;zip2sd&amp;#39; to&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# deliver the zip file to phone, or to customize other actions&lt;/span&gt;

&lt;span style="color: #008800"&gt;include $(PORT_BUILD)/porting.mk&lt;/span&gt;

&lt;span style="color: #008800; font-style: italic"&gt;# To define any local-target&lt;/span&gt;
&lt;span style="color: #B8860B"&gt;updater&lt;/span&gt; &lt;span style="color: #666666"&gt;:=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;ZIP_DIR&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;/META-INF/com/google/android/updater-script
&lt;span style="color: #B8860B"&gt;pre_install_data_packages&lt;/span&gt; &lt;span style="color: #666666"&gt;:=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;TMP_DIR&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;/pre_install_apk_pkgname.txt
&lt;span style="color: #00A000"&gt;local-pre-zip-misc&lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt;
    rm -rf &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;pre_install_data_packages&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; apk in &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;ZIP_DIR&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;/data/media/preinstall_apps/*.apk; &lt;span style="color: #AA22FF; font-weight: bold"&gt;do&lt;/span&gt;&lt;span style="color: #BB6622; font-weight: bold"&gt;\&lt;/span&gt;
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;AAPT&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt; d --values resources &lt;span style="color: #B8860B"&gt;$$&lt;/span&gt;apk | grep &lt;span style="color: #BB4444"&gt;&amp;#39;id=127 packageCount&amp;#39;&lt;/span&gt; | sed -e &lt;span style="color: #BB4444"&gt;&amp;quot;s/^.*name=//&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;pre_install_data_packages&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;;&lt;span style="color: #BB6622; font-weight: bold"&gt;\&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;done&lt;/span&gt;
    more &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;pre_install_data_packages&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt; | wc -l &amp;gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;ZIP_DIR&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;/system/etc/enforcecopyinglibpackages.txt
    more &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;pre_install_data_packages&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt; &amp;gt;&amp;gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;ZIP_DIR&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;/system/etc/enforcecopyinglibpackages.txt

&lt;span style="color: #00A000"&gt;out/framework2.jar &lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt; out/framework.jar

&lt;span style="color: #00A000"&gt;%.phone &lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt; out/%.jar
    @echo push -- to --- phone
    adb remount
    adb push &lt;span style="color: #B8860B"&gt;$&amp;lt;&lt;/span&gt; /system/framework
    adb shell chmod &lt;span style="color: #666666"&gt;644&lt;/span&gt; /system/framework/&lt;span style="color: #B8860B"&gt;$*&lt;/span&gt;.jar

&lt;span style="color: #00A000"&gt;%.sign-plat &lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt; out/%
    java -jar &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;TOOL_DIR&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;/signapk.jar &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;PORT_ROOT&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;/build/security/platform.x509.pem &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;PORT_ROOT&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;/build/security/platform.pk8  &lt;span style="color: #B8860B"&gt;$&amp;lt;&lt;/span&gt; &lt;span style="color: #B8860B"&gt;$&amp;lt;&lt;/span&gt;.signed
    @echo push -- to --- phone
    adb remount
    adb push &lt;span style="color: #B8860B"&gt;$&amp;lt;&lt;/span&gt;.signed /system/app/&lt;span style="color: #B8860B"&gt;$*&lt;/span&gt;
    adb shell chmod &lt;span style="color: #666666"&gt;644&lt;/span&gt; /system/app/&lt;span style="color: #B8860B"&gt;$*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="make-workspace"&gt;make workspace&lt;/h3&gt;
&lt;p&gt;在 patchrom/mtk6582 目录下运行 &lt;code&gt;make workspace&lt;/code&gt; 命令。这个命令会把 stockrom.zip 文件解压，并且反编译里面的 jar/apk 来作为移植的基础。在上述 makefile 内容下，会生成下面几个文件夹：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;android.policy.jar.out&lt;/li&gt;
&lt;li&gt;framework.jar.out&lt;/li&gt;
&lt;li&gt;framework-res&lt;/li&gt;
&lt;li&gt;mediatek-framework.jar.out&lt;/li&gt;
&lt;li&gt;secondary-framework.jar.out&lt;/li&gt;
&lt;li&gt;services.jar.out&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;深入理解make workspace&lt;/p&gt;
&lt;p&gt;可以阅读 patchrom/build　目录下的 makefile 文件来深入理解 patchrom　的编译系统。对 &lt;code&gt;make workspace&lt;/code&gt; 命令，实际上是根据 jellybean42-mtk.mk 里的 private-miui-jars，以及 framework-res.apk　和 makefile　里定义的 local-modified-apps 来决定反编译哪些内容的。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="make-firstpatch"&gt;make firstpatch&lt;/h3&gt;
&lt;p&gt;在 patchrom/mtk6582 目录下运行 &lt;code&gt;make firstpatch&lt;/code&gt; 命令。这个命令偿试自动合并 smali 文件。如果无法合并，会在 reject 目录下生成有冲突的文件。所以，运行这个命令后，我们只需要合并 reject 目录下的有冲突的文件即可完成 MIUI ROM 的移植工作。&lt;/p&gt;
&lt;p&gt;这个命令在 patchrom/mtk6582/temp 目录下生成的文件树如下：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;├── dst_smali_orig &lt;span style="color: #008800; font-style: italic"&gt;# 这个是底包 stockrom.zip 里反编译出来的系统 smali 文件&lt;/span&gt;
│   ├── android.policy.jar.out
│   ├── framework.jar.out
│   ├── mediatek-framework.jar.out
│   ├── secondary-framework.jar.out
│   └── services.jar.out
├── dst_smali_patched　# 这个是程序自动合并的目标 smali 文件
│   ├── android.policy.jar.out
│   ├── framework.jar.out
│   ├── mediatek-framework.jar.out
│   ├── secondary-framework.jar.out
│   └── services.jar.out
├── new_smali &lt;span style="color: #008800; font-style: italic"&gt;# 这个是 MIUI ROM 里反编译出来的系统 smali 文件&lt;/span&gt;
│   ├── android.policy.jar.out
│   ├── framework.jar.out
│   ├── mediatek-framework.jar.out
│   ├── secondary-framework.jar.out
│   └── services.jar.out
├── old_smali　# 这个是 AOSP 里反编译出来的系统 smali 文件
│   ├── android.policy.jar.out
│   ├── framework.jar.out
│   ├── mediatek-framework.jar.out
│   ├── secondary-framework.jar.out
│   └── services.jar.out
└── reject　# 这个是由于冲突程序无法自动合并，需要手动合并的 smali 文件
    ├── android.policy.jar.out
    ├── framework.jar.out
    ├── secondary-framework.jar.out
    └── services.jar.out
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以阅读 patchrom/build 和 patchrom/tools 两个目录下的 makefile 和 shell 源码来理解 make firstpatch 过程到底做了什么事情。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;关于自动合并&lt;/p&gt;
&lt;p&gt;自动合并会把一些差异自动合并进 dst_smali_patched 目录。这个合并过程是怎么样的呢？可以阅读 patchrom/tools/patch_miui_framework.sh 文件来获取详细信息。这里总结自动合并的过程如下：1) 用 diff 命令计算 old_smali 和 new_smali 两个文件夹下的每个文件的补丁 .diff 文件。2) 用 patch 命令把计算出来的 .diff 文件逐个给 dst_smali_orig 目录下的对应文件打补丁，自动合并成功的文件最终生成成 dst_smali_patched 目录下。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="reject"&gt;手动合并 reject 目录&lt;/h3&gt;
&lt;p&gt;看起来好简单，其实挑战刚刚开始，要手动合并 reject 目录下的内容不是件容易的事情。即使合并完，后面的调试过程也是痛苦异常。不过也别灰心。办法总比困难多。掌握了基本原理，那么合并过程和调试过程其实还是有规律可以遵循的。在开始这个痛苦过程前，需要先掌握 smali 语法以及 Dalvik　虚拟机的字节码的函义。关于 Dalvik 虚拟机字节码，这个&lt;a href="http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html"&gt;文档&lt;/a&gt;可以查阅。&lt;/p&gt;
&lt;p&gt;手动合并 smali 代码的流程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用文本编辑器逐个打开 &lt;code&gt;reject&lt;/code&gt; 目录下的所有文件，找出冲突的代码块&lt;/li&gt;
&lt;li&gt;用 BeyondCompare/Meld 工具去比较 old_smali 和 new_smali，找出冲突代码块的位置&lt;/li&gt;
&lt;li&gt;通过比较阅读 smali 文件理解 MIUI 在 AOSP 的基础修改了什么逻辑&lt;/li&gt;
&lt;li&gt;用 BeyondCompare/Meld 工具去比较 dst_smali_orig 和 dst_smali_patched，找出冲突代码块的位置&lt;/li&gt;
&lt;li&gt;根据步骤 3 的逻辑修改，把这个修改合并进 dst_smali_patched 目录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个过程刚做很痛苦，但有做几次积累一定经验后，就轻松了。过程中可能还要结合 AOSP 的 JAVA 源码阅读来理解逻辑。&lt;/p&gt;
&lt;p&gt;目标 smali 代码合并进 dst_smali_patched 之后，还需要把这个结果合并回 patchrom/mtk6582 目录下的相应 smali 文件里。比如，需要把 patchrom/mtk6582/android.policy.jar.out 目录和 patchrom/mtk6582/temp/dst_smali_patched/android.policy.jar.out 目录相比较，把最终结果合并进 patchrom/mtk6582/android.policy.jar.out　里。因为 patchrom 编译工具在生成这些需要合并的文件时，把 smali 文件里的行号删除了。这样有利于自动合并和手动合并，而不会被行号干扰。而我们合并完真正进行编译时，实际上参加编译的是 patchrom/mtk6582/android.policy.jar.out 下的 smali 文件。所以必须合并回去才能真正把 MIUI 合并过去。&lt;/p&gt;
&lt;h3 id="make-fullota"&gt;make fullota&lt;/h3&gt;
&lt;p&gt;合并完成后，可以在 patchrom/mtk6582 目录下运行 &lt;code&gt;make fullota&lt;/code&gt; 来生成目标文件 MIUI_MTK6582.zip。如果你人品足够好，那么可能一步就生成了。但基本上没有这么好的运气。过程中会有 smali 错误。需要根据提示去做适当的修改。编译通过后，就可以把 MIUI_MTK6582.zip 文件通过 recovery 方式升级到手机看移植后的效果。&lt;/p&gt;
&lt;h2 id="_4"&gt;结语&lt;/h2&gt;
&lt;p&gt;本文分析了使用 patchrom 移植 MIUI 的全过程，详细解释了 patchrom 编译系统及步骤。这个对理解 patchrom 移植的原理有比较大的帮助。移植过程中可能会碰到各种各样的问题。这些问题都需要一些丰富的知识去识别和解决。下一篇准备介绍一下移植过程中遇到的一些问题，解决方法以及找到解决方法的分析过程。&lt;/p&gt;</summary><category term="android"></category><category term="patchrom"></category><category term="miui"></category></entry><entry><title>Android电话本核心数据结构</title><link href="http://blog.kamidox.com/android-contacts-provider.html" rel="alternate"></link><updated>2014-11-27T23:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-11-27:android-contacts-provider.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#contact-provider"&gt;Contact Provider结构&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#rawcontacts"&gt;RawContacts表&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#raw-contact"&gt;raw contact的重要字段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;注意事项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;一个例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#data"&gt;Data表&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_4"&gt;描述性字段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;通用数据字段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;类型相关的字段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;类型相关的字段名类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#contacts"&gt;Contacts表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;从同步适配器来的数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_9"&gt;需要的权限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#user-profile"&gt;User Profile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#contacts-provider"&gt;Contacts Provider元数据&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#contacts-provider_1"&gt;读写Contacts Provider&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_10"&gt;查询记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_11"&gt;批量操作&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_12"&gt;释放点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_13"&gt;反向引用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_14"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;简介&lt;/h2&gt;
&lt;p&gt;Contact Provider是Android系统提供的一个功能强大且灵活的系统组件，用来管理系统里的所有联系人数据。我们在Android手机是看到的联系人信息的数据来源就是由Contact Provider提供的，我们也可以自己写程序来访问这些联系人数据，也可以把这些数据和我们自己的网络服务进行同步和备份。由于Contact Provider管理了相当多类型的数据源，对一个联系人又同时管理着非常多的信息，结果就导致Contact Provider组织结构异常复杂。本文包含以下内容来介绍Contact Provider：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Contact Provider的基础数据结构&lt;/li&gt;
&lt;li&gt;怎么样从Contact Provider里获取联系人数据&lt;/li&gt;
&lt;li&gt;怎么样修改Contact Provider里的联系人数据&lt;/li&gt;
&lt;li&gt;怎么样写一个同步适配器(sync adapter)来实现联系人数据的同步&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文假设你已经了解了Android的content provider机制。Android自带的一个示例程序SampleSyncAdapter很好地演示了如何写一个同步适配器，来把联系人数据同步到部署在Google Web Service上网络服务上。&lt;/p&gt;
&lt;h2 id="contact-provider"&gt;Contact Provider结构&lt;/h2&gt;
&lt;p&gt;Contact Provider是Android里的一个content provider组件。针对一个联系人，它维护三种类型的数据，分别用三个表来维护这些数据。三个表都定义在类&lt;code&gt;ContactsContract&lt;/code&gt;里，它定义了每个表的content URL，列名称等常量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ContactsContract.Contacts&lt;br /&gt;
  这个表的每一行表示一个联系人，它是由&lt;code&gt;RawContacts&lt;/code&gt;表里的数据聚合而来的。&lt;/li&gt;
&lt;li&gt;ContactsContract.RawContacts&lt;br /&gt;
  针对不同的帐户，这个表的第一行包含了一个联系人的概要信息。&lt;/li&gt;
&lt;li&gt;ContactsContract.Data&lt;br /&gt;
  这个表保存真正的联系人数据，比如电子邮件，电话号码等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义在&lt;code&gt;ContactsContract&lt;/code&gt;里的其他表，用来辅助实现Contact Provider的其他功能。三个核心的表Contacts, RawContacts, Data的相互关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="contacts_structure" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/contacts_structure.png" /&gt;&lt;/p&gt;
&lt;h3 id="rawcontacts"&gt;RawContacts表&lt;/h3&gt;
&lt;p&gt;一个raw contacts表示一个来自特定帐户类型和名称的联系人数据。因为Contact Provider允许多个在线服务作为数据的来源，所以Contact Provider允许多个raw contacts来对应同一个联系人。用户也可以从多个帐户中合并多个raw contacts来生成一个联系人数据。&lt;/p&gt;
&lt;p&gt;raw contact的大部分数据不保存在&lt;code&gt;RawContacts&lt;/code&gt;表里，而是通过一行或多行数据保存在&lt;code&gt;ContactsContract.Data&lt;/code&gt;表里。&lt;code&gt;Data&lt;/code&gt;表里的每行数据都有一个&lt;code&gt;Data.RAW_CONTACT_ID&lt;/code&gt;，它与表&lt;code&gt;RawContacts&lt;/code&gt;的&lt;code&gt;RawContacts._ID&lt;/code&gt;是对应的。即表&lt;code&gt;Data&lt;/code&gt;里所有满足&lt;code&gt;Data.RAW_CONTACT_ID == RawContacts._ID&lt;/code&gt;的记录，都属于表&lt;code&gt;RawContacts&lt;/code&gt;里由&lt;code&gt;RawContacts._ID&lt;/code&gt;指定的这条记录的数据。&lt;/p&gt;
&lt;h4 id="raw-contact"&gt;raw contact的重要字段&lt;/h4&gt;
&lt;p&gt;下表是raw contact的表的一些重要字段。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段名称&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ACCOUNT_NAME&lt;/td&gt;
&lt;td&gt;raw contact的数据来源的帐户名称。比如对Google帐户而言，这个字段的值就是用户的Gmail地址。&lt;/td&gt;
&lt;td&gt;这个字段的数据格式是由帐户类型决定的，不一定要电子邮件地址。只要服务提供方能保证帐户名的唯一性即可。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ACCOUNT_TYPE&lt;/td&gt;
&lt;td&gt;raw contact的数据来源的帐户类型。比如Google帐户的帐户类型是&lt;strong&gt;com.google&lt;/strong&gt;，这个值由一般由帐户提供方的域名来保证唯一性，不和别的帐户冲突。&lt;/td&gt;
&lt;td&gt;一个帐户类型一般会和一个同步适配器关联起来，来提供数据同步服务。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETED&lt;/td&gt;
&lt;td&gt;删除标志位&lt;/td&gt;
&lt;td&gt;Contact Provider使用这个标志位来管理用户删除，但还没同步到服务器上的记录。当同步适配器开始同步，从服务器上删除了这个记录之后，这条记录才在本地删除。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_2"&gt;注意事项&lt;/h4&gt;
&lt;p&gt;下面是关于&lt;code&gt;RawContacts&lt;/code&gt;表的重要的注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;联系人名称并不保存在&lt;code&gt;ContactsContract.RawContacts&lt;/code&gt;表里，而是保存在&lt;code&gt;ContactsContract.Data&lt;/code&gt;表里。它的数据类型是&lt;code&gt;ContactsContract.CommonDataKinds.StructuredName&lt;/code&gt;。而且每个联系人在Data表里只有一行表示联系人名字的数据。&lt;/li&gt;
&lt;li&gt;要在raw contact表里保存属于指定帐户数据，必须先通过&lt;code&gt;AccountManager&lt;/code&gt;注册帐户。可以通过提示用户添加帐户类型和帐户名称到系统里来实现注册帐户的目的。如果你不这样做，Contact Provider会自动删除raw contact表里属于这个帐户的数据。&lt;br /&gt;
  例如，如果你需要你的应用程序维护来自你的网络服务&lt;code&gt;"com.example.dataservice"&lt;/code&gt;的联系人数据，帐户的用户名是&lt;code&gt;"user@dataservice.example.com"&lt;/code&gt;。用户必须先在手机里新建一个帐户，其帐户类型是&lt;code&gt;"com.example.dataservice"&lt;/code&gt;，帐户名是&lt;code&gt;"user@dataservice.example.com"&lt;/code&gt;。添加帐户成功后，你的应用程序才能添加属于这个帐户的联系人数据到raw contact表里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="_3"&gt;一个例子&lt;/h4&gt;
&lt;p&gt;为了更好的理解raw contact的机制，我们假设有个用户叫&amp;rdquo;Emily Dickinson&amp;rdquo;，她在设备里添加了下面三个帐户：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;emily.dickinson@gmail.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;emilyd@gmail.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Twitter account "belle_of_amherst"&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并且都启用了自动同步功能。&lt;/p&gt;
&lt;p&gt;假设Emily在电脑上打开浏览器，用&lt;code&gt;emily.dickinson@gmail.com&lt;/code&gt;登录Gmail，打开通讯录，添加了&amp;rdquo;Thomas Higginson&amp;rdquo;。过了一会儿，她又用&lt;code&gt;emilyd@gmail.com&lt;/code&gt;登录Gmail，然后向&amp;rdquo;Thomas Higginson&amp;rdquo;发了封电子邮件，这个操作会自动把&amp;rdquo;Thomas Higginson&amp;rdquo;添加进联系人里。她也在Twitter上关注了&amp;rdquo;colonel_tom&amp;rdquo; (Thomas Higginson&amp;rsquo;s Twitter ID) 。&lt;/p&gt;
&lt;p&gt;上面的操作，会导致Contacts Provider创建了三个raw contacts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个是和&lt;code&gt;emily.dickinson@gmail.com&lt;/code&gt;帐户关联的叫&amp;rdquo;Thomas Higginson&amp;rdquo;的联系人。这个联系人所属的帐户类型是Google。&lt;/li&gt;
&lt;li&gt;第二个是和&lt;code&gt;emilyd@gmail.com&lt;/code&gt;帐户关联的叫&amp;rdquo;Thomas Higginson&amp;rdquo;的raw contact。这个联系人的帐户类型也是Google。虽然第二个联系人和第一个的名字一样，但它属于另外一个帐户名下的联系人。&lt;/li&gt;
&lt;li&gt;第三个是和Twitter帐户&amp;rdquo;belle_of_amherst&amp;rdquo;关联的叫&amp;rdquo;Thomas Higginson&amp;rdquo;的联系人。它的帐户类型是Twitter.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="data"&gt;Data表&lt;/h3&gt;
&lt;p&gt;前面提过，Data表是用来保存联系人数据的，通过&lt;code&gt;Data.RAW_CONTACT_ID&lt;/code&gt;和raw contact里的&lt;code&gt;RawContacts._ID&lt;/code&gt;关联起来。这样就允许一个raw contact可以有多个相同类型的数据保存在Data表里，比如一个联系人可以有多个电子邮件地址，多个电话号码等。例如，属于&lt;code&gt;emilyd@gmail.com&lt;/code&gt;帐户的联系人&amp;rdquo;Thomas Higginson&amp;rdquo;有一个家庭电子邮件&lt;code&gt;thigg@gmail.com&lt;/code&gt;以及一个工作电子邮件&lt;code&gt;thomas.higginson@gmail.com&lt;/code&gt;，Contact Provider保存这两个电子邮件地址在Data表里，并通过&lt;code&gt;Data.RAW_CONTACT_ID&lt;/code&gt;和&lt;code&gt;RawContacts&lt;/code&gt;表里的数据关联。&lt;/p&gt;
&lt;p&gt;需要注意，不同类型的数据全部保存在&lt;code&gt;Data&lt;/code&gt;表里。联系人名字，邮件地址，电话号码，照片，网址等等，全部是保存在&lt;code&gt;Data&lt;/code&gt;表里的。为了实现这样的目的，Data表里包含一些描述性的字段来描述数据。还包含了一些真正的用来保存数据的字段。&lt;/p&gt;
&lt;h4 id="_4"&gt;描述性字段&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;RAW_CONTACT_ID&lt;br /&gt;
  用来和&lt;code&gt;RawContacts._ID&lt;/code&gt;字段进行关联，以表示行数据是属于哪个raw contact的。&lt;/li&gt;
&lt;li&gt;MIMETYPE&lt;br /&gt;
  数据类型，Contact Provider使用定义&lt;code&gt;ContactsContract.CommonDataKinds&lt;/code&gt;里的子类来区别不同的数据类型。&lt;/li&gt;
&lt;li&gt;IS_PRIMARY&lt;br /&gt;
  如果一个数据类型可以出现多次，则这个字段用来标示出这种数据类型的主数据。比如一个联系人有多个电话号码，则其中一个的IS_PRIMARY可以设置为非零值，则这个号码就是主电话号码。有些应用程序可以利用这一特性地优先选择主电话号码来拨号等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="_5"&gt;通用数据字段&lt;/h4&gt;
&lt;p&gt;一个Data表里的记录，总共有15个通用数据字段，从DATA1到DATA15。同时还有4个只能给同步适配器使用的字段SYNC1到SYNC4。&lt;/p&gt;
&lt;p&gt;DATA1字段会被索引起来，Contact Provider默认问题认为这个字段保存的是最经常被访问的数据，比如对Email数据而言，这个字段保存的就是Email地址。&lt;/p&gt;
&lt;p&gt;通常情况下，DATA15被用来保存二进制数据(BLOB)，比如照片的二进制数据等。&lt;/p&gt;
&lt;h4 id="_6"&gt;类型相关的字段&lt;/h4&gt;
&lt;p&gt;DATA表里的每一行保存一种类型的数据，为了方便地访问不同类型的数据，Contact Provider也提供了访问具体类型数据的字段的方法，这些类型相关的字段别名由定义在&lt;code&gt;ContactsContract.CommonDataKinds&lt;/code&gt;里的子类来定义。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;ContactsContract.CommonDataKinds.Email&lt;/code&gt;类定义了MIME Type为&lt;code&gt;Email.CONTENT_ITEM_TYPE&lt;/code&gt;的数据，要访问Email地址时，可以直接访问&lt;code&gt;Email.ADDRESS&lt;/code&gt;，它的值其实就是&amp;rdquo;data1&amp;rdquo;，就是通用数据字段的DATA1字段。&lt;/p&gt;
&lt;div class="admonition caution"&gt;
&lt;p class="admonition-title"&gt;警告&lt;/p&gt;
&lt;p&gt;当向&lt;code&gt;ContactsContract.Data&lt;/code&gt;表中添加自定义数据时，不要使用&lt;code&gt;ContactsContract.CommonDataKinds&lt;/code&gt;里预定义的MIME类型。否则你可以丢失数据或引起Contact Provider不能正常工作。例如，你&lt;strong&gt;不能&lt;/strong&gt;向Data表里添加一行数据，然后其MIME type定义为&lt;code&gt;Email.CONTENT_ITEM_TYPE&lt;/code&gt;，其值保存在字段DATA1上，且其值是用户名而不是Email地址。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;下图就是类型相关字段别名和通用数据字段的关联关系图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="data_columns" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/data_columns.png" /&gt;&lt;/p&gt;
&lt;h4 id="_7"&gt;类型相关的字段名类&lt;/h4&gt;
&lt;p&gt;下表列出了最常用的类型相关的别名字段类&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;别名类名称&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.CommonDataKinds.StructuredName&lt;/td&gt;
&lt;td&gt;名字&lt;/td&gt;
&lt;td&gt;只能有一个名字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.CommonDataKinds.Photo&lt;/td&gt;
&lt;td&gt;照片&lt;/td&gt;
&lt;td&gt;只能有一个照片&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.CommonDataKinds.Email&lt;/td&gt;
&lt;td&gt;电子邮件&lt;/td&gt;
&lt;td&gt;可以有多个电子邮件地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.CommonDataKinds.GroupMembership&lt;/td&gt;
&lt;td&gt;联系人所在的组&lt;/td&gt;
&lt;td&gt;联系人的组是可选项&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="contacts"&gt;Contacts表&lt;/h3&gt;
&lt;p&gt;Contact Provider会从RawContacts和Data表里收集数据，组合生成一个记录放在Contacts表里。Contact Provider负责在这个表里生成记录，合并数据。应用程序和同步适配器都不能向这个表里添加记录，Contacts表里的一些字段还是只读的。&lt;/p&gt;
&lt;div class="admonition hint"&gt;
&lt;p class="admonition-title"&gt;注意&lt;/p&gt;
&lt;p&gt;如果你试图通过ContentResolve的insert()方法向Contacts表里添加记录，会得到一个&lt;code&gt;UnsupportedOperationException&lt;/code&gt;的错误。如果试图修改只读的字段，也会被忽略。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Contact Provider会根据raw contact自动向Contacts表里添加一条记录。如果raw contact数据改变，导致Contacts表里原先和raw contact关联记录不复存在了，那么Contact Provider也会自动向Contacts里自动添加一条记录。如果应用程序或同步适配器添加了一条raw contact记录，且这条记录与Contacts表里的某条记录是一样的，那么Contact Provider会负责把这条新增加的记录和原来那条记录合并。&lt;/p&gt;
&lt;p&gt;Contact Provider通过&lt;code&gt;Contacts._ID&lt;/code&gt;和&lt;code&gt;RawContacts.CONTACT_ID&lt;/code&gt;把Contacts表和RawContacts表的数据关联起来。即一个Contacts表里的记录可以与多个RawContacts表里的记录对应。给定&lt;code&gt;Contacts._ID&lt;/code&gt;的值，所有&lt;code&gt;RawContacts.CONTACT_ID&lt;/code&gt;为这个值的记录都与Contacts里的这条记录关联。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ContactsContract.Contacts&lt;/code&gt;表还包含了一个&lt;code&gt;LOOKUP_KEY&lt;/code&gt;字段，这个字段永久地和某个特定的联系人关联起来。这个字段存在的意义在于，Contacts表是由Contacts Provider自动维护的，当发生数据合并或同步适配器修改raw contacts时，Contacts._ID的值是会发生变化的。而&lt;code&gt;Contacts.LOOKUP_KEY&lt;/code&gt;在这个过程中，是不会发生变化的。&lt;code&gt;Contacts.CONTENT_LOOKUP_URI&lt;/code&gt;和&lt;code&gt;LOOKUP_KEY&lt;/code&gt;字段组合起来所代表的联系人依然指向了原来的联系人。所以，我们可以用&lt;code&gt;LOOKUP_KEY&lt;/code&gt;来连接一个我们感兴趣的联系人。&lt;/p&gt;
&lt;p&gt;下图阐明了三个主要的表之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;img alt="contacts_tables" src="https://raw.githubusercontent.com/kamidox/blogs/master/images/contacts_tables.png" /&gt;&lt;/p&gt;
&lt;h3 id="_8"&gt;从同步适配器来的数据&lt;/h3&gt;
&lt;p&gt;用户可以在设备里直接输入联系人数据，联系人数据也可以通过同步适配器自动地在设备和云端进行同步。同步适配器在系统后台运行，由系统控制，通过ContentResolver来管理数据。&lt;/p&gt;
&lt;p&gt;在Android系统上，同步适配器的云端服务是由帐户类型来区分的。一个同步适配器对应一个帐户类型。但同步适配器可以支持同一个帐户类型下的多个帐户名，就象可以在设备上登录多个Google帐户一样。下面的文字描述了帐户类型和帐户名称与同步适配器的关系。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帐户类型&lt;br /&gt;
  唯一地标识了用户存储数据的云端服务。大多数时候，用户必须通过云端服务鉴权才能使用服务。例如，Google联系人就是一个值为&amp;rdquo;com.google&amp;rdquo;的帐户类型。这个值与AccountManager类里的帐户类型的值是一样的。&lt;/li&gt;
&lt;li&gt;帐户名称&lt;br /&gt;
  唯一地标识了某个帐户类型的一个特定的帐户。Google联系人帐户和Google帐户是相同的，它们都用Gmail地址作为帐户名称。其他的云端服务可能使用一个字符串或一个数字来表示帐户名称，但必须注意的是，云端服务必须保证在同一个帐户类型里，帐户名称可以唯一地区分一个帐户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;帐户类型可以不唯一，即一个设备里可以有多个相同帐户类型的帐户。比如，设备可以登录多个Google帐户。帐户名称一般是唯一的，至少在同一个帐户类型里必须是唯一的。帐户类型和帐户名称结合起来，通过同步适配器，共同标识了一个在Contact Provider和云端服务之间的一个特定同步数据流。&lt;/p&gt;
&lt;p&gt;如果你想在你的云端服务和Contact Provider之间同步数据，你必须实现一个同步适配器。后面章节的文章会提到这个话题。&lt;/p&gt;
&lt;h3 id="_9"&gt;需要的权限&lt;/h3&gt;
&lt;p&gt;需要访问Contact Provider的应用程序必须取得下面的权限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读权限&lt;br /&gt;
  需要在应用程序的AndroidManifest.xml里，添加&lt;code&gt;&amp;lt;uses-permission android:name="android.permission.READ_CONTACTS"&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;写权限&lt;br /&gt;
  需要在应用程序的AndroidManifest.xml里，添加&lt;code&gt;&amp;lt;uses-permission android:name="android.permission.WRITE_CONTACTS"&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个权限不包含User Profile数据的读写。user profile使用单独的权限来控制读写。&lt;/p&gt;
&lt;h3 id="user-profile"&gt;User Profile&lt;/h3&gt;
&lt;p&gt;User Profile就是在设备联系人应用程序里看到的&amp;rdquo;我的个人资料&amp;rdquo;，用来描述本设备所有人信息的一个数据。&lt;code&gt;ContactsContract.Contacts&lt;/code&gt;表里有一行数据用来表现user profile。这个数据用来描述设备所有人本身，而不是设备所有人的联系人。&lt;/p&gt;
&lt;p&gt;读写user profile除了读写联系人数据外，还需要额外的权限，他们是&amp;rdquo;android.permission.READ_PROFILE&amp;rdquo;和&amp;rdquo;android.permission.WRITE_PROFILE&amp;rdquo;。这两个都是在API 14的时候才加进去的。&lt;/p&gt;
&lt;p&gt;要获取user profile，可以使用ContentResolver通过&lt;code&gt;ContactsContract.Profile.CONTENT_URI&lt;/code&gt;来获取，下面是获取user profile的示例代码：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;// Sets the columns to retrieve for the user profile&lt;/span&gt;
mProjection &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;new&lt;/span&gt; String&lt;span style="color: #666666"&gt;[]&lt;/span&gt;
    &lt;span style="color: #666666"&gt;{&lt;/span&gt;
        Profile&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;_ID&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
        Profile&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;DISPLAY_NAME_PRIMARY&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
        Profile&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;LOOKUP_KEY&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
        Profile&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;PHOTO_THUMBNAIL_URI&lt;/span&gt;
    &lt;span style="color: #666666"&gt;};&lt;/span&gt;

&lt;span style="color: #008800; font-style: italic"&gt;// Retrieves the profile from the Contacts Provider&lt;/span&gt;
mProfileCursor &lt;span style="color: #666666"&gt;=&lt;/span&gt; getContentResolver&lt;span style="color: #666666"&gt;().&lt;/span&gt;&lt;span style="color: #BB4444"&gt;query&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;
                Profile&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CONTENT_URI&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
                mProjection &lt;span style="color: #666666"&gt;,&lt;/span&gt;
                &lt;span style="color: #AA22FF; font-weight: bold"&gt;null&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
                &lt;span style="color: #AA22FF; font-weight: bold"&gt;null&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
                &lt;span style="color: #AA22FF; font-weight: bold"&gt;null&lt;/span&gt;&lt;span style="color: #666666"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="contacts-provider"&gt;Contacts Provider元数据&lt;/h3&gt;
&lt;p&gt;Contacts Provider管理了本地的所有联系人数据，追踪他们的状态。这些元数据就是为了实现这些功能所需要的。这些元数据保存在RawContacts，Contacts, Data等表格记录里，同时还保存在&lt;code&gt;ContactsContract.Settings&lt;/code&gt;和&lt;code&gt;ContactsContract.SyncState&lt;/code&gt;表里。下面汇总了这些元数据的位置及其作用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表名称&lt;/th&gt;
&lt;th&gt;字段名称&lt;/th&gt;
&lt;th&gt;字段值&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.RawContacts&lt;/td&gt;
&lt;td&gt;DIRTY&lt;/td&gt;
&lt;td&gt;0: 数据没变化；1: 上次同步以来数据变化了&lt;/td&gt;
&lt;td&gt;这个数据由Contact Provider维护。当用户修改记录时，这个值自动变为1；而当同步适配器修改记录时，在其修改数据的URI上，会带上&lt;code&gt;CALLER_IS_SYNCADAPTER&lt;/code&gt;参数，以表示是同步适配器修改的，不需要标记为脏数据。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.RawContacts&lt;/td&gt;
&lt;td&gt;VERSION&lt;/td&gt;
&lt;td&gt;数据的版本&lt;/td&gt;
&lt;td&gt;当RawContacts表里的记录数据改变时，Contacts Provider自动增加这个值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.Data&lt;/td&gt;
&lt;td&gt;DATA_VERSION&lt;/td&gt;
&lt;td&gt;数据的版本&lt;/td&gt;
&lt;td&gt;当Data表里的记录数据改变时，Contacts Provider自动增加这个值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.RawContacts&lt;/td&gt;
&lt;td&gt;SOURCE_ID&lt;/td&gt;
&lt;td&gt;字符串，用来唯一标识这个记录来自哪个帐户的。&lt;/td&gt;
&lt;td&gt;当同步适配器添加记录时，这个字段必须设置为服务器端针对这个记录的唯一标识。当设备端用户添加记录时，这个字段为空，这样就告诉同步适配器这个字段是用户新增的，必须在服务器端新建一条记录，并用这条记录的SOURCE_ID值来更新用户添加的这条记录。特别地，这个字段必须在一个帐户里保持全局唯一性，且必须在同步过程中保持不变。即同步前后，这个字段需要标识出相同的记录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.Groups&lt;/td&gt;
&lt;td&gt;GROUP_VISIBLE&lt;/td&gt;
&lt;td&gt;0: 属于这个值的记录在应用程序里不可见；1: 这个组的联系人可见&lt;/td&gt;
&lt;td&gt;这个字段可以让服务端设置组的可见性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.Settings&lt;/td&gt;
&lt;td&gt;UNGROUPED_VISIBLE&lt;/td&gt;
&lt;td&gt;0: 未分组的联系人不可见；1: 未分组的联系人可见&lt;/td&gt;
&lt;td&gt;默认情况下，未分组的联系人是不可见的。通过修改&lt;code&gt;ContactsContract.Settings&lt;/code&gt;表里的这个字段，可以设置应用程序显示未分组的联系人。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ContactsContract.SyncState&lt;/td&gt;
&lt;td&gt;所有字段&lt;/td&gt;
&lt;td&gt;使用这个表来保存同步适配器的元数据&lt;/td&gt;
&lt;td&gt;用这个表格来保存同步后的状态信息以及所有和同步相关的数据，比如时间戳等。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="contacts-provider_1"&gt;读写Contacts Provider&lt;/h2&gt;
&lt;p&gt;本节内容描述如何访问Contacts Provider的数据，主要集中在下面几个话题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;联系人记录查询&lt;/li&gt;
&lt;li&gt;分批修改数据&lt;/li&gt;
&lt;li&gt;通过Intent来获取或修改记录&lt;/li&gt;
&lt;li&gt;数据完整性检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过同步适配器修改联系人数据将在下面的章节中单独描述。&lt;/p&gt;
&lt;h3 id="_10"&gt;查询记录&lt;/h3&gt;
&lt;p&gt;因为Contacts Provider数据是按照三个核心表(Contacts, RawContacts, Data)按照层次结构组织起来的，应用程序经常需要获取一个联系人的所有信息，这就需要从这三个表里里去联合查询。比如从Contacts表里找到一个记录，然后根据Contacts._ID从RawContacts表里关联RawContacts.CONTACT_ID去查询与这个Contacts记录关联的RawContacts记录。接着，再根据找到的关联的RawContacts记录的RawContacts._ID的值从Data表里，根据Data.RAW_CONTACTS_ID去查询所有的关联记录。再把这些记录组合起来，最后得到了一个完整的联系人信息。为了达成这个目的，Contact Provider提供了&lt;em&gt;ContactsContract.Contacts.Entity&lt;/em&gt;类来实现这个功能，自动实现了这些表的联合查询。&lt;/p&gt;
&lt;p&gt;一个entity表是从Contacts, RawContacts, Data三个表里把关联的记录合并起来，从中选择一些列来组合起来的。当从entity表里查询数据时，需要提供一个感兴趣的字段列表(projection)，查询结果是一个游标(cursor)，里面包含一个个联系人的所有信息数据。例如，指定一个联系人的名字，查询出这个联系人的所有电子邮件，那么你将得到包含一行数据的游标，这行数据里有名字以及多个电子邮件的数据。&lt;/p&gt;
&lt;p&gt;entity表让查询操作更简单。你可以一次从不同的表里获取出联系人的所有信息。而不需要先从父表里查询数据，得到ID，再根据ID去子表里查询。而且，Contacts Provider把这些联合查询操作在一个事务里完成，这样保证了查询到的数据的一致性。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;注意&lt;/p&gt;
&lt;p&gt;一个entity一般没有包含Contacts表及其子表的所有字段，如果试图访问这些不在entity表里的字段，会有异常抛出。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;下面的代码演示了如何从entity里获取记录数据。一个联系人应用程序一般有个列表显示联系人，点击后显示这个记录的详细信息，下面的代码是显示详细信息的一部分代码。即根据联系人的ID去获取所有的联系人信息。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    &lt;span style="color: #008800; font-style: italic"&gt;/*&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * Appends the entity path to the URI. In the case of the Contacts Provider, the&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * expected URI is content://com.google.contacts/#/entity (# is the ID value).&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     */&lt;/span&gt;
    mContactUri &lt;span style="color: #666666"&gt;=&lt;/span&gt; Uri&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withAppendedPath&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;
            mContactUri&lt;span style="color: #666666"&gt;,&lt;/span&gt;
            ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Contacts&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Entity&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CONTENT_DIRECTORY&lt;/span&gt;&lt;span style="color: #666666"&gt;);&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Initializes the loader identified by LOADER_ID.&lt;/span&gt;
    getLoaderManager&lt;span style="color: #666666"&gt;().&lt;/span&gt;&lt;span style="color: #BB4444"&gt;initLoader&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;
            LOADER_ID&lt;span style="color: #666666"&gt;,&lt;/span&gt;  &lt;span style="color: #008800; font-style: italic"&gt;// The identifier of the loader to initialize&lt;/span&gt;
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;null&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;       &lt;span style="color: #008800; font-style: italic"&gt;// Arguments for the loader (in this case, none)&lt;/span&gt;
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;this&lt;/span&gt;&lt;span style="color: #666666"&gt;);&lt;/span&gt;      &lt;span style="color: #008800; font-style: italic"&gt;// The context of the activity&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Creates a new cursor adapter to attach to the list view&lt;/span&gt;
    mCursorAdapter &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;new&lt;/span&gt; SimpleCursorAdapter&lt;span style="color: #666666"&gt;(&lt;/span&gt;
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;this&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;                        &lt;span style="color: #008800; font-style: italic"&gt;// the context of the activity&lt;/span&gt;
            R&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;layout&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;detail_list_item&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;   &lt;span style="color: #008800; font-style: italic"&gt;// the view item containing the detail widgets&lt;/span&gt;
            mCursor&lt;span style="color: #666666"&gt;,&lt;/span&gt;                     &lt;span style="color: #008800; font-style: italic"&gt;// the backing cursor&lt;/span&gt;
            mFromColumns&lt;span style="color: #666666"&gt;,&lt;/span&gt;                &lt;span style="color: #008800; font-style: italic"&gt;// the columns in the cursor that provide the data&lt;/span&gt;
            mToViews&lt;span style="color: #666666"&gt;,&lt;/span&gt;                    &lt;span style="color: #008800; font-style: italic"&gt;// the views in the view item that display the data&lt;/span&gt;
            &lt;span style="color: #666666"&gt;0);&lt;/span&gt;                          &lt;span style="color: #008800; font-style: italic"&gt;// flags&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Sets the ListView&amp;#39;s backing adapter.&lt;/span&gt;
    mRawContactList&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;setAdapter&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;mCursorAdapter&lt;span style="color: #666666"&gt;);&lt;/span&gt;
    &lt;span style="color: #666666"&gt;...&lt;/span&gt;
&lt;span style="color: #AA22FF"&gt;@Override&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;public&lt;/span&gt; Loader&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;Cursor&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color: #00A000"&gt;onCreateLoader&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #00BB00; font-weight: bold"&gt;int&lt;/span&gt; id&lt;span style="color: #666666"&gt;,&lt;/span&gt; Bundle args&lt;span style="color: #666666"&gt;)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;/*&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * Sets the columns to retrieve.&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * RAW_CONTACT_ID is included to identify the raw contact associated with the data row.&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * DATA1 contains the first column in the data row (usually the most important one).&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * MIMETYPE indicates the type of data in the data row.&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     */&lt;/span&gt;
    String&lt;span style="color: #666666"&gt;[]&lt;/span&gt; projection &lt;span style="color: #666666"&gt;=&lt;/span&gt;
        &lt;span style="color: #666666"&gt;{&lt;/span&gt;
            ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Contacts&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Entity&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;RAW_CONTACT_ID&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
            ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Contacts&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Entity&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;DATA1&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
            ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Contacts&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Entity&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;MIMETYPE&lt;/span&gt;
        &lt;span style="color: #666666"&gt;};&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;/*&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * Sorts the retrieved cursor by raw contact id, to keep all data rows for a single raw&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * contact collated together.&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     */&lt;/span&gt;
    String sortOrder &lt;span style="color: #666666"&gt;=&lt;/span&gt;
            ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Contacts&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Entity&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;RAW_CONTACT_ID&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;&amp;quot; ASC&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;;&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;/*&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * Returns a new CursorLoader. The arguments are similar to&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * ContentResolver.query(), except for the Context argument, which supplies the location of&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * the ContentResolver to use.&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     */&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;new&lt;/span&gt; CursorLoader&lt;span style="color: #666666"&gt;(&lt;/span&gt;
            getApplicationContext&lt;span style="color: #666666"&gt;(),&lt;/span&gt;  &lt;span style="color: #008800; font-style: italic"&gt;// The activity&amp;#39;s context&lt;/span&gt;
            mContactUri&lt;span style="color: #666666"&gt;,&lt;/span&gt;              &lt;span style="color: #008800; font-style: italic"&gt;// The entity content URI for a single contact&lt;/span&gt;
            projection&lt;span style="color: #666666"&gt;,&lt;/span&gt;               &lt;span style="color: #008800; font-style: italic"&gt;// The columns to retrieve&lt;/span&gt;
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;null&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;                     &lt;span style="color: #008800; font-style: italic"&gt;// Retrieve all the raw contacts and their data rows.&lt;/span&gt;
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;null&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;                     &lt;span style="color: #008800; font-style: italic"&gt;//&lt;/span&gt;
            sortOrder&lt;span style="color: #666666"&gt;);&lt;/span&gt;               &lt;span style="color: #008800; font-style: italic"&gt;// Sort by the raw contact ID.&lt;/span&gt;
&lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当数据加载结束，LoaderManager 会调用 Activity 的 onLoadFinish() 回调函数。这个回调函数的参数之一是 Cursor 对象，它包含了查询的结果集。应用程序可以从 Cursor 对象里获取数据并显示出来。&lt;/p&gt;
&lt;h3 id="_11"&gt;批量操作&lt;/h3&gt;
&lt;p&gt;在操作电话数据的增加，删除，修改时，尽量使用批量操作，通过创建一个 ArrayList 列表，列表里放 ContactProviderOperation 类的实例，最后再调用 ContentResolver.applyPatch() 方法来执行批量操作。Contact Provider 将把一次 applyPatch() 里的所有操作当成一个事务来执行，这样你的修改就不会造成数据不一致性。新建一个电话本记录时，批量操作也会把插入 RawContact 表里的数据和插入 Data 表里的数据放在一个事务里执行，确保数据的一致性。&lt;/p&gt;
&lt;h4 id="_12"&gt;释放点&lt;/h4&gt;
&lt;p&gt;当指操作包含大量的操作时，执行起来虽然不会阻塞 UI 纯种，但系统整体很繁忙，会阻塞其它的进程。这样就会导致用户体验下降。一个解决方法是把所有操作通过合理的安排，放进几个独立的 ArrayList 对象里，同时为了不阻塞其他进程，可以在操作之间放一个&lt;strong&gt;释放点&lt;/strong&gt;，释放点也是一个 ContentProviderOperation 实例，它的 isyieldAllowed() 会返回 true 。当 Contact Provider 执行这些操作时，遇到释放点后，它会停止事务，暂停操作，以便让其他程序运行。等到 Contact Provider 再次运行时，它将创建新的事务从上次暂停的地方继续执行操作。&lt;/p&gt;
&lt;p&gt;释放点会导致在一批操作被分隔成多个事务。正因为如此，你需要把释放点放在一批相关数据操作的结尾处。比如，你需要把释放点放在添加 RawContact 记录和添加相应的 Data 记录之后。以确保释放点之间的操作的数据一致性。&lt;/p&gt;
&lt;p&gt;释放点之间也是一个原子操作单元。所有在释放点之间的操作要么全部成功要么全部失败。如果没有设置释放点，那么整个批量操作都将作为一个原子操作，要么全部成功要么全部失败。使用释放点可以避免让系统性能受到挑战，同时又兼顾了数据操作的原子性。&lt;/p&gt;
&lt;h4 id="_13"&gt;反向引用&lt;/h4&gt;
&lt;p&gt;当你把向 RawContact 里插入一条记录，以及把其相应的数据插入到 Data 表里作为一个批量操作时，你需要把 Data 表里的 RAW_CONTACT_ID 的值填成 RawContact 表里新插入的记录的 ID 值。而由于你还没有让 Contact Provider 去执行这个批量操作，即记录还没有在 RawContact 里生成，它的 ID 值是不可用的。为了解决这个问题， ContentProviderOperation.Builder 类提供了 withValueBackReference() 方法，用来让前一个操作的返回值作为当前操作的某个字段的值。&lt;/p&gt;
&lt;p&gt;withValueBackReference() 方法有两个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key&lt;br /&gt;
  键值对里的键值，它的值必须是要引用前一个操作返回值作为当前字段值的字段名称&lt;/li&gt;
&lt;li&gt;previousResult&lt;br /&gt;
  applyPatch() 函数返回的 ContentProviderResult 实例数组的索引值，这个索引值从0开始计数。当一个批量操作被 applyPatch() 执行时，每个操作都会有个返回值，其值是一个 ContentProviderResult 实例，通过数组组织起来返回。previousResult 是这个返回数组的索引值，用这个索引值获取到 ContentProviderResult，并把结果保存在由 key 指定的当前操作的字段上。这样就允许我们在插入 Data 表时，把其 RAW_CONTACT_ID 的值作为反向引用，引用之前的插入 RawContact 操作的返回值上。appyPatch() 调用时，其结果数组一次性被创建，数组的大小就是操作的个数。结果数组的值全部被设置为 null。所以，当反向引用一个还未执行的操作的结果上时， withValueBackReference() 会抛出一个异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的代码演示如何向 raw contact 和 data 表里利用反向引用批量地插入数据。这个代码在 ContactManager 例子里。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;/**&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt; * Creates a contact entry from the current UI values in the account named by mSelectedAccount.&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt; */&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;protected&lt;/span&gt; &lt;span style="color: #00BB00; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00A000"&gt;createContactEntry&lt;/span&gt;&lt;span style="color: #666666"&gt;()&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
    &lt;span style="color: #008800; font-style: italic"&gt;// Get values from UI&lt;/span&gt;
    String name &lt;span style="color: #666666"&gt;=&lt;/span&gt; mContactNameEditText&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getText&lt;/span&gt;&lt;span style="color: #666666"&gt;().&lt;/span&gt;&lt;span style="color: #BB4444"&gt;toString&lt;/span&gt;&lt;span style="color: #666666"&gt;();&lt;/span&gt;
    String phone &lt;span style="color: #666666"&gt;=&lt;/span&gt; mContactPhoneEditText&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getText&lt;/span&gt;&lt;span style="color: #666666"&gt;().&lt;/span&gt;&lt;span style="color: #BB4444"&gt;toString&lt;/span&gt;&lt;span style="color: #666666"&gt;();&lt;/span&gt;
    String email &lt;span style="color: #666666"&gt;=&lt;/span&gt; mContactEmailEditText&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getText&lt;/span&gt;&lt;span style="color: #666666"&gt;().&lt;/span&gt;&lt;span style="color: #BB4444"&gt;toString&lt;/span&gt;&lt;span style="color: #666666"&gt;();&lt;/span&gt;
    &lt;span style="color: #00BB00; font-weight: bold"&gt;int&lt;/span&gt; phoneType &lt;span style="color: #666666"&gt;=&lt;/span&gt; mContactPhoneTypes&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;get&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;
            mContactPhoneTypeSpinner&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getSelectedItemPosition&lt;/span&gt;&lt;span style="color: #666666"&gt;());&lt;/span&gt;
    &lt;span style="color: #00BB00; font-weight: bold"&gt;int&lt;/span&gt; emailType &lt;span style="color: #666666"&gt;=&lt;/span&gt; mContactEmailTypes&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;get&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;
            mContactEmailTypeSpinner&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getSelectedItemPosition&lt;/span&gt;&lt;span style="color: #666666"&gt;());;&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Prepare contact creation request&lt;/span&gt;
    &lt;span style="color: #008800; font-style: italic"&gt;//&lt;/span&gt;
    &lt;span style="color: #008800; font-style: italic"&gt;// Note: We use RawContacts because this data must be associated with a particular account.&lt;/span&gt;
    &lt;span style="color: #008800; font-style: italic"&gt;//       The system will aggregate this with any other data for this contact and create a&lt;/span&gt;
    &lt;span style="color: #008800; font-style: italic"&gt;//       coresponding entry in the ContactsContract.Contacts provider for us.&lt;/span&gt;
    ArrayList&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;ContentProviderOperation&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt; ops &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;new&lt;/span&gt; ArrayList&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;ContentProviderOperation&lt;span style="color: #666666"&gt;&amp;gt;();&lt;/span&gt;
    ops&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;add&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContentProviderOperation&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;newInsert&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;RawContacts&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CONTENT_URI&lt;/span&gt;&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;RawContacts&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;ACCOUNT_TYPE&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; mSelectedAccount&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getType&lt;/span&gt;&lt;span style="color: #666666"&gt;())&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;RawContacts&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;ACCOUNT_NAME&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; mSelectedAccount&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getName&lt;/span&gt;&lt;span style="color: #666666"&gt;())&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;build&lt;/span&gt;&lt;span style="color: #666666"&gt;());&lt;/span&gt;
    ops&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;add&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContentProviderOperation&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;newInsert&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Data&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CONTENT_URI&lt;/span&gt;&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValueBackReference&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Data&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;RAW_CONTACT_ID&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; &lt;span style="color: #666666"&gt;0)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Data&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;MIMETYPE&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
                    ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CommonDataKinds&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;StructuredName&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CONTENT_ITEM_TYPE&lt;/span&gt;&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CommonDataKinds&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;StructuredName&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;DISPLAY_NAME&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; name&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;build&lt;/span&gt;&lt;span style="color: #666666"&gt;());&lt;/span&gt;
    ops&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;add&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContentProviderOperation&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;newInsert&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Data&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CONTENT_URI&lt;/span&gt;&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValueBackReference&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Data&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;RAW_CONTACT_ID&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; &lt;span style="color: #666666"&gt;0)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Data&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;MIMETYPE&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
                    ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CommonDataKinds&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Phone&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CONTENT_ITEM_TYPE&lt;/span&gt;&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CommonDataKinds&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Phone&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;NUMBER&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; phone&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CommonDataKinds&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Phone&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;TYPE&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; phoneType&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;build&lt;/span&gt;&lt;span style="color: #666666"&gt;());&lt;/span&gt;
    ops&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;add&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContentProviderOperation&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;newInsert&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Data&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CONTENT_URI&lt;/span&gt;&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValueBackReference&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Data&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;RAW_CONTACT_ID&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; &lt;span style="color: #666666"&gt;0)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Data&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;MIMETYPE&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt;
                    ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CommonDataKinds&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Email&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CONTENT_ITEM_TYPE&lt;/span&gt;&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CommonDataKinds&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Email&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;DATA&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; email&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CommonDataKinds&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Email&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;TYPE&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; emailType&lt;span style="color: #666666"&gt;)&lt;/span&gt;
            &lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;build&lt;/span&gt;&lt;span style="color: #666666"&gt;());&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;/*&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * Demonstrates a yield point. At the end of this insert, the batch operation&amp;#39;s thread&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * will yield priority to other threads. Use after every set of operations that affect a&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     * single contact, to avoid degrading performance.&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;     */&lt;/span&gt;
    op&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withYieldAllowed&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;true&lt;/span&gt;&lt;span style="color: #666666"&gt;);&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Ask the Contact provider to create a new contact&lt;/span&gt;
    Log&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;i&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;TAG&lt;span style="color: #666666"&gt;,&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;Selected account: &amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; mSelectedAccount&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getName&lt;/span&gt;&lt;span style="color: #666666"&gt;()&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot; (&amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt;
            mSelectedAccount&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getType&lt;/span&gt;&lt;span style="color: #666666"&gt;()&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;);&lt;/span&gt;
    Log&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;i&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;TAG&lt;span style="color: #666666"&gt;,&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;Creating contact: &amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; name&lt;span style="color: #666666"&gt;);&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;try&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
        getContentResolver&lt;span style="color: #666666"&gt;().&lt;/span&gt;&lt;span style="color: #BB4444"&gt;applyBatch&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ContactsContract&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;AUTHORITY&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; ops&lt;span style="color: #666666"&gt;);&lt;/span&gt;
    &lt;span style="color: #666666"&gt;}&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;catch&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;Exception e&lt;span style="color: #666666"&gt;)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;
        &lt;span style="color: #008800; font-style: italic"&gt;// Display warning&lt;/span&gt;
        Context ctx &lt;span style="color: #666666"&gt;=&lt;/span&gt; getApplicationContext&lt;span style="color: #666666"&gt;();&lt;/span&gt;
        CharSequence txt &lt;span style="color: #666666"&gt;=&lt;/span&gt; getString&lt;span style="color: #666666"&gt;(&lt;/span&gt;R&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;string&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;contactCreationFailure&lt;/span&gt;&lt;span style="color: #666666"&gt;);&lt;/span&gt;
        &lt;span style="color: #00BB00; font-weight: bold"&gt;int&lt;/span&gt; duration &lt;span style="color: #666666"&gt;=&lt;/span&gt; Toast&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;LENGTH_SHORT&lt;/span&gt;&lt;span style="color: #666666"&gt;;&lt;/span&gt;
        Toast toast &lt;span style="color: #666666"&gt;=&lt;/span&gt; Toast&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;makeText&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;ctx&lt;span style="color: #666666"&gt;,&lt;/span&gt; txt&lt;span style="color: #666666"&gt;,&lt;/span&gt; duration&lt;span style="color: #666666"&gt;);&lt;/span&gt;
        toast&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;show&lt;/span&gt;&lt;span style="color: #666666"&gt;();&lt;/span&gt;

        &lt;span style="color: #008800; font-style: italic"&gt;// Log exception&lt;/span&gt;
        Log&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;e&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;TAG&lt;span style="color: #666666"&gt;,&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;Exceptoin encoutered while inserting contact: &amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; e&lt;span style="color: #666666"&gt;);&lt;/span&gt;
    &lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;LINE 6 - 12 从编辑框里获取名字，电话，邮件以及电话类型和邮件类型。&lt;/li&gt;
&lt;li&gt;LINE 19 - 23 构建一个操作，这个操作向 RawContact 插入一条记录。然后将这个操作放在批量操作列表里。记住，这个操作的索引值是 0 。&lt;/li&gt;
&lt;li&gt;LINE 24 - 43 构建三个操作，分别向 Data 表里插入名字，电话和邮件。在这三个操作时，每个操作对 RAW_CONTACT_ID 的处理都使用了反向引用的原理，引用索引值为 0，即插入 RawContact 这个操作的返回值作为 Data 表里 RAW_CONTACT_ID 的值。&lt;/li&gt;
&lt;li&gt;LINE 50 插入一个释放点。当 Contact Provider 执行到这里时可以把CPU释放出来给别的进程执行。&lt;/li&gt;
&lt;li&gt;LINE 57 把这个批量操作列表提交给 Contact Provider 作为一个事务来执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;批量操作也可以用来&lt;strong&gt;优化并发控制&lt;/strong&gt;，它让一个事务执行时不用对数据库加锁。要使用这个方法，你可以执行这个事务，然后检查其它的修改是否同时发生了。如果发现数据不一致，则回滚整个事务，然后重试。&lt;/p&gt;
&lt;p&gt;优化并发控制对手机设备特别有用，因为手机设备大部分情况下只有一个用户在使用，同时并发操作数据库的情景比较少。因为没有用锁来控制数据操作，所以不需要花时间来请求锁和释放锁，这样整个系统性能会比较好。要使用&lt;strong&gt;优化并发控制&lt;/strong&gt;来修改一行 RawContact 的数据，可以用下面的步骤来进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取 RawContact 的数据时，把 VERSION 字段也一并获取出来&lt;/li&gt;
&lt;li&gt;使用 newAssertQuery(Uri) 静态方法来创建 ContentProviderOperation.Builder 实例，其 Uri 参数使用 RawContacts.CONTENT_URI 加 RawContact._ID组合起来。&lt;/li&gt;
&lt;li&gt;对创建出来的 ContentProviderOperation.Builder 实例，使用 withValue() 来和步骤 1 获取出来的 VERSION 字段值进行比较。&lt;/li&gt;
&lt;li&gt;对同一个 ContentProviderOperation.Builder 实例，使用 withExpectedCount() 来保证获得出来的记录有且只有一条。&lt;/li&gt;
&lt;li&gt;调用 build() 方法来创建 ContentProviderOperation 实例，并把它添加到批量操作列表的第一项。&lt;/li&gt;
&lt;li&gt;调用 applyPatch() 来执行这个事务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果一个潜在的修改在你获取数据和修改数据之间发生，那么 VERSION 值将会自动递增，这样步骤 4 的断言动作就会失败，从而整个事务都会回退。这样你可以选择重试或其它操作，总之数据会保持一致。下面的代码演示如何使用 CursorLoader 来创建包含&lt;strong&gt;断言&lt;/strong&gt;的 ContentProviderOperation 实例。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;/*&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt; * The application uses CursorLoader to query the raw contacts table. The system calls this method&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt; * when the load is finished.&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt; */&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #00BB00; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00A000"&gt;onLoadFinished&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;Loader&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;Cursor&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt; loader&lt;span style="color: #666666"&gt;,&lt;/span&gt; Cursor cursor&lt;span style="color: #666666"&gt;)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Gets the raw contact&amp;#39;s _ID and VERSION values&lt;/span&gt;
    mRawContactID &lt;span style="color: #666666"&gt;=&lt;/span&gt; cursor&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getLong&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;cursor&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getColumnIndex&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;BaseColumns&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;_ID&lt;/span&gt;&lt;span style="color: #666666"&gt;));&lt;/span&gt;
    mVersion &lt;span style="color: #666666"&gt;=&lt;/span&gt; cursor&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getInt&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;cursor&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;getColumnIndex&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;SyncColumns&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;VERSION&lt;/span&gt;&lt;span style="color: #666666"&gt;));&lt;/span&gt;
&lt;span style="color: #666666"&gt;}&lt;/span&gt;

&lt;span style="color: #666666"&gt;...&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Sets up a Uri for the assert operation&lt;/span&gt;
    Uri rawContactUri &lt;span style="color: #666666"&gt;=&lt;/span&gt; ContentUris&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withAppendedId&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;RawContacts&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;CONTENT_URI&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; mRawContactID&lt;span style="color: #666666"&gt;);&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Creates a builder for the assert operation&lt;/span&gt;
    ContentProviderOperation&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;Builder&lt;/span&gt; assertOp &lt;span style="color: #666666"&gt;=&lt;/span&gt; ContentProviderOperation&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;netAssertQuery&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;rawContactUri&lt;span style="color: #666666"&gt;);&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Adds the assertions to the assert operation: checks the version and count of rows tested&lt;/span&gt;
    assertOp&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withValue&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;SyncColumns&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;VERSION&lt;/span&gt;&lt;span style="color: #666666"&gt;,&lt;/span&gt; mVersion&lt;span style="color: #666666"&gt;);&lt;/span&gt;
    assertOp&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;withExpectedCount&lt;/span&gt;&lt;span style="color: #666666"&gt;(1);&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Creates an ArrayList to hold the ContentProviderOperation objects&lt;/span&gt;
    ArrayList ops &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;new&lt;/span&gt; ArrayList&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;ContentProviderOperationg&lt;span style="color: #666666"&gt;&amp;gt;;&lt;/span&gt;

    ops&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;add&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;assertOp&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;build&lt;/span&gt;&lt;span style="color: #666666"&gt;());&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// You would add the rest of your batch operations to &amp;quot;ops&amp;quot; here&lt;/span&gt;

    &lt;span style="color: #666666"&gt;...&lt;/span&gt;

    &lt;span style="color: #008800; font-style: italic"&gt;// Applies the batch. If the assert fails, an Exception is thrown&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;try&lt;/span&gt;
        &lt;span style="color: #666666"&gt;{&lt;/span&gt;
            ContentProviderResult&lt;span style="color: #666666"&gt;[]&lt;/span&gt; results &lt;span style="color: #666666"&gt;=&lt;/span&gt;
                    getContentResolver&lt;span style="color: #666666"&gt;().&lt;/span&gt;&lt;span style="color: #BB4444"&gt;applyBatch&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;AUTHORITY&lt;span style="color: #666666"&gt;,&lt;/span&gt; ops&lt;span style="color: #666666"&gt;);&lt;/span&gt;

        &lt;span style="color: #666666"&gt;}&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;catch&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;OperationApplicationException e&lt;span style="color: #666666"&gt;)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;

            &lt;span style="color: #008800; font-style: italic"&gt;// Actions you want to take if the assert operation fails go here&lt;/span&gt;
        &lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id="_14"&gt;结语&lt;/h2&gt;
&lt;p&gt;联系人的数据结构特别复杂。把握住了本文介绍的这几个核心数据结构及操作。基本上原电话本就会有一个全面的了解。下一篇关于电话本的文章，我们将结合 Android 的示例程序 SampleSyncAdapter 来介绍如何做一个电话本同步服务器以及如何在手机端添加一个同步适配器来同步自己的电话本数据。&lt;/p&gt;</summary><category term="android"></category><category term="contacts"></category><category term="contacts provider"></category></entry><entry><title>Android应用性能调试</title><link href="http://blog.kamidox.com/android-performance-debug-tools.html" rel="alternate"></link><updated>2014-11-18T23:30:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-11-18:android-performance-debug-tools.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;开篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;性能问题汇总&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;性能调试工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#gpu"&gt;GPU呈现模式分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#gpu_1"&gt;调试GPU过度绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#method-profiling"&gt;Method Profiling工具&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_4"&gt;刷新时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#listviewviewholder"&gt;ListView的ViewHolder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;一些技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;结束语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;开篇&lt;/h2&gt;
&lt;p&gt;关于Android性能方面，不能不读&lt;a href="http://www.curious-creature.org/docs/android-performance-case-study-1.html"&gt;这篇文章&lt;/a&gt;。作者是GOOGLE员工，同时也是个摄影爱好者。本文就是通过阅读这篇文章，结合Android 4.4平台和自身实践总结出来的，个人认为对Android应用程序性能优化较有帮助的一些工具及使用示例。不足之处欢迎指正。&lt;/p&gt;
&lt;h2 id="_2"&gt;性能问题汇总&lt;/h2&gt;
&lt;p&gt;性能问题总的来说，就是反映慢。实际上，从图形学意义来讲，就是帧率低。性能问题最终可以归纳成两类问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;布局不合理导致过度绘制。&lt;br /&gt;
   重绘(Over Draw)是指屏幕上的一个象素点被画了多次，比如一个图片按钮(ImageButton)要先按出背景，再画出按钮上的图片，这就是重绘的概念。过度重绘是指有由于布局不合理导致一些不必要的重绘，比如一个窗口多有层背景，那么在渲染的时候，就会一层一层地画上去，上面的背景覆盖掉下而把背景。这个时候我们可以把下面的背景去掉。只画上层的背景，从而提高刷新速度。&lt;/li&gt;
&lt;li&gt;函数调用不合理导致每帧的刷新之间CPU花了太长的时间。&lt;br /&gt;
   比如每次刷新时，或者处理点击事件时，都去大量地读写文件。对于这种问题，要么使用缓存减少文件读取次数。如果不得不读，可能就要考虑使用异步加载的方式来确保界面刷新，数据加载完填充数据的方式来优化性能和用户体验。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_3"&gt;性能调试工具&lt;/h2&gt;
&lt;p&gt;Android的开发者选项里以及ADT/monitor提供了大量性能调试工具来调试上述性能问题。本文重点介绍三个工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GPU呈现模式分析 -&amp;gt; 在adb shell dumpsys gfxinfo中&lt;br /&gt;
   这个在开发者选项的&lt;strong&gt;监控&lt;/strong&gt;里面。可以从GPU刷新的角度分析我们的刷新帧率问题。&lt;/li&gt;
&lt;li&gt;调试GPU过度绘制 -&amp;gt; 显示过度重绘区域&lt;br /&gt;
   这个在开发者选项的&lt;strong&gt;硬件加速渲染&lt;/strong&gt;里面。这个可以查看一些界面的布局不合理导致的过度绘制的性能问题。&lt;/li&gt;
&lt;li&gt;Method Profiling工具&lt;br /&gt;
   这个在DDMS/monitor里可以找到，这个工具可以从虚拟机层面抓取每个函数及其调用的函数的运行时间，统计运行次数等功能。是分析性能问题的绝佳工具。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="gpu"&gt;GPU呈现模式分析&lt;/h2&gt;
&lt;p&gt;GPU呈现模式分析可以从GPU层面上分析我们的刷新效率。使用这个工具可以用来发现有没有刷新帧率过低的问题。&lt;/p&gt;
&lt;p&gt;首先，在开发者模式里打开&lt;strong&gt;GPU呈现模式分析&lt;/strong&gt;菜单，在弹出式菜单里选择&lt;strong&gt;在adb shell dumpsys gfxinfo中&lt;/strong&gt;选项。打开这个选项后，系统会为每个窗口记录最近128帧的刷新时间。&lt;/p&gt;
&lt;p&gt;接着，手机连接电脑，确保adb可用。然后运行你要调试的应用程序做一些必要的操作之后，运行下面的命令在抓取GPU刷新的LOG：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;adb shell dumpsys gfxinfo com.android.soundrecorder &amp;gt; soundrecorder_gfxinfo_1.log
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;em&gt;com.android.soundrecorder&lt;/em&gt;是要分析的应用的包名称；&lt;em&gt;soundrecorder_gfxinfo_1.log&lt;/em&gt;是抓取出来的LOG保存位置。&lt;/p&gt;
&lt;p&gt;接着，打开LOG文件&lt;em&gt;soundrecorder_gfxinfo_1.log&lt;/em&gt;，找到&lt;strong&gt;Profile data in ms:&lt;/strong&gt;那节，可以看到类似下面的数据：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;com.android.soundrecorder/com.android.soundrecorder.SoundRecorder/android.view.ViewRootImpl@41db6d18
Draw    Process Execute
4.38    6.49    0.87
0.65    5.69    0.84
4.40    7.82    3.10
2.64    4.62    0.92
...     ...     ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中有三种类型的数据数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Draw是在java里构建显示列表所花的时间，这个表示花在&lt;code&gt;View.onDraw(Canvas canvas)&lt;/code&gt;里的时间&lt;/li&gt;
&lt;li&gt;Process是android的2D渲染器执行Draw所构建出来的显示列表所花的时间，一个View的结构层次越复杂，就有越多的渲染命令需要被执行，就会花越多的时间&lt;/li&gt;
&lt;li&gt;Execute是发送一帧显示数据给GPU的合成器所花的时间，这部分时间一般较短且较固定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述的描述比较抽象，我们从代码层面来看这三个数据的含义：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android.view.HardwareRender$GlRenderer.draw()&lt;/code&gt;函数抛开无关代码后，只剩下两行：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;@Override&lt;/span&gt;
&lt;span style="color: #00BB00; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #00A000"&gt;draw&lt;/span&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;View view&lt;span style="color: #666666"&gt;,&lt;/span&gt; View&lt;span style="color: #666666"&gt;.&lt;/span&gt;&lt;span style="color: #BB4444"&gt;AttachInfo&lt;/span&gt; attachInfo&lt;span style="color: #666666"&gt;,&lt;/span&gt; HardwareDrawCallbacks callbacks&lt;span style="color: #666666"&gt;,&lt;/span&gt; Rect dirty&lt;span style="color: #666666"&gt;)&lt;/span&gt; &lt;span style="color: #666666"&gt;{&lt;/span&gt;

    &lt;span style="color: #666666"&gt;...&lt;/span&gt;

    DisplayList displayList &lt;span style="color: #666666"&gt;=&lt;/span&gt; buildDisplayList&lt;span style="color: #666666"&gt;(&lt;/span&gt;view&lt;span style="color: #666666"&gt;,&lt;/span&gt; canvas&lt;span style="color: #666666"&gt;);&lt;/span&gt;

    &lt;span style="color: #666666"&gt;...&lt;/span&gt;

    status &lt;span style="color: #666666"&gt;|=&lt;/span&gt; drawDisplayList&lt;span style="color: #666666"&gt;(&lt;/span&gt;attachInfo&lt;span style="color: #666666"&gt;,&lt;/span&gt; canvas&lt;span style="color: #666666"&gt;,&lt;/span&gt; displayList&lt;span style="color: #666666"&gt;,&lt;/span&gt; status&lt;span style="color: #666666"&gt;);&lt;/span&gt;

    &lt;span style="color: #666666"&gt;...&lt;/span&gt;
&lt;span style="color: #666666"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Line 6: 这个就是Draw的时间，&lt;code&gt;buildDisplayList()&lt;/code&gt;最终会调用&lt;code&gt;View.getDisplayList()&lt;/code&gt;，而后者就是从View树里从根部开始遍历所有的子View，并且依次调用每个View的&lt;code&gt;View.onDraw()&lt;/code&gt;方法把控件都画在画布上。这里，每个View都独立地画在一个Canvas上。&lt;br /&gt;
Line 10: 这个就是Process的时间，&lt;code&gt;drawDisplayList()&lt;/code&gt;会调用&lt;code&gt;android.view.GLE20Canvas.drawDisplayList()&lt;/code&gt;函数来把DisplayList合并起来。即Draw的结果是一个DisplayList，Process要做的就是把这个DisplayList合并起来。&lt;/p&gt;
&lt;p&gt;有了上面的分析，我们就清楚了这三个数据的含义，要减少Draw的时间，就要去减少控件层次结构和个数，同时优化每个控件的onDraw函数。要减少Process时间，就去减少控件层次结构和个数以及一些复杂的效果，如半透明之类的。而Execute的时间基本不受软件控制，可以排除在优化对象之外。&lt;/p&gt;
&lt;p&gt;接下来，回到我们抓到的LOG数据&lt;em&gt;soundrecorder_gfxinfo_1.log&lt;/em&gt;里面。我们把这三个数据拷贝到excel里，做一个柱状图(Stacked Column)来直观地观察一下GPU的刷新时间。&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/soundrecorder_gfxinfo_1_stacked_column.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出来，一帧的刷新时间大部分都小于16ms，部分帧超过16ms。除了这个数据外，我们也可以算一下Draw和Process的平均时间，计算这个时间是为了量化对比优化前后的性能指标。我们可以精确地计算出性能提升了多少个百分点。针对本次抓到的LOG，我们计算出来的平均时间如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Draw平均时间：3.926ms&lt;/li&gt;
&lt;li&gt;Process平均时间：7.262ms&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;16ms的含义&lt;/p&gt;
&lt;p&gt;一般情况下，如果能保证60fps的刷新帧率，那么人眼看起来就会觉得很流畅。这样1000 / 60大概就是16ms。所以需要保证一帧的刷新时间小于16ms就能保证流畅度。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="gpu_1"&gt;调试GPU过度绘制&lt;/h2&gt;
&lt;p&gt;GPU呈现模式分析让我们了解GPU刷新，并且能知道帧率能不能达到60fps。还能算出Draw和Process平均时间供对比分析，但对怎么样优化就不明确了。这样我们就需要GPU过度绘制工具来帮忙。&lt;/p&gt;
&lt;p&gt;首先，在开发者模式里关闭之前打开的&lt;strong&gt;GPU呈现模式分析&lt;/strong&gt;，然后打开&lt;strong&gt;调试GPU过度绘制&lt;/strong&gt;，选择&lt;strong&gt;显示过度重绘区域&lt;/strong&gt;。这样就会看到界面会画出花花绿绿的背景。这些不同颜色的背景就是用来指示出过度重绘的程度的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;背景颜色&lt;/th&gt;
&lt;th&gt;表示的含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;无颜色&lt;/td&gt;
&lt;td&gt;表示没有重绘，即一个象素点只被绘制了1次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;蓝色&lt;/td&gt;
&lt;td&gt;表示重绘了1次，即一个象素点被绘制了2次。屏幕上如果有大块的的蓝色区域是可以接受的，但如果整个屏幕都是蓝色的，那就需要优化了，可以去掉一层。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;绿色&lt;/td&gt;
&lt;td&gt;表示重绘了2次，即一个象素点被绘制了3次。中等面积的绿色区域是可以接受的，不过最好引起警惕，去看一下能不能优化。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;淡红色&lt;/td&gt;
&lt;td&gt;表示重绘了3次，即一个象素绘制了4次。很小的淡红色区域是可以接受的，其他情况就需要去优化。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;深红色&lt;/td&gt;
&lt;td&gt;表示重绘了4次以上。这个不正确的，必须进行优化。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们可以打开录音机模块，看一下录音机这个模块在优化之前的GPU过度绘制显示图片：&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/recorder_1.png" /&gt; &lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/recorder_list_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;录音主界面可以看出两个明显的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;整个背景都是蓝色的。这个应该可以优化，去掉一层。&lt;/li&gt;
&lt;li&gt;底部区域是绿色的，被重绘了2次，需要分析一下是否可以优化。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;录音列表界面也可以看出一个问题：底部区域是蓝色的，重绘了2次，可以想办法优化。&lt;/p&gt;
&lt;p&gt;我们以录音主界面为例，看一下它的布局文件：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;LinearLayout&lt;/span&gt; &lt;span style="color: #BB4444"&gt;xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&lt;/span&gt;
    &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;match_parent&amp;quot;&lt;/span&gt;
    &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;match_parent&amp;quot;&lt;/span&gt;
    &lt;span style="color: #BB4444"&gt;android:orientation=&amp;quot;vertical&amp;quot;&lt;/span&gt;
    &lt;span style="color: #BB4444"&gt;android:background=&amp;quot;@drawable/main_bg&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;

    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;RelativeLayout&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/timerViewLayout&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;match_parent&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;123dip&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;

        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;ImageButton&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/listButtons&amp;quot;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;android:layout_alignParentTop=&amp;quot;true&amp;quot;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;android:layout_alignParentRight=&amp;quot;true&amp;quot;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;android:src=&amp;quot;@drawable/record_ic_recordlist&amp;quot;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;android:background=&amp;quot;@null&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;

        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;TextView&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/stateMessage1&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_toLeftOf=&amp;quot;@+id/listButtons&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_alignParentTop=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_alignParentLeft=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_marginTop=&amp;quot;15dip&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_marginLeft=&amp;quot;45dip&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:gravity=&amp;quot;center&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;style=&amp;quot;@android:style/TextAppearance.Small.Inverse&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;

        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;TextView&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/timerView&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:textSize=&amp;quot;60sp&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_centerHorizontal=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_alignParentBottom=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;style=&amp;quot;@android:style/TextAppearance.Large.Inverse&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;

    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/RelativeLayout&amp;gt;&lt;/span&gt;

    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;com.android.soundrecorder.VUMeter&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/uvMeter&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;match_parent&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;0dip&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_weight=&amp;quot;1&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;

    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;RelativeLayout&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;match_parent&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;150dip&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:background=&amp;quot;@drawable/op_bar_bg&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;

        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;ImageButton&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/recordButton&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/span&gt; 
            &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_centerInParent=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:src=&amp;quot;@drawable/record_btn_record&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:background=&amp;quot;@null&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;

        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;TextView&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/stopButton&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:textSize=&amp;quot;14sp&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:textColor=&amp;quot;#CCCCCC&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:text=&amp;quot;@string/accept&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_alignParentRight=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_centerVertical=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:singleLine=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:gravity=&amp;quot;center&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_marginRight=&amp;quot;25dip&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:clickable=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:background=&amp;quot;@drawable/record_btn_complete&amp;quot;&lt;/span&gt;
             &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/RelativeLayout&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/LinearLayout&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;LINE 5：主界面有个主背景图片&lt;code&gt;@drawable/main_bg&lt;/code&gt;，这是个全屏的背景图片。加上窗口背景图片，这块实际上有完全叠加起来的两层背景。我们可以优化去掉一层背景。&lt;br /&gt;
LINE 48：底部区域也有个背景图片&lt;code&gt;@drawable/op_bar_bg&lt;/code&gt;。这个实际上是多余的，可以去掉。&lt;/p&gt;
&lt;p&gt;优化措施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;去掉LINE 5及LINE 48的背景图片&lt;/li&gt;
&lt;li&gt;在录音Activity的&lt;code&gt;onCreate()&lt;/code&gt;方法设置窗口的背景图片&lt;code&gt;getWindow().setBackgroundDrawableResource(R.drawable.main_bg);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;窗口背景图片&lt;/p&gt;
&lt;p&gt;定义在Theme里的窗口背景，在Activity启动的时候由系统创建并应用在Activity窗口里。所以在上面第2个优化步骤里。我们是直接把背景图片从布局文件里删除，移到Activity的窗口里。这样就省去了一层背景图片。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;再来看一下录音列表这个activity的布局文件：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;LinearLayout&lt;/span&gt; &lt;span style="color: #BB4444"&gt;xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&lt;/span&gt;
    &lt;span style="color: #BB4444"&gt;android:orientation=&amp;quot;vertical&amp;quot;&lt;/span&gt; 
    &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;fill_parent&amp;quot;&lt;/span&gt;
    &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;fill_parent&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;

    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;FrameLayout&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;fill_parent&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;0dip&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_weight=&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;

        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;TextView&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@android:id/empty&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;fill_parent&amp;quot;&lt;/span&gt; 
            &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;fill_parent&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:gravity=&amp;quot;center|center&amp;quot;&lt;/span&gt; 
            &lt;span style="color: #BB4444"&gt;android:textSize=&amp;quot;18sp&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:text=&amp;quot;@string/list_empty&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;

        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;ListView&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@android:id/list&amp;quot;&lt;/span&gt; 
            &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;fill_parent&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/span&gt; 
            &lt;span style="color: #BB4444"&gt;android:gravity=&amp;quot;left|top&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;

    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/FrameLayout&amp;gt;&lt;/span&gt;

    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;View&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/menuAnchor&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;1dip&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;5dip&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_gravity=&amp;quot;right&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:visibility=&amp;quot;invisible&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;&amp;quot;

    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;RelativeLayout&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/bottomBarLayout&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;match_parent&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;150dip&amp;quot;&lt;/span&gt;
        &lt;span style="color: #BB4444"&gt;android:background=&amp;quot;@drawable/op_bar_bg&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;

        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;ImageButton&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/recordButton&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/span&gt; 
            &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_centerInParent=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:src=&amp;quot;@drawable/record_btn_record&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:background=&amp;quot;@null&amp;quot;&lt;/span&gt; &lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;

        &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;ImageButton&lt;/span&gt; &lt;span style="color: #BB4444"&gt;android:id=&amp;quot;@+id/optionButton&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_height=&amp;quot;wrap_content&amp;quot;&lt;/span&gt; 
            &lt;span style="color: #BB4444"&gt;android:layout_width=&amp;quot;wrap_content&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_alignParentRight=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_centerVertical=&amp;quot;true&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:layout_marginRight=&amp;quot;25dip&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:src=&amp;quot;@drawable/recordlist_btn_more&amp;quot;&lt;/span&gt;
            &lt;span style="color: #BB4444"&gt;android:background=&amp;quot;@null&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;/&amp;gt;&lt;/span&gt;

    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/RelativeLayout&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/LinearLayout&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;LINE 35：底部区域有个背景图片&lt;code&gt;android:background="@drawable/op_bar_bg&lt;/code&gt;，加上我们上面提到的窗口背景图片，所以底部区域这块实际上覆盖了两层背景。就是说这块背景会绘制2次，所以呈现了蓝色。&lt;/p&gt;
&lt;p&gt;优化措施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LINE 7的FrameLayout我们给它加上一个白色的背景色。&lt;/li&gt;
&lt;li&gt;在录音列表Activity的&lt;code&gt;onCreate()&lt;/code&gt;方法里去掉窗口背景图片。&lt;code&gt;getWindow().setBackgroundDrawable(null)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优化之后，我们再看一下这两个窗口在优化前后的样子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/recorder_1.png" /&gt; &lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/recorder_2.png" /&gt; &lt;/p&gt;
&lt;p&gt;对比可以看得出来，录音主界面从原来是全屏蓝色，底部绿色变成背景全部无色。这样我们就省去了一层背景图片。&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/recorder_list_1.png" /&gt; &lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/recorder_list_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;而录音列表界面背景也变成无色的，即背景只画一次。&lt;/p&gt;
&lt;p&gt;优化之后，我们通过上面介绍的&lt;strong&gt;GPU呈现模式分析&lt;/strong&gt;再抓一次LOG，计算Draw和Process的平均时间分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Draw平均时间：3.566ms；优化之前是3.926ms&lt;/li&gt;
&lt;li&gt;Process平均时间：7.200ms；优化之前是7.262ms&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面定量来看，Draw性能大概提高了9.17%。而Process性能没有明显提高。这也是符合我们的预期的，因为我们只优化了画图部分，并没有优化布局的层次结构，所以Process不会提高。&lt;/p&gt;
&lt;h2 id="method-profiling"&gt;Method Profiling工具&lt;/h2&gt;
&lt;p&gt;上面介绍的工具用来调试布局不合理导致过度绘制，而Method Profiling工具则可以调试刷新之外的性能，比如响应用户点击事件时花了大量的时间读写文件之类的问题。&lt;/p&gt;
&lt;p&gt;首先，手机连接电脑，确保adb可用。打开ADT/monitor，打开&lt;strong&gt;device&lt;/strong&gt;窗口，选择要调试的应用程序，然后点击&lt;strong&gt;Start Method Profiling&lt;/strong&gt;开始抓取LOG。&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/soundrecorder_start_method_profiling.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;接着，操作手机运行你要优化性能的程序，在里面做适当的操作。操作完成后，点击&lt;strong&gt;Stop Method Profiling&lt;/strong&gt;按钮，会自动在临时目录保存一个trace文件，打开后大概如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/soundrecorder_main_method_profiling.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;一些关键数据的含义如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Incl Cpu Time %&lt;/td&gt;
&lt;td&gt;函数自己及其调用的函数总共所占用CPU的时间占总时间的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Incl Cpu Time&lt;/td&gt;
&lt;td&gt;函数自己及其调用的函数总共所占用CPU的时间，单位为ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Excl CPU Time %&lt;/td&gt;
&lt;td&gt;函数自己(不包含其调用的函数)运行时占用的CPU时间的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Excl CPU Time&lt;/td&gt;
&lt;td&gt;函数自己(不包含其调用的函数)运行时占用的CPU时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Incl Real Time&lt;/td&gt;
&lt;td&gt;函数自己及其调用的函数总共所用的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Excl Real Time&lt;/td&gt;
&lt;td&gt;函数自己(不包含其调用的函数)运行时所用的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Calls + RecurCalls/Total&lt;/td&gt;
&lt;td&gt;在抓LOG这段时间内函数的调用的总次数，包含递归调用的次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cpu Time/Call&lt;/td&gt;
&lt;td&gt;函数调用一次所用的CPU时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Real Time/Call&lt;/td&gt;
&lt;td&gt;函数调用一次所用的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;CPU Time vs Real Time&lt;/p&gt;
&lt;p&gt;这两个时间有什么区别呢？简单地讲，CPU Time就是CPU真正在运行这个函数的代码所花的时间；而Real time是Wall time，即这个函数从开始进入到真正退出所花的时间。这两个时间为什么会不同呢？举个例子，假如一个函数读取文件，并处理文件里的文本内容。读取文件涉及到IO操作，比如打开文件，实际上打开文件时调用打开文件的这个函数所在线程会短时间进入SLEEP状态，即不占用CPU，但也不返回，而是等待底层真正文件打开成功后，退出SLEEP状态再返回。这个短时间的SLEEP状态是不计处CPU Time的，因为它不占用CPU。但是计入Real time，因为函数还没返回。所以两者必定满足下面的条件：CPU Time &amp;lt;= Real Time。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Method Profiling的信息量很大，可以挖掘很多很有意思的信息。下面列举一些信息来抛砖引玉。&lt;/p&gt;
&lt;h3 id="_4"&gt;刷新时间&lt;/h3&gt;
&lt;p&gt;我们可以用Method Profiling抓一个录音过程中的LOG文件。在ADT/monitor里可以看到上文我们提到Draw和Process的概念：&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/soundrecorder_GlRenderer.draw.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;在ADT/monitor里的信息可以看出，&lt;code&gt;android.view.HardwareRender$GlRenderer.draw()&lt;/code&gt;的&lt;strong&gt;Incl Cpu Time&lt;/strong&gt;总共占用CPU 3012.359ms，占总CPU时间的88.8%，在抓LOG的这段时间里，总共调用了85次，每次调用的CPU时间是35.440ms，Real time是45.637ms。而其Children里面，&lt;code&gt;GlRenderer.buildDisplayList()&lt;/code&gt;占用74.1%，这个实际上就是&lt;code&gt;View.onDraw()&lt;/code&gt;占用的时间总和。&lt;code&gt;GlRenderer.drawDisplayList()&lt;/code&gt;占用19.7%，这个就是合成DisplayList占用的时间。&lt;/p&gt;
&lt;p&gt;通过这些信息，我们知道我们抓的这段LOG里，CPU主要花费在界面刷新上（占了88.8%）。我们需要优化控件的&lt;code&gt;onDraw()&lt;/code&gt;方法来优化性能。&lt;/p&gt;
&lt;p&gt;继续往下看，我们可以看到录音控件里的&lt;code&gt;UVMeter.onDraw()&lt;/code&gt;方法占用了整个的CPU时间的61.8%。&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/soundrecorder_VUMeter.onDraw.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以看出来&lt;code&gt;drawLine()&lt;/code&gt;函数CPU时间占用了44.8%，总共用时940.858ms，调用了15046次，每次调用需要用时0.063ms；从这些数据来看，我们优化的方向应该想办法减少&lt;code&gt;UVMeter.onDraw()&lt;/code&gt;里对&lt;code&gt;drawLine()&lt;/code&gt;的调用次数。&lt;code&gt;String.format()&lt;/code&gt;函数CPU时间占用了35.4%。可以用类似的方法来分析。&lt;/p&gt;
&lt;p&gt;接下来，就是深入&lt;code&gt;UVMeter.onDraw()&lt;/code&gt;方法的代码里，去看有没有办法减少&lt;code&gt;drawLine()&lt;/code&gt;和&lt;code&gt;String.format()&lt;/code&gt;函数的调用次数了。&lt;/p&gt;
&lt;h3 id="listviewviewholder"&gt;ListView的ViewHolder&lt;/h3&gt;
&lt;p&gt;在优化ListView的滚动效率时，我们经常会给每个Item一个ViewHolder避免重复创建View。我们抓一个打开录音列表Activity的Method Profiling LOG文件，从LOG文件里可以定量地看出来这个优化能节省多少时间。&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/soundrecorder_getView.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;从trace里可以看到，&lt;code&gt;getView()&lt;/code&gt;函数占总CPU时间的45.5%，每次调用平均CPU用时31.052ms。而其Children里的&lt;code&gt;LayoutInflater.inflate()&lt;/code&gt;占用CPU时间72.7%，总共调用11次，每次CPU用时52.971ms。ViewHolder就是为了避免重复调用&lt;code&gt;inflate()&lt;/code&gt;函数来创建View的。这样就可以为每个Item节省52.971ms。这是一个非常值得的优化项目。&lt;/p&gt;
&lt;p&gt;我们可以再录音列表里上下滚动来抓一个LOG来对比：&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMAGE" src="http://kamidox-blogs.qiniudn.com/soundrecorder_scroll_getView.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;从对比可知，&lt;code&gt;getView()&lt;/code&gt;占总CPU时间为12.8%，每次调用平均CPU时间为10.369ms。由此可见尽量减少调用&lt;code&gt;inflate()&lt;/code&gt;是优化性能的一个重要方法。同时要减少&lt;code&gt;inflate()&lt;/code&gt;函数的用时，可以通过简化View的布局层次结构来达到目的。&lt;/p&gt;
&lt;h3 id="_5"&gt;一些技巧&lt;/h3&gt;
&lt;p&gt;Method Profiling能看到的信息远不止这些。可以通过重点关注需要优化的性能瓶颈，有针对性地从Method Profiling Log里找到可优化的线索，一些有用的技巧总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;针对需要优化的性能问题抓取LOG&lt;br /&gt;
   比如需要优化滚动慢的问题，就只抓滚动的LOG，如果需要优化启动慢的问题，就只抓启动的LOG。这样才能有针对性地从LOG里找出可优化的线索。&lt;/li&gt;
&lt;li&gt;阅读LOG的时候，可以从上往下，按照CPU占用时间倒序来发现线索。针对framework里的一些函数如果不清楚其功能可以跳过。当看到应用里面的函数调用时，就需要深入去对比LOG和代码，来发现可优化的线索。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_6"&gt;结束语&lt;/h2&gt;
&lt;p&gt;性能问题是个复杂的问题。单靠这些调试工具不能完全解决问题，而应该在设计阶段就考虑性能问题。在优化阶段利用这些调试工具来优化细节，同时发现一些设计阶段没有发现的性能瓶颈问题。&lt;/p&gt;
&lt;p&gt;本文将录音机应用作为例子描述的一些log文件可以在&lt;a href="http://pan.baidu.com/s/1Gp5Xc"&gt;这里&lt;/a&gt;下载到。里面的文件说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sound_record_list_start.trace：启动录音列表的trace文件&lt;/li&gt;
&lt;li&gt;sound_record_list.trace：在录音列表里上下滚动的trace文件&lt;/li&gt;
&lt;li&gt;sound_recorder.trace：录音过程中的trace文件&lt;/li&gt;
&lt;li&gt;soundrecorder_gfxinfo_1.log：优化前的gfxinfo文件&lt;/li&gt;
&lt;li&gt;soundrecorder_gfxinfo_1.xlsx：优化前的gfxinfo文件制作出来的excel文件&lt;/li&gt;
&lt;li&gt;soundrecorder_gfxinfo_2.log：优化后的gfxinfo文件&lt;/li&gt;
&lt;li&gt;soundrecorder_gfxinfo_2.xlsx：优化后的gfxinfo文件制作出来的excel文件&lt;/li&gt;
&lt;/ul&gt;</summary><category term="android"></category></entry><entry><title>FlaskBB阅读笔记（二）</title><link href="http://blog.kamidox.com/flaskbb-notes-2.html" rel="alternate"></link><updated>2014-11-04T23:00:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-11-04:flaskbb-notes-2.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;开篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#flask-script"&gt;Flask-Script用法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;创建命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;获取用户输入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;其它技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#managepy"&gt;manage.py源码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;结束语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;开篇&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/sh4nks/flaskbb"&gt;FlaskBB&lt;/a&gt;是用Flask框架实现的一个轻量级的论坛社区软件，代码托管在GitHub上。本系列文章通过阅读FlaskBB的源代码来深入学习Flask框架，以及在一个产品级的Flask应用里的一些最佳实践规则。&lt;/p&gt;
&lt;p&gt;本文是这系列文章的第二遍。本文分析FlaskBB的脚本管理程序&lt;code&gt;manage.py&lt;/code&gt;的源码。基本上每个Flask程序都需要一个&lt;code&gt;manage.py&lt;/code&gt;，用户可以通过它来创建数据库，运行开发服务器的任务。在FlaskBB的&lt;code&gt;README.md&lt;/code&gt;里有下面一段话：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;* Create a virtualenv
* Install the dependencies
    * `pip install -r requirements.txt`
* Configuration (_adjust them accordingly to your needs_)
    * For development copy `flaskbb/configs/development.py.example` to `flaskbb/configs/development.py`
* Database creation
    * `python manage.py createall`
* Run the development server
    * `python manage.py runserver`
* Visit [localhost:8080](http://localhost:8080)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些指令是指导用户安装/运行FlaskBB论坛程序的。其中&lt;code&gt;python manage.py createall&lt;/code&gt;和&lt;code&gt;python manage.py runserver&lt;/code&gt;就是本文要介绍的主角，其中第一条命令用来创建一个测试数据库，第二条命令用来运行开发服务器。&lt;/p&gt;
&lt;p&gt;有了这些神器，从GitHub下载代码：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;cd&lt;/span&gt; ~
git clone https://github.com/sh4nks/flaskbb.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后创建virtualenv：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;cd&lt;/span&gt; ~/flaskbb
virtualenv .venv
&lt;span style="color: #AA22FF"&gt;source&lt;/span&gt; .venv/bin/activate
pip install -r requirements.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;拷贝配置文件：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;cp flaskbb/configs/development.py.example flaskbb/configs/development.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;创建数据库，并运行开发服务器：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;python manage.py createall
python manage.py runserver
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样打开&lt;a href="http://localhost:8080"&gt;localhost:8080&lt;/a&gt;即可看到FlaskBB运行出来的论坛网站了。&lt;/p&gt;
&lt;h2 id="flask-script"&gt;Flask-Script用法&lt;/h2&gt;
&lt;p&gt;要了解&lt;code&gt;manage.py&lt;/code&gt;的工作原理，必须先了解Flask-Script扩展模块的用法。在本系列第一篇文章中，我们简要介绍了Flask-Script的作用。其官方文档这样描述自己：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Flask-Script extension provides support for writing external scripts in Flask. This includes running a development server, a customised Python shell, scripts to set up your database, cronjobs, and other command-line tasks that belong outside the web application itself.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_2"&gt;创建命令&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;@command&lt;/code&gt;装饰器创建命令：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;flask.ext.script&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; Manager

app &lt;span style="color: #666666"&gt;=&lt;/span&gt; Flask(__name__)
&lt;span style="color: #008800; font-style: italic"&gt;# configure your app&lt;/span&gt;

manager &lt;span style="color: #666666"&gt;=&lt;/span&gt; Manager(app)

&lt;span style="color: #AA22FF"&gt;@manager.command&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;hello&lt;/span&gt;():
    &lt;span style="color: #BB4444"&gt;&amp;quot;Just say hello&amp;quot;&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;

&lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; __name__ &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;:
    manager&lt;span style="color: #666666"&gt;.&lt;/span&gt;run()
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这样就创建了一个&lt;code&gt;hello&lt;/code&gt;的命令，假设上述文件保存为&lt;code&gt;manage.py&lt;/code&gt;，则可以运行这个添加的命令：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;python manage.py hello
&amp;gt; hello world
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用&lt;code&gt;@option&lt;/code&gt;装饰器创建带参数的命令：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;@manager.option&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;#39;-n&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;--name&amp;#39;&lt;/span&gt;, dest&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;, default&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;joe&amp;#39;&lt;/span&gt;)
&lt;span style="color: #AA22FF"&gt;@manager.option&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;#39;-u&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;--url&amp;#39;&lt;/span&gt;, dest&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;url&amp;#39;&lt;/span&gt;, default&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;hello&lt;/span&gt;(name, url):
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; url &lt;span style="color: #AA22FF; font-weight: bold"&gt;is&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;:
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;, name
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;else&lt;/span&gt;:
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;, name, &lt;span style="color: #BB4444"&gt;&amp;quot;from&amp;quot;&lt;/span&gt;, url
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述命令可以这样调用：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;python manage.py hello -n Joe -u reddit.com
&amp;gt; hello Joe from reddit.com
&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;python manage.py hello -n Joe
&amp;gt; hello Joe
&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;python manage.py hello --name Joey --url kamidox.com
&amp;gt; hello Joey from kamidox.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实际上，使用&lt;code&gt;@command&lt;/code&gt;装饰器也可以实现上述相同的带参数的命令，只是使用&lt;code&gt;@option&lt;/code&gt;可读性更好一点。&lt;/p&gt;
&lt;h3 id="_3"&gt;获取用户输入&lt;/h3&gt;
&lt;p&gt;在创建数据库时，需要和用户交互，输入数据库用户名密码等信息。我们可以借助prompt系列函数来获取用户的输入：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;flask.ext.script&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; Manager, prompt_bool

&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;myapp&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; app
&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;myapp.models&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; db

manager &lt;span style="color: #666666"&gt;=&lt;/span&gt; Manager(app)

&lt;span style="color: #AA22FF"&gt;@manager.command&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;dropdb&lt;/span&gt;():
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; prompt_bool(&lt;span style="color: #BB4444"&gt;&amp;quot;Are you sure you want to lose all your data&amp;quot;&lt;/span&gt;):
        db&lt;span style="color: #666666"&gt;.&lt;/span&gt;drop_all()
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这个命令可以这样调用：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;python manage.py dropdb
&amp;gt; Are you sure you want to lose all your data ? &lt;span style="color: #666666"&gt;[&lt;/span&gt;N&lt;span style="color: #666666"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Flask-Script还提供了&lt;code&gt;prompt_pass()&lt;/code&gt;，&lt;code&gt;prompt_choices()&lt;/code&gt;等不同形态的函数来获取用户输入信息。&lt;/p&gt;
&lt;h3 id="_4"&gt;其它技巧&lt;/h3&gt;
&lt;p&gt;不带任何参数运行&lt;code&gt;python manage.py&lt;/code&gt;会输出可用的命令列表：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;.venv&lt;span style="color: #666666"&gt;)&lt;/span&gt;kamidox@kamidox-laptop:~/code/flaskbb&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;python manage.py
usage: manage.py &lt;span style="color: #666666"&gt;[&lt;/span&gt;-?&lt;span style="color: #666666"&gt;]&lt;/span&gt;
                 &lt;span style="color: #666666"&gt;{&lt;/span&gt;shell,create_admin,db,createall,runserver,initflaskbb,initdb,dropdb&lt;span style="color: #666666"&gt;}&lt;/span&gt;
                 ...

positional arguments:
  &lt;span style="color: #666666"&gt;{&lt;/span&gt;shell,create_admin,db,createall,runserver,initflaskbb,initdb,dropdb&lt;span style="color: #666666"&gt;}&lt;/span&gt;
    shell               Runs a Python shell inside Flask application context.
    create_admin        Creates the admin user
    db                  Perform database migrations
    createall           Creates the database with some testing content. If you
                        &lt;span style="color: #AA22FF; font-weight: bold"&gt;do&lt;/span&gt; not want to drop or create the db add &lt;span style="color: #BB4444"&gt;&amp;#39;-c&amp;#39;&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;to not
                        create the db&lt;span style="color: #666666"&gt;)&lt;/span&gt; and &lt;span style="color: #BB4444"&gt;&amp;#39;-d&amp;#39;&lt;/span&gt; &lt;span style="color: #666666"&gt;(&lt;/span&gt;to not drop the db&lt;span style="color: #666666"&gt;)&lt;/span&gt;
    runserver           Runs the Flask development server i.e. app.run&lt;span style="color: #666666"&gt;()&lt;/span&gt;
    initflaskbb         Initializes FlaskBB with all necessary data
    initdb              Creates the database.
    dropdb              Deletes the database

optional arguments:
  -?, --help            show this &lt;span style="color: #AA22FF"&gt;help &lt;/span&gt;message and &lt;span style="color: #AA22FF"&gt;exit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以针对特定命令获取其帮助信息：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #666666"&gt;(&lt;/span&gt;.venv&lt;span style="color: #666666"&gt;)&lt;/span&gt;kamidox@kamidox-laptop:~/code/flaskbb&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;python manage.py runserver --help
usage: manage.py runserver &lt;span style="color: #666666"&gt;[&lt;/span&gt;-?&lt;span style="color: #666666"&gt;]&lt;/span&gt; &lt;span style="color: #666666"&gt;[&lt;/span&gt;-h HOST&lt;span style="color: #666666"&gt;]&lt;/span&gt; &lt;span style="color: #666666"&gt;[&lt;/span&gt;-p PORT&lt;span style="color: #666666"&gt;]&lt;/span&gt; &lt;span style="color: #666666"&gt;[&lt;/span&gt;--threaded&lt;span style="color: #666666"&gt;]&lt;/span&gt;
                           &lt;span style="color: #666666"&gt;[&lt;/span&gt;--processes PROCESSES&lt;span style="color: #666666"&gt;]&lt;/span&gt; &lt;span style="color: #666666"&gt;[&lt;/span&gt;--passthrough-errors&lt;span style="color: #666666"&gt;]&lt;/span&gt; &lt;span style="color: #666666"&gt;[&lt;/span&gt;-d&lt;span style="color: #666666"&gt;]&lt;/span&gt;
                           &lt;span style="color: #666666"&gt;[&lt;/span&gt;-D&lt;span style="color: #666666"&gt;]&lt;/span&gt; &lt;span style="color: #666666"&gt;[&lt;/span&gt;-r&lt;span style="color: #666666"&gt;]&lt;/span&gt; &lt;span style="color: #666666"&gt;[&lt;/span&gt;-R&lt;span style="color: #666666"&gt;]&lt;/span&gt;

Runs the Flask development server i.e. app.run&lt;span style="color: #666666"&gt;()&lt;/span&gt;

optional arguments:
  -?, --help            show this &lt;span style="color: #AA22FF"&gt;help &lt;/span&gt;message and &lt;span style="color: #AA22FF"&gt;exit&lt;/span&gt;
  -h HOST, --host HOST
  -p PORT, --port PORT
  --threaded
  --processes PROCESSES
  --passthrough-errors
  -d, --debug           &lt;span style="color: #AA22FF"&gt;enable &lt;/span&gt;the Werkzeug debugger &lt;span style="color: #666666"&gt;(&lt;/span&gt;DO NOT use in production
                        code&lt;span style="color: #666666"&gt;)&lt;/span&gt;
  -D, --no-debug        disable the Werkzeug debugger
  -r, --reload          monitor Python files &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; changes &lt;span style="color: #666666"&gt;(&lt;/span&gt;not 100&lt;span style="color: #666666"&gt;{&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;const&amp;#39;&lt;/span&gt;:
                        True, &lt;span style="color: #BB4444"&gt;&amp;#39;help&amp;#39;&lt;/span&gt;: &lt;span style="color: #BB4444"&gt;&amp;#39;monitor Python files for changes (not&lt;/span&gt;
&lt;span style="color: #BB4444"&gt;                        100% safe for production use)&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;option_strings&amp;#39;&lt;/span&gt;:
                        &lt;span style="color: #666666"&gt;[&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;-r&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;--reload&amp;#39;&lt;/span&gt;&lt;span style="color: #666666"&gt;]&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;dest&amp;#39;&lt;/span&gt;: &lt;span style="color: #BB4444"&gt;&amp;#39;use_reloader&amp;#39;&lt;/span&gt;,
                        &lt;span style="color: #BB4444"&gt;&amp;#39;required&amp;#39;&lt;/span&gt;: False, &lt;span style="color: #BB4444"&gt;&amp;#39;nargs&amp;#39;&lt;/span&gt;: 0, &lt;span style="color: #BB4444"&gt;&amp;#39;choices&amp;#39;&lt;/span&gt;: None,
                        &lt;span style="color: #BB4444"&gt;&amp;#39;default&amp;#39;&lt;/span&gt;: None, &lt;span style="color: #BB4444"&gt;&amp;#39;prog&amp;#39;&lt;/span&gt;: &lt;span style="color: #BB4444"&gt;&amp;#39;manage.py runserver&amp;#39;&lt;/span&gt;,
                        &lt;span style="color: #BB4444"&gt;&amp;#39;container&amp;#39;&lt;/span&gt;: &amp;lt;argparse._ArgumentGroup object at
                        0xb609cd6c&amp;gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;type&amp;#39;&lt;/span&gt;: None, &lt;span style="color: #BB4444"&gt;&amp;#39;metavar&amp;#39;&lt;/span&gt;: None&lt;span style="color: #666666"&gt;}&lt;/span&gt;afe &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt;
                        production use&lt;span style="color: #666666"&gt;)&lt;/span&gt;
  -R, --no-reload       &lt;span style="color: #AA22FF; font-weight: bold"&gt;do&lt;/span&gt; not monitor Python files &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; changes
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更多详细的用法可参阅&lt;a href="http://flask-script.readthedocs.org/"&gt;Flask-Script官方文档&lt;/a&gt;，如果翻墙不便，也可以从GitHub上下载Flask-Script源码，然后在docs自己编译生成html文档。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;cd&lt;/span&gt; ~/code
git clone https://github.com/smurfix/flask-script.git
&lt;span style="color: #AA22FF"&gt;cd &lt;/span&gt;docs
make html
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译完成后，打开&lt;code&gt;docs/_build/html/index.html&lt;/code&gt;即可查阅Flask-Script文档了。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Sphinx&lt;/p&gt;
&lt;p&gt;如果编译提示出错，检查一下是否安装了&lt;a href="http://sphinx.pocoo.org/"&gt;Sphinx&lt;/a&gt;。这是个用来生成优美的html文档的引擎。IBM DeveloperWorks有&lt;a href="http://www.ibm.com/developerworks/cn/opensource/os-sphinx-documentation/"&gt;一篇文章&lt;/a&gt;介绍了Sphinx的作用。感兴趣的朋友可以参考一下。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="managepy"&gt;manage.py源码分析&lt;/h2&gt;
&lt;p&gt;有了上面的背景知识，阅读&lt;code&gt;manage.py&lt;/code&gt;就很轻松了。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;@manager.option&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;#39;-u&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;--username&amp;#39;&lt;/span&gt;, dest&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;username&amp;#39;&lt;/span&gt;)
&lt;span style="color: #AA22FF"&gt;@manager.option&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;#39;-p&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;--password&amp;#39;&lt;/span&gt;, dest&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;password&amp;#39;&lt;/span&gt;)
&lt;span style="color: #AA22FF"&gt;@manager.option&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;#39;-e&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;--email&amp;#39;&lt;/span&gt;, dest&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;email&amp;#39;&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;initflaskbb&lt;/span&gt;(username&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;, password&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;, email&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;Initializes FlaskBB with all necessary data&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;logger&lt;span style="color: #666666"&gt;.&lt;/span&gt;info(&lt;span style="color: #BB4444"&gt;&amp;quot;Creating default data...&amp;quot;&lt;/span&gt;)
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;try&lt;/span&gt;:
        create_default_groups()
        create_default_settings()
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;except&lt;/span&gt; IntegrityError:
        app&lt;span style="color: #666666"&gt;.&lt;/span&gt;logger&lt;span style="color: #666666"&gt;.&lt;/span&gt;error(&lt;span style="color: #BB4444"&gt;&amp;quot;Couldn&amp;#39;t create the default data because it already &amp;quot;&lt;/span&gt;
                         &lt;span style="color: #BB4444"&gt;&amp;quot;exist!&amp;quot;&lt;/span&gt;)
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; prompt_bool(&lt;span style="color: #BB4444"&gt;&amp;quot;Do you want to recreate the database? (y/n)&amp;quot;&lt;/span&gt;):
            db&lt;span style="color: #666666"&gt;.&lt;/span&gt;session&lt;span style="color: #666666"&gt;.&lt;/span&gt;rollback()
            db&lt;span style="color: #666666"&gt;.&lt;/span&gt;drop_all()
            db&lt;span style="color: #666666"&gt;.&lt;/span&gt;create_all()
            create_default_groups()
            create_default_settings()
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;else&lt;/span&gt;:
            sys&lt;span style="color: #666666"&gt;.&lt;/span&gt;exit(&lt;span style="color: #666666"&gt;0&lt;/span&gt;)
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;except&lt;/span&gt; OperationalError:
        app&lt;span style="color: #666666"&gt;.&lt;/span&gt;logger&lt;span style="color: #666666"&gt;.&lt;/span&gt;error(&lt;span style="color: #BB4444"&gt;&amp;quot;No database found.&amp;quot;&lt;/span&gt;)
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; prompt_bool(&lt;span style="color: #BB4444"&gt;&amp;quot;Do you want to create the database now? (y/n)&amp;quot;&lt;/span&gt;):
            db&lt;span style="color: #666666"&gt;.&lt;/span&gt;session&lt;span style="color: #666666"&gt;.&lt;/span&gt;rollback()
            db&lt;span style="color: #666666"&gt;.&lt;/span&gt;create_all()
            create_default_groups()
            create_default_settings()
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;else&lt;/span&gt;:
            sys&lt;span style="color: #666666"&gt;.&lt;/span&gt;exit(&lt;span style="color: #666666"&gt;0&lt;/span&gt;)

    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;logger&lt;span style="color: #666666"&gt;.&lt;/span&gt;info(&lt;span style="color: #BB4444"&gt;&amp;quot;Creating admin user...&amp;quot;&lt;/span&gt;)
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; username &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; password &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; email:
        create_admin_user(username&lt;span style="color: #666666"&gt;=&lt;/span&gt;username, password&lt;span style="color: #666666"&gt;=&lt;/span&gt;password, email&lt;span style="color: #666666"&gt;=&lt;/span&gt;email)
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;else&lt;/span&gt;:
        create_admin()

    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;logger&lt;span style="color: #666666"&gt;.&lt;/span&gt;info(&lt;span style="color: #BB4444"&gt;&amp;quot;Creating welcome forum...&amp;quot;&lt;/span&gt;)
    create_welcome_forum()

    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;logger&lt;span style="color: #666666"&gt;.&lt;/span&gt;info(&lt;span style="color: #BB4444"&gt;&amp;quot;Congratulations! FlaskBB has been successfully installed&amp;quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;上面是&lt;code&gt;manage.py&lt;/code&gt;里&lt;code&gt;initflaskbb&lt;/code&gt;命令的代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Line 1-4: 声明了&lt;code&gt;initflaskbb&lt;/code&gt;命令，并且带三个参数，分别是&lt;code&gt;username&lt;/code&gt;，&lt;code&gt;password&lt;/code&gt;，&lt;code&gt;email&lt;/code&gt;用来创建管理员用户&lt;/li&gt;
&lt;li&gt;Line 9-10: 创建论坛默认组和设置信息。具体后面分析应用程序的数据模型时再来深入分析。&lt;/li&gt;
&lt;li&gt;Line 11-14: 如果捕获到&lt;code&gt;IntegrityError&lt;/code&gt;异常，说明数据库中的相应数据已经存在，则用&lt;code&gt;prompt_bool&lt;/code&gt;来提示用户是否覆盖原有数据&lt;/li&gt;
&lt;li&gt;Line 22-24: 如何捕获到&lt;code&gt;OperationalError&lt;/code&gt;异常，说明数据库不存在，用&lt;code&gt;prompt_bool&lt;/code&gt;提示用户是否创建数据库&lt;/li&gt;
&lt;li&gt;Line 33-36: 创建管理员帐户&lt;/li&gt;
&lt;li&gt;Line 39: 创建默认的论坛板块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以通过运行下面的命令来初始化论坛数据：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;python manage.py initflaskbb -u admin -p admin -e admin@kamidox.com
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_5"&gt;结束语&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;manage.py&lt;/code&gt;主要通过Flask-Script扩展来实现开发，调试及部署过程中的数据库初始化以及一些交互调试功能，是程序必不可少的组成部分。&lt;/p&gt;</summary><category term="python"></category><category term="flask"></category></entry><entry><title>FlaskBB阅读笔记（一）</title><link href="http://blog.kamidox.com/flaskbb-notes-1.html" rel="alternate"></link><updated>2014-11-02T23:25:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-11-02:flaskbb-notes-1.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;开篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#blueprint"&gt;Blueprint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#flaskbbflask"&gt;FlaskBB用到的Flask扩展&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#jinja2"&gt;自定义的Jinja2过滤器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;向模板注入设置信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;更新用户在线信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;自定义错误处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#log"&gt;LOG配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;结束语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;开篇&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/sh4nks/flaskbb"&gt;FlaskBB&lt;/a&gt;是用Flask框架实现的一个轻量级的论坛社区软件，代码托管在GitHub上。本系列文章通过阅读FlaskBB的源代码来深入学习Flask框架，以及在一个产品级的Flask应用里的一些最佳实践规则。&lt;/p&gt;
&lt;p&gt;本文是这系列文章的第一遍。本文分析FlaskBB的主程序&lt;code&gt;app.py&lt;/code&gt;的源码。我们从&lt;code&gt;create_app()&lt;/code&gt;函数入手，分析FlaskBB的软件结构。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;create_app&lt;/span&gt;(config&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    Creates the app.&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #008800; font-style: italic"&gt;# Initialize the app&lt;/span&gt;
    app &lt;span style="color: #666666"&gt;=&lt;/span&gt; Flask(&lt;span style="color: #BB4444"&gt;&amp;quot;flaskbb&amp;quot;&lt;/span&gt;)

    &lt;span style="color: #008800; font-style: italic"&gt;# Use the default config and override it afterwards&lt;/span&gt;
    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config&lt;span style="color: #666666"&gt;.&lt;/span&gt;from_object(&lt;span style="color: #BB4444"&gt;&amp;#39;flaskbb.configs.default.DefaultConfig&amp;#39;&lt;/span&gt;)
    &lt;span style="color: #008800; font-style: italic"&gt;# Update the config&lt;/span&gt;
    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config&lt;span style="color: #666666"&gt;.&lt;/span&gt;from_object(config)
    &lt;span style="color: #008800; font-style: italic"&gt;# try to update the config via the environment variable&lt;/span&gt;
    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config&lt;span style="color: #666666"&gt;.&lt;/span&gt;from_envvar(&lt;span style="color: #BB4444"&gt;&amp;quot;FLASKBB_SETTINGS&amp;quot;&lt;/span&gt;, silent&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)

    configure_blueprints(app)
    configure_extensions(app)
    configure_template_filters(app)
    configure_context_processors(app)
    configure_before_handlers(app)
    configure_errorhandlers(app)
    configure_logging(app)

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; app
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id="_2"&gt;配置&lt;/h2&gt;
&lt;p&gt;FlaskBB使用下面典型的配置代码了加载应用程序的配置信息。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# Use the default config and override it afterwards&lt;/span&gt;
app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config&lt;span style="color: #666666"&gt;.&lt;/span&gt;from_object(&lt;span style="color: #BB4444"&gt;&amp;#39;flaskbb.configs.default.DefaultConfig&amp;#39;&lt;/span&gt;)
&lt;span style="color: #008800; font-style: italic"&gt;# Update the config&lt;/span&gt;
app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config&lt;span style="color: #666666"&gt;.&lt;/span&gt;from_object(config)
&lt;span style="color: #008800; font-style: italic"&gt;# try to update the config via the environment variable&lt;/span&gt;
app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config&lt;span style="color: #666666"&gt;.&lt;/span&gt;from_envvar(&lt;span style="color: #BB4444"&gt;&amp;quot;FLASKBB_SETTINGS&amp;quot;&lt;/span&gt;, silent&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;code&gt;Flask.config&lt;/code&gt;类是专门用来处理应用程序全局配置信息的。它类似python的&lt;code&gt;dict&lt;/code&gt;类，增加了一些导入配置的函数而已。其中&lt;code&gt;Flask.config.from_object()&lt;/code&gt;用来从一个python类里导入配置信息，需要注意的是，这个函数&lt;strong&gt;只导入大写的类成员变量&lt;/strong&gt;，小写的类成员函数是不导入的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Flask.config.from_envvar()&lt;/code&gt;用来从环境变量指定的文件中导入设置信息，比如上例中，可以设置&lt;code&gt;FLASKBB_SETTINGS&lt;/code&gt;的环境变量指向&lt;em&gt;/path/to/python/config/file.py&lt;/em&gt;，这样程序就会从这个文件里导入配置信息。&lt;/p&gt;
&lt;p&gt;需要注意的是，最后导入的配置信息可覆盖前面导入的信息。所以，一般会有三个层次：一是默认配置；二是应用程序创建时传入的参数；最后再从环境变量里导入。&lt;/p&gt;
&lt;p&gt;FlaskBB提供了不少配置信息，比如&lt;code&gt;SEND_LOGS&lt;/code&gt;表示是不是要把错误信息发送给网站管理员邮箱；&lt;code&gt;SQLALCHEMY_DATABASE_URI&lt;/code&gt;表示ORM数据库路径等等。具体参阅&lt;code&gt;flaskbb.configs.default.DefaultConfig&lt;/code&gt;类。&lt;/p&gt;
&lt;h2 id="blueprint"&gt;Blueprint&lt;/h2&gt;
&lt;p&gt;Blueprint是Flask提供的模块化设计组件。FlaskBB通过&lt;code&gt;configure_blueprints()&lt;/code&gt;来初始化Blueprint&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;configure_blueprints&lt;/span&gt;(app):
    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;register_blueprint(forum, url_prefix&lt;span style="color: #666666"&gt;=&lt;/span&gt;app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;quot;FORUM_URL_PREFIX&amp;quot;&lt;/span&gt;])
    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;register_blueprint(user, url_prefix&lt;span style="color: #666666"&gt;=&lt;/span&gt;app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;quot;USER_URL_PREFIX&amp;quot;&lt;/span&gt;])
    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;register_blueprint(auth, url_prefix&lt;span style="color: #666666"&gt;=&lt;/span&gt;app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;quot;AUTH_URL_PREFIX&amp;quot;&lt;/span&gt;])
    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;register_blueprint(management, url_prefix&lt;span style="color: #666666"&gt;=&lt;/span&gt;app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;quot;ADMIN_URL_PREFIX&amp;quot;&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;主要由四个Blueprint组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;forum&lt;br /&gt;
  论坛主模块，由&lt;code&gt;flaskbb.forum.views.forum&lt;/code&gt;Blueprint实现，默认其挂载的URL是&lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;user&lt;br /&gt;
  用户管理模块，由&lt;code&gt;flaskbb.user.views.user&lt;/code&gt;Blueprint实现，默认其挂载的URL是&lt;code&gt;/user&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;auth&lt;br /&gt;
  鉴权模块，由&lt;code&gt;flaskbb.auth.views.auth&lt;/code&gt;Blueprint实现，默认其挂载的URL是&lt;code&gt;/auth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;management&lt;br /&gt;
  后台管理模块，由&lt;code&gt;flaskbb.management.views.management&lt;/code&gt;Blueprint实现，默认其挂载的URL是&lt;code&gt;/admin&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="flaskbbflask"&gt;FlaskBB用到的Flask扩展&lt;/h2&gt;
&lt;p&gt;有大量的第三方开发者为Flask构架开发扩展，在&lt;a href="http://flask.pocoo.org/extensions/"&gt;这里&lt;/a&gt;可以找到官方收录的所有Flask扩展。FlaskBB通过&lt;code&gt;configure_extensions()&lt;/code&gt;函数来初始化用到的扩展。这些扩展的简要信息汇总如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://github.com/mitsuhiko/flask-sqlalchemy/"&gt;Flask-SQLAlchemy&lt;/a&gt;&lt;br /&gt;
  这是&lt;a href="http://www.sqlalchemy.org/"&gt;sqlalchemy&lt;/a&gt;的Flask扩展，提供SQL数据库和ORM访问。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.com/maxcountryman/flask-login/"&gt;Flask-Login&lt;/a&gt;&lt;br /&gt;
  这个扩展提供了用户会话管理。实现了一些通用的会话管理任务，如登录，登出，以及记录用户会话期间的状态数据等。&lt;/li&gt;
&lt;li&gt;&lt;a href="　http://github.com/mattupstate/flask-mail/"&gt;Flask-Mail&lt;/a&gt;&lt;br /&gt;
  这个扩展让Flask应用很容易地发送电子邮件，而且支持单元测试。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.com/thadeusb/flask-cache/"&gt;Flask-Cache&lt;/a&gt;&lt;br /&gt;
  给Flask程序提供Cache支持。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.com/mgood/flask-debugtoolbar/"&gt;Flask-DebugToolbar&lt;/a&gt;&lt;br /&gt;
  从Django移植过来的适用于Flask的调试器。主要用来调试Flask程序及性能。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rhyselsmore/flask-redis/"&gt;Flask-Redis&lt;/a&gt;&lt;br /&gt;
  给Flask程序添加&lt;a href="http://www.redis.cn/"&gt;Redis&lt;/a&gt;的扩展。Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/miguelgrinberg/Flask-Migrate"&gt;Flask-Migrate&lt;/a&gt;&lt;br /&gt;
  给Flask用的SQLAlchemy数据库迁移工具。比如，Flask应用的1.3版本在1.2版本的数据库的某个表里添加了一个字段，那么使用这个工具可以自动生成数据库迁移脚本，帮助使用1.2版本的用户把数据库从1.2版本升级到1.3版本。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sysr-q/flask-themes2"&gt;Flask-Theme2&lt;/a&gt;&lt;br /&gt;
  给Flask应用添加主题支持。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sh4nks/flask-plugins"&gt;Flask-Plugins&lt;/a&gt;&lt;br /&gt;
  和FlaskBB的作者是同一个人。提供更简单的插件管理。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/gyllstromk/Flask-WhooshAlchemy"&gt;Flask-WhooshAlchemy&lt;/a&gt;&lt;br /&gt;
  这个扩展帮助Flask程序实现基于SQLAlchemy数据库内容的文本搜索和索引服务。正如扩展的名字，它是使用&lt;a href="https://bitbucket.org/mchaput/whoosh/wiki/Home"&gt;whoosh&lt;/a&gt;和SQLAlchemy的ORM结合起来实现广西内容的搜索和索引功能。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/lepture/flask-wtf"&gt;Flask-WTF&lt;/a&gt;&lt;br /&gt;
  当你必须处理浏览器提交的表单数据时，视图代码很快会变得难以阅读。有一些库可以简化这个工作，其中之一便是WTForms。这个扩展让Flask使用更简单地集成WTForms，同时处理了CSRF(Cross-Site Rrequest Forgery，跨站请求伪造)，提供更好的安全性。还提供文件上传等功能。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.com/techniq/flask-script/"&gt;Flask-Script&lt;/a&gt;&lt;br /&gt;
  给Flask应用程序提供外部脚本支持。比如运行开发服务器，初始化数据库，等命令行相关的任务。对FlaskBB而言，&lt;code&gt;python manage.py runserver&lt;/code&gt;和&lt;code&gt;python manage.py createall&lt;/code&gt;等命令就是通过这个扩展实现的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="jinja2"&gt;自定义的Jinja2过滤器&lt;/h2&gt;
&lt;p&gt;Jinja2提供了&lt;a href="http://jinja.pocoo.org/docs/dev/api/#custom-filters"&gt;自定义过滤器&lt;/a&gt;的功能，可以在Jinja2模板里灵活使用。FlaskBB通过函数&lt;code&gt;configure_template_filters()&lt;/code&gt;定义了一系列过滤器，其中&lt;code&gt;is_online&lt;/code&gt;过滤器是这样定义的：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;app&lt;span style="color: #666666"&gt;.&lt;/span&gt;jinja_env&lt;span style="color: #666666"&gt;.&lt;/span&gt;filters[&lt;span style="color: #BB4444"&gt;&amp;#39;is_online&amp;#39;&lt;/span&gt;] &lt;span style="color: #666666"&gt;=&lt;/span&gt; is_online
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;过滤器就是一个简单的python函数，&lt;code&gt;is_online()&lt;/code&gt;函数定义在&lt;em&gt;flaskbb/utils/helper.py&lt;/em&gt;里：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;is_online&lt;/span&gt;(user):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;A simple check to see if the user was online within a specified&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    time range&lt;/span&gt;

&lt;span style="color: #BB4444; font-style: italic"&gt;    :param user: The user who needs to be checked&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; user&lt;span style="color: #666666"&gt;.&lt;/span&gt;lastseen &lt;span style="color: #666666"&gt;&amp;gt;=&lt;/span&gt; time_diff()
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这样，在Jinaja2模板&lt;em&gt;flaskbb/templates/user/profile.html&lt;/em&gt;里，就可以使用下面的代码来判断用户是否在线：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;{% if user|is_online %}
&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span&lt;/span&gt; &lt;span style="color: #BB4444"&gt;class=&amp;quot;label label-success&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;Online&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
{% else %}
&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span&lt;/span&gt; &lt;span style="color: #BB4444"&gt;class=&amp;quot;label label-default&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;Offline&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
{% endif %}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面Jinja2模板里&lt;code&gt;user|is_online&lt;/code&gt;脚本会导致&lt;code&gt;is_online(user)&lt;/code&gt;被调用来判断用户是否在线。&lt;/p&gt;
&lt;h2 id="_3"&gt;向模板注入设置信息&lt;/h2&gt;
&lt;p&gt;FlaskBB通过调用&lt;code&gt;configure_context_processors()&lt;/code&gt;向模板注入设置信息。代码如下：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;configure_context_processors&lt;/span&gt;(app):
&lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;Configures the context processors&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #AA22FF"&gt;@app.context_processor&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;inject_flaskbb_config&lt;/span&gt;():
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    Injects the ``flaskbb_config`` config variable into the templates.&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;dict&lt;/span&gt;(flaskbb_config&lt;span style="color: #666666"&gt;=&lt;/span&gt;flaskbb_config)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;使用&lt;code&gt;context_processor&lt;/code&gt;装饰器来装饰&lt;code&gt;inject_flaskbb_config()&lt;/code&gt;函数，这样这个函数会被Flask记录起来，每次要渲染模板时，会先调用这个函数更新一下模板上下文信息。这样，在模板里就可以访问这里注入的上下文信息。上下文处理器函数必须返回一个&lt;code&gt;dict&lt;/code&gt;实例。Flask官方文档对&lt;a href="http://flask.pocoo.org/docs/0.10/templating/#context-processors"&gt;context_processor&lt;/a&gt;有详细的描述。&lt;/p&gt;
&lt;p&gt;例如，返回的&lt;code&gt;dict&lt;/code&gt;里包含&amp;rsquo;name: kamidox&amp;rsquo;这样的值，则在Jinja2模板里可以直接用&lt;code&gt;{% name %}&lt;/code&gt;来访问&lt;code&gt;name&lt;/code&gt;变量，其值为&lt;code&gt;kamidox&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="_4"&gt;更新用户在线信息&lt;/h2&gt;
&lt;p&gt;FlaskBB通过&lt;code&gt;configure_before_handlers()&lt;/code&gt;函数来注册每个请求之前的动作，以记录用户的在线信息。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;configure_before_handlers&lt;/span&gt;(app):
&lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;Configures the before request handlers&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span style="color: #AA22FF"&gt;@app.before_request&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;update_lastseen&lt;/span&gt;():
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    Updates `lastseen` before every reguest if the user is authenticated&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; current_user&lt;span style="color: #666666"&gt;.&lt;/span&gt;is_authenticated():
        current_user&lt;span style="color: #666666"&gt;.&lt;/span&gt;lastseen &lt;span style="color: #666666"&gt;=&lt;/span&gt; datetime&lt;span style="color: #666666"&gt;.&lt;/span&gt;datetime&lt;span style="color: #666666"&gt;.&lt;/span&gt;utcnow()
        db&lt;span style="color: #666666"&gt;.&lt;/span&gt;session&lt;span style="color: #666666"&gt;.&lt;/span&gt;add(current_user)
        db&lt;span style="color: #666666"&gt;.&lt;/span&gt;session&lt;span style="color: #666666"&gt;.&lt;/span&gt;commit()
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这里，&lt;code&gt;before_request&lt;/code&gt;装饰器将把&lt;code&gt;update_lastseen()&lt;/code&gt;函数注册进Flask，Flask在处理请求之前都会调用这个函数。FlaskBB使用这个机制来记录最后一次看到用户的时间。结合会话的超时机制，就可以判断用户是否在线。&lt;/p&gt;
&lt;h2 id="_5"&gt;自定义错误处理&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;configure_errorhandlers()&lt;/code&gt;来实现自定义错误处理。其中，HTTP 403, 404及500的错误处理定义如下&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;configure_errorhandlers&lt;/span&gt;(app):
&lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;Configures the error handlers&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span style="color: #AA22FF"&gt;@app.errorhandler&lt;/span&gt;(&lt;span style="color: #666666"&gt;403&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;forbidden_page&lt;/span&gt;(error):
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; render_template(&lt;span style="color: #BB4444"&gt;&amp;quot;errors/forbidden_page.html&amp;quot;&lt;/span&gt;), &lt;span style="color: #666666"&gt;403&lt;/span&gt;

&lt;span style="color: #AA22FF"&gt;@app.errorhandler&lt;/span&gt;(&lt;span style="color: #666666"&gt;404&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;page_not_found&lt;/span&gt;(error):
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; render_template(&lt;span style="color: #BB4444"&gt;&amp;quot;errors/page_not_found.html&amp;quot;&lt;/span&gt;), &lt;span style="color: #666666"&gt;404&lt;/span&gt;

&lt;span style="color: #AA22FF"&gt;@app.errorhandler&lt;/span&gt;(&lt;span style="color: #666666"&gt;500&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;server_error_page&lt;/span&gt;(error):
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; render_template(&lt;span style="color: #BB4444"&gt;&amp;quot;errors/server_error.html&amp;quot;&lt;/span&gt;), &lt;span style="color: #666666"&gt;500&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这样当发生这些http错误时，错误网页将从服务器返回自定义的错误网页，而不是浏览器客户端默认的错误页面。&lt;/p&gt;
&lt;h2 id="log"&gt;LOG配置&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;configure_logging()&lt;/code&gt;来配置系统的LOG。FlaskBB的LOG主要保存在应用程序根目录下的&lt;em&gt;logs&lt;/em&gt;目录里，分两个文件保存，一个是INFO级别的LOG，另外一个是ERROR级别的LOG。同时还支持把ERROR级别的LOG通过邮件的方式发送给网站管理员。&lt;/p&gt;
&lt;p&gt;下面代码配置了INFO级别的LOG：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;logs_folder &lt;span style="color: #666666"&gt;=&lt;/span&gt; os&lt;span style="color: #666666"&gt;.&lt;/span&gt;path&lt;span style="color: #666666"&gt;.&lt;/span&gt;join(app&lt;span style="color: #666666"&gt;.&lt;/span&gt;root_path, os&lt;span style="color: #666666"&gt;.&lt;/span&gt;pardir, &lt;span style="color: #BB4444"&gt;&amp;quot;logs&amp;quot;&lt;/span&gt;)
formatter &lt;span style="color: #666666"&gt;=&lt;/span&gt; logging&lt;span style="color: #666666"&gt;.&lt;/span&gt;Formatter(
    &lt;span style="color: #BB4444"&gt;&amp;#39;&lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%(asctime)s&lt;/span&gt;&lt;span style="color: #BB4444"&gt; &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%(levelname)s&lt;/span&gt;&lt;span style="color: #BB4444"&gt;: &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%(message)s&lt;/span&gt;&lt;span style="color: #BB4444"&gt; &amp;#39;&lt;/span&gt;
    &lt;span style="color: #BB4444"&gt;&amp;#39;[in &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%(pathname)s&lt;/span&gt;&lt;span style="color: #BB4444"&gt;:&lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%(lineno)d&lt;/span&gt;&lt;span style="color: #BB4444"&gt;]&amp;#39;&lt;/span&gt;)

info_log &lt;span style="color: #666666"&gt;=&lt;/span&gt; os&lt;span style="color: #666666"&gt;.&lt;/span&gt;path&lt;span style="color: #666666"&gt;.&lt;/span&gt;join(logs_folder, app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;#39;INFO_LOG&amp;#39;&lt;/span&gt;])

info_file_handler &lt;span style="color: #666666"&gt;=&lt;/span&gt; logging&lt;span style="color: #666666"&gt;.&lt;/span&gt;handlers&lt;span style="color: #666666"&gt;.&lt;/span&gt;RotatingFileHandler(
    info_log,
    maxBytes&lt;span style="color: #666666"&gt;=100000&lt;/span&gt;,
    backupCount&lt;span style="color: #666666"&gt;=10&lt;/span&gt;
)

info_file_handler&lt;span style="color: #666666"&gt;.&lt;/span&gt;setLevel(logging&lt;span style="color: #666666"&gt;.&lt;/span&gt;INFO)
info_file_handler&lt;span style="color: #666666"&gt;.&lt;/span&gt;setFormatter(formatter)
app&lt;span style="color: #666666"&gt;.&lt;/span&gt;logger&lt;span style="color: #666666"&gt;.&lt;/span&gt;addHandler(info_file_handler)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;下面代码配置了通过邮件发送错误LOG给网站管理员：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;logging.handlers&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; SMTPHandler
&lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;quot;SEND_LOGS&amp;quot;&lt;/span&gt;]:
    mail_handler &lt;span style="color: #666666"&gt;=&lt;/span&gt; \
        SMTPHandler(app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;#39;MAIL_SERVER&amp;#39;&lt;/span&gt;],
                    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;#39;MAIL_DEFAULT_SENDER&amp;#39;&lt;/span&gt;],
                    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;#39;ADMINS&amp;#39;&lt;/span&gt;],
                    &lt;span style="color: #BB4444"&gt;&amp;#39;application error, no admins specified&amp;#39;&lt;/span&gt;,
                    (
                        app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;#39;MAIL_USERNAME&amp;#39;&lt;/span&gt;],
                        app&lt;span style="color: #666666"&gt;.&lt;/span&gt;config[&lt;span style="color: #BB4444"&gt;&amp;#39;MAIL_PASSWORD&amp;#39;&lt;/span&gt;],
                    ))

    mail_handler&lt;span style="color: #666666"&gt;.&lt;/span&gt;setLevel(logging&lt;span style="color: #666666"&gt;.&lt;/span&gt;ERROR)
    mail_handler&lt;span style="color: #666666"&gt;.&lt;/span&gt;setFormatter(formatter)
    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;logger&lt;span style="color: #666666"&gt;.&lt;/span&gt;addHandler(mail_handler)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2 id="_6"&gt;结束语&lt;/h2&gt;
&lt;p&gt;通过对主程序&lt;code&gt;app.py&lt;/code&gt;的代码分析，我们基本上知道了FlaskBB的主体框架，模块划分，用到的外部扩展等信息。下一篇将分模块深入阅读各个Blueprint模块的实现以及数据库设计方面的内容。&lt;/p&gt;</summary><category term="python"></category><category term="flask"></category></entry><entry><title>使用Flask搭建一个流媒体服务器</title><link href="http://blog.kamidox.com/build-streaming-server-by-flask.html" rel="alternate"></link><updated>2014-10-28T23:25:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-10-28:build-streaming-server-by-flask.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;摘要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;理论基础&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;生成器函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#multipart"&gt;Multipart应答&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;实现流媒体服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;模拟视频帧数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;连接硬件摄像头&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;一些限制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;摘要&lt;/h2&gt;
&lt;p&gt;收到前不久订阅的&lt;a href="http://www.pythonweekly.com/"&gt;PythonWeekly&lt;/a&gt;发过来的一个邮件通知，由&lt;a href="http://blog.miguelgrinberg.com/"&gt;Miguel&lt;/a&gt;写的一篇介绍如何使用Flask搭建一个流媒体服务器的文章，思路很新颖也很有意思。你可以点击&lt;a href="http://blog.miguelgrinberg.com/post/video-streaming-with-flask"&gt;这里&lt;/a&gt;阅读英文原文。或者跟随本文跟我一起体验一把搭建一个流媒体服务器的过程吧。&lt;/p&gt;
&lt;h2 id="_2"&gt;理论基础&lt;/h2&gt;
&lt;p&gt;流媒体有两大特点，一是数据量大。二是有实时性要求。针对这两个特点，我们必须把应答数据分块传输给客户端来实现流媒体服务器。这里我们用到了两个关键技术来实现流媒体服务器，我们使用生成器函数来把数据分块传送，Flask的&lt;code&gt;Response&lt;/code&gt;类本身对生成器函数有良好的支持。接着，我们使用&lt;strong&gt;Multipart&lt;/strong&gt;来组装一个HTTP应答。&lt;/p&gt;
&lt;h3 id="_3"&gt;生成器函数&lt;/h3&gt;
&lt;p&gt;生成器函数是可被打断和恢复的函数。其关键字是&lt;code&gt;yield&lt;/code&gt;，来看一个例子：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;gen&lt;/span&gt;():
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;yield&lt;/span&gt; &lt;span style="color: #666666"&gt;1&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;yield&lt;/span&gt; &lt;span style="color: #666666"&gt;2&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;yield&lt;/span&gt; &lt;span style="color: #666666"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的代码我们就定义了一个生成器函数，当生成器函数被调用时，它返回一个生成器迭代器，或直接叫生成器。通过不断地调用生成器的&lt;code&gt;next()&lt;/code&gt;方法来执行生成器函数体的代码，直到遇到异常为止。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #666666"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; g &lt;span style="color: #666666"&gt;=&lt;/span&gt; gen()
&lt;span style="color: #666666"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; g
&lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;generator &lt;span style="color: #AA22FF"&gt;object&lt;/span&gt; gen at &lt;span style="color: #666666"&gt;0xb72330a4&amp;gt;&lt;/span&gt;
&lt;span style="color: #666666"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; g&lt;span style="color: #666666"&gt;.&lt;/span&gt;next()
&lt;span style="color: #666666"&gt;1&lt;/span&gt;
&lt;span style="color: #666666"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; g&lt;span style="color: #666666"&gt;.&lt;/span&gt;next()
&lt;span style="color: #666666"&gt;2&lt;/span&gt;
&lt;span style="color: #666666"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; g&lt;span style="color: #666666"&gt;.&lt;/span&gt;next()
&lt;span style="color: #666666"&gt;3&lt;/span&gt;
&lt;span style="color: #666666"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; g&lt;span style="color: #666666"&gt;.&lt;/span&gt;next()
Traceback (most recent call last):
  File &lt;span style="color: #BB4444"&gt;&amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;&lt;/span&gt;, line &lt;span style="color: #666666"&gt;1&lt;/span&gt;, &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;module&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;
&lt;span style="color: #D2413A; font-weight: bold"&gt;StopIteration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上面的例子可以看到一个生成器函数可以返回多个结果。每当程序执行到&lt;code&gt;yield&lt;/code&gt;语句时，函数现场会被保留，同时返回一个值。Flask就是利用这个特性把应答数据通过生成器分块发送给客户端。&lt;/p&gt;
&lt;h3 id="multipart"&gt;Multipart应答&lt;/h3&gt;
&lt;p&gt;Multipart应答包含一个&lt;em&gt;multipart&lt;/em&gt;媒体类型，后面跟着多块独立的数据，每块数据有自己的&lt;em&gt;Content-Type&lt;/em&gt;，每块数据之间通过&lt;em&gt;boundary&lt;/em&gt;分隔。下面是一个例子：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;HTTP/1.1 200 OK
Content-Type: multipart/x-mixed-replace; boundary=frame

--frame
Content-Type: image/jpeg

&amp;lt;jpeg data here&amp;gt;
--frame
Content-Type: image/jpeg

&amp;lt;jpeg data here&amp;gt;
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Multipart有多种不同的类型，针对流媒体，我们使用&lt;code&gt;multipart/x-mixed-replace&lt;/code&gt;。浏览器处理这种Multipart类型时，会使用当前的块数据替换之前的块数据。这刚好就是我们想要的流媒体的效果。我们可以把媒体的一帧数据打包为一个数据块，每块数据有自己的&lt;em&gt;Content-Type&lt;/em&gt;和可选的&lt;em&gt;Content-Length&lt;/em&gt;。浏览器逐帧替换，就实现了视频的播放功能。&lt;a href="http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html"&gt;RFC1341&lt;/a&gt;对Multipart媒体类型进行了详细的描述，有兴趣的朋友可移步参考。&lt;/p&gt;
&lt;h2 id="_4"&gt;实现流媒体服务器&lt;/h2&gt;
&lt;p&gt;上面介绍了实现流媒体服务器的理论知识。接下来我们使用这些知识来用Flask搭建一个流媒体服务器。&lt;/p&gt;
&lt;p&gt;有多种方法可以在浏览器里实现流媒体播放，和Flask配合较好的是使用&lt;a href="http://baike.baidu.com/view/4875263.htm"&gt;Motion JPEG&lt;/a&gt;的方法。简单地讲，就是把视频画面通过JPEG图片的方式，一帧一帧地发送给浏览器。这也是很多IP Camera使用的流媒体播放方式，它实时性很好，但视频效果不是很理想。因为Motion JPEG对视频的压缩效率太低了。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;flask&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; Flask, render_template, Response
&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;camera&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; Camera

app &lt;span style="color: #666666"&gt;=&lt;/span&gt; Flask(__name__)

&lt;span style="color: #AA22FF"&gt;@app.route&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;index&lt;/span&gt;():
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; render_template(&lt;span style="color: #BB4444"&gt;&amp;#39;index.html&amp;#39;&lt;/span&gt;)

&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;gen&lt;/span&gt;(camera):
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;while&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;:
        frame &lt;span style="color: #666666"&gt;=&lt;/span&gt; camera&lt;span style="color: #666666"&gt;.&lt;/span&gt;get_frame()
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;yield&lt;/span&gt; (b&lt;span style="color: #BB4444"&gt;&amp;#39;--frame&lt;/span&gt;&lt;span style="color: #BB6622; font-weight: bold"&gt;\r\n&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;&lt;/span&gt;
               b&lt;span style="color: #BB4444"&gt;&amp;#39;Content-Type: image/jpeg&lt;/span&gt;&lt;span style="color: #BB6622; font-weight: bold"&gt;\r\n\r\n&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;&lt;/span&gt; &lt;span style="color: #666666"&gt;+&lt;/span&gt; frame &lt;span style="color: #666666"&gt;+&lt;/span&gt; b&lt;span style="color: #BB4444"&gt;&amp;#39;&lt;/span&gt;&lt;span style="color: #BB6622; font-weight: bold"&gt;\r\n&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;&lt;/span&gt;)

&lt;span style="color: #AA22FF"&gt;@app.route&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;#39;/video_feed&amp;#39;&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;video_feed&lt;/span&gt;():
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; Response(gen(Camera()),
                    mimetype&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;multipart/x-mixed-replace; boundary=frame&amp;#39;&lt;/span&gt;)

&lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; __name__ &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
    app&lt;span style="color: #666666"&gt;.&lt;/span&gt;run(host&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;0.0.0.0&amp;#39;&lt;/span&gt;, debug&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这个Flask应用程序导入了一个&lt;code&gt;Camera&lt;/code&gt;类，这个类是为了持续不断地提供视频的帧数据的类。这个程序提供了两个服务路径，&lt;code&gt;/&lt;/code&gt;路径由&lt;code&gt;index.html&lt;/code&gt;模板提供服务，下面是它的内容：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Video Streaming Demonstration&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Video Streaming Demonstration&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;img&lt;/span&gt; &lt;span style="color: #BB4444"&gt;src=&amp;quot;{{ url_for(&amp;#39;video_feed&amp;#39;) }}&amp;quot;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;
  &lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000; font-weight: bold"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是一个非常简单的HTML网页。其中关键的是&lt;code&gt;img&lt;/code&gt;这个标签，它定义了一张图片元素，其URL是&lt;code&gt;/video_feed&lt;/code&gt;。从Flask应用程序代码的Line17-20可以知道，&lt;code&gt;/video_feed&lt;/code&gt;是由一个&lt;code&gt;video_feed()&lt;/code&gt;方法提供服务的，它返回的是一个multipart应答。这个应答的内容是由生成器函数&lt;code&gt;gen()&lt;/code&gt;提供的。而&lt;code&gt;gen()&lt;/code&gt;函数就是不停地从camera里获取一帧一帧的图片，并通过生成器返回给客户端。客户端浏览器在收到这个流媒体时，会在&lt;code&gt;img&lt;/code&gt;标签定义的图片里，逐帧地显示图片，这样一个视频就播放出来的。目前市面上绝大部分浏览器都支持这个功能。&lt;/p&gt;
&lt;h2 id="_5"&gt;模拟视频帧数据&lt;/h2&gt;
&lt;p&gt;现在只要实现&lt;code&gt;Camera&lt;/code&gt;类，并提供源源不断的视频帧数据即可运行上面的程序了。由于连接摄像头涉及到硬件，我们使用一个简单的模拟器来源源不断地返回数据：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;time&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; time

&lt;span style="color: #AA22FF; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;Camera&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;object&lt;/span&gt;):
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;__init__&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;):
        &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;frames &lt;span style="color: #666666"&gt;=&lt;/span&gt; [&lt;span style="color: #AA22FF"&gt;open&lt;/span&gt;(f &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;.jpg&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;)&lt;span style="color: #666666"&gt;.&lt;/span&gt;read() &lt;span style="color: #AA22FF; font-weight: bold"&gt;for&lt;/span&gt; f &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; [&lt;span style="color: #BB4444"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;]]

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;get_frame&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;):
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;frames[&lt;span style="color: #AA22FF"&gt;int&lt;/span&gt;(time()) &lt;span style="color: #666666"&gt;%&lt;/span&gt; &lt;span style="color: #666666"&gt;3&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;这个代码很简单，它从本地读取三个图片，并根据当前时间，每秒返回不同的图片来模拟提供源源不断的视频帧数据。&lt;/p&gt;
&lt;p&gt;大家可以从原作者的GitHub上下载程序的代码来运行。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;git clone https://github.com/miguelgrinberg/flask-video-streaming.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者直接下载&lt;a href="https://github.com/miguelgrinberg/flask-video-streaming/archive/master.zip"&gt;ZIP&lt;/a&gt;包来运行。&lt;/p&gt;
&lt;p&gt;下载完代码，进入代码根目录，执行&lt;code&gt;python app.py&lt;/code&gt;。然后在浏览器里打开&lt;code&gt;http://localhost:5000&lt;/code&gt;即可以看到模拟的视频了。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;安装Flask&lt;/p&gt;
&lt;p&gt;要运行上述代码，需要先安装Flask。&lt;a href="http://flask.pocoo.org/"&gt;官网&lt;/a&gt;上有教程，简单易懂。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="_6"&gt;连接硬件摄像头&lt;/h2&gt;
&lt;p&gt;下载代码的同学应该可以看到代码里还有一个&lt;code&gt;camera_pi.py&lt;/code&gt;的文件，这个是用来实现真正的连接硬件摄像头的代码。原文作者使用的摄像头是&lt;a href="http://baike.baidu.com/view/5730914.htm"&gt;Raspberry Pi&lt;/a&gt;，这是个类似Arduino的开源的硬件项目。&lt;/p&gt;
&lt;h2 id="_7"&gt;一些限制&lt;/h2&gt;
&lt;p&gt;当客户端浏览器打开上述流媒体服务的网址时，它就独占了这个线程。在把Flask应用Deploy到Nginx+uwsgi服务器上时，它能服务的最大客户端数目为应用程序的线程数，一般就是几个到几十个。而如果是在本机使用&lt;code&gt;python app.py&lt;/code&gt;运行的测试服务器，则只能服务一个客户端。&lt;/p&gt;
&lt;p&gt;针对这个问题，原文作者提供了一个解决方案。使用&lt;a href="http://www.gevent.org/"&gt;gevent&lt;/a&gt;来解决。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev event loop.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有兴趣的同学可以在原代码的基础上，引入gevent来支持多客户端。&lt;/p&gt;</summary><category term="python"></category><category term="flask"></category></entry><entry><title>使用Pelican搭建博客系统</title><link href="http://blog.kamidox.com/build-blog-system-by-pelican.html" rel="alternate"></link><updated>2014-10-26T23:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-10-26:build-blog-system-by-pelican.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;摘要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pelican"&gt;Pelican介绍&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pelican_1"&gt;什么是Pelican&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pelican_2"&gt;为什么选择Pelican&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#pelican_3"&gt;Pelican安装与配置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pelican_4"&gt;安装Pelican并创建项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pelicanconfpypublishconfpy"&gt;配置pelicanconf.py和publishconf.py&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#makefile"&gt;配置Makefile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;配置主题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;异常&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;撰写博客&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_5"&gt;撰写博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;预览博客文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;发布博客&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#nginx"&gt;配置Nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;上传博客到服务器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_9"&gt;最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;摘要&lt;/h2&gt;
&lt;p&gt;经过几天的折腾，用Pelican搭建的独立博客系统终于上线运行了。可以打开&lt;a href="http://blog.kamidox.com"&gt;kamidox.com&lt;/a&gt;看一下效果图。由于选用了响应式网页设计的主题，所以在手机上的浏览效果也相当赞。本文介绍了Pelican的特性；选择Pelican的理由以及从头安装配置，搭建出一个可运行的独立博客系统。最后给出我自己的最佳实践描述。&lt;/p&gt;
&lt;h2 id="pelican"&gt;Pelican介绍&lt;/h2&gt;
&lt;h3 id="pelican_1"&gt;什么是Pelican&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/getpelican/pelican"&gt;Perlican&lt;/a&gt;是用Python实现的一个静态网站生成器，支持&lt;a href="http://docutils.sourceforge.net/rst.html"&gt;reStructuredText&lt;/a&gt;或&lt;a href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt;。它支持以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;博客文章和静态网页&lt;/li&gt;
&lt;li&gt;支持评论。评论是通过第三方服务&lt;a href="https://disqus.com/"&gt;Disqus&lt;/a&gt;支持的。即评论数据保存在第三方服务器上&lt;/li&gt;
&lt;li&gt;主题支持&lt;/li&gt;
&lt;li&gt;把博客文章生成PDF格式文档&lt;/li&gt;
&lt;li&gt;多语言博客支持，如可以用英文和中文写同一篇博客。不同语言访问者访问相应语言的博文&lt;/li&gt;
&lt;li&gt;支持Atom/RSS订阅&lt;/li&gt;
&lt;li&gt;博文中代码高亮支持&lt;/li&gt;
&lt;li&gt;博客搬家支持(WordPress, Dotclear, 或RSS feeds)&lt;/li&gt;
&lt;li&gt;支持插件，如Twiter, Google Analytics等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="pelican_2"&gt;为什么选择Pelican&lt;/h3&gt;
&lt;p&gt;首先排除掉WordPress之类的CMS系统。因为我不想要数据库，我只需要一个轻量级的静态网站生成器。我的博客使用Markdown编写，且保存在GitHub上。我想要的，只是用Markdown写完博客之后，git commit + git push即可直接发布到博客网站上。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.iwantmyname.com/2014/05/the-updated-big-list-of-static-website-generators-for-your-site-blog-or-wiki.html"&gt;这篇文章&lt;/a&gt;介绍了32个各种语言实现的博客引擎，而&lt;a href="http://siliconangle.com/blog/2012/03/20/5-minimalist-static-html-blog-generators-to-check-out/"&gt;这篇文章&lt;/a&gt;介绍了５个最轻量级的静态网站生成器。最终选择Pelican是基于如下原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Python实现。由于最近在学习Python，我可以阅读源码并按照我的需求来改造Pelican使之完全符合我的需求。下次学习Ruby，用&lt;a href="https://github.com/jekyll/jekyll"&gt;jekyll&lt;/a&gt;再折腾一遍。因为Jekyll是用Ruby实现的。且GitHub Pages的后台就是用Jekyll，到时可直接用GitHub Pages实现个人博客。&lt;/li&gt;
&lt;li&gt;足够轻量级。总的代码量才1MB多。安装也方便。&lt;/li&gt;
&lt;li&gt;有一堆现成的主题可以使用。这对我这种非专业前端的开发者来说，省了不少事。&lt;/li&gt;
&lt;li&gt;文档齐全。&lt;/li&gt;
&lt;li&gt;开发活动活跃。GitHub上代码提交活跃。上面文章里介绍的很多博客系统基本上都2+年前就停止更新了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后两点对使用任何开源工具来说都是很重要的，只有开发活跃，社区资源多，文档齐全，遇到问题的时候才能较快地得到解决。&lt;/p&gt;
&lt;h2 id="pelican_3"&gt;Pelican安装与配置&lt;/h2&gt;
&lt;h3 id="pelican_4"&gt;安装Pelican并创建项目&lt;/h3&gt;
&lt;p&gt;详细的信息可以参阅&lt;a href="http://docs.getpelican.com/en/3.4.0/"&gt;Pelican官方文档&lt;/a&gt;。假设电脑上已经安装Python和pip。首先，通过pip安装pelican和markdown：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;pip install pelican markdown
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后创建你的博客项目：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;mkdir ~/blogs
&lt;span style="color: #AA22FF"&gt;cd&lt;/span&gt; ~/blogs
pelican-quickstart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在运行pelican-quickstart时，系统会问一系列问题，比如你的博客网址啊，作者名字啊之类的，根据真实情况填写即可，这些问题只是用来生成配置文件的，我们后面都可以通过修改配置文件来手动修改这些设置。我填写的内容如下：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;kamidox@kamidox-laptop:~/lab/blogs&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;pelican-quickstart
Welcome to pelican-quickstart v3.4.0.

This script will &lt;span style="color: #AA22FF"&gt;help &lt;/span&gt;you create a new Pelican-based website.

Please answer the following questions so this script can generate the files
needed by Pelican.

&amp;gt; Where &lt;span style="color: #AA22FF; font-weight: bold"&gt;do&lt;/span&gt; you want to create your new web site? &lt;span style="color: #666666"&gt;[&lt;/span&gt;.&lt;span style="color: #666666"&gt;]&lt;/span&gt;
&amp;gt; What will be the title of this web site? kamidox
&amp;gt; Who will be the author of this web site? Joey Huang
&amp;gt; What will be the default language of this web site? &lt;span style="color: #666666"&gt;[&lt;/span&gt;en&lt;span style="color: #666666"&gt;]&lt;/span&gt;
&amp;gt; Do you want to specify a URL prefix? e.g., http://example.com   &lt;span style="color: #666666"&gt;(&lt;/span&gt;Y/n&lt;span style="color: #666666"&gt;)&lt;/span&gt;
&amp;gt; What is your URL prefix? &lt;span style="color: #666666"&gt;(&lt;/span&gt;see above example; no trailing slash&lt;span style="color: #666666"&gt;)&lt;/span&gt; http://kamidox.com
&amp;gt; Do you want to &lt;span style="color: #AA22FF"&gt;enable &lt;/span&gt;article pagination? &lt;span style="color: #666666"&gt;(&lt;/span&gt;Y/n&lt;span style="color: #666666"&gt;)&lt;/span&gt; Y
&amp;gt; How many articles per page &lt;span style="color: #AA22FF; font-weight: bold"&gt;do&lt;/span&gt; you want? &lt;span style="color: #666666"&gt;[&lt;/span&gt;10&lt;span style="color: #666666"&gt;]&lt;/span&gt;
&amp;gt; Do you want to generate a Fabfile/Makefile to automate generation and publishing? &lt;span style="color: #666666"&gt;(&lt;/span&gt;Y/n&lt;span style="color: #666666"&gt;)&lt;/span&gt; Y
&amp;gt; Do you want an auto-reload &amp;amp; simpleHTTP script to assist with theme and site development? &lt;span style="color: #666666"&gt;(&lt;/span&gt;Y/n&lt;span style="color: #666666"&gt;)&lt;/span&gt;
&amp;gt; Do you want to upload your website using FTP? &lt;span style="color: #666666"&gt;(&lt;/span&gt;y/N&lt;span style="color: #666666"&gt;)&lt;/span&gt; N
&amp;gt; Do you want to upload your website using SSH? &lt;span style="color: #666666"&gt;(&lt;/span&gt;y/N&lt;span style="color: #666666"&gt;)&lt;/span&gt; y
&amp;gt; What is the hostname of your SSH server? &lt;span style="color: #666666"&gt;[&lt;/span&gt;localhost&lt;span style="color: #666666"&gt;]&lt;/span&gt; kamidox.com
&amp;gt; What is the port of your SSH server? &lt;span style="color: #666666"&gt;[&lt;/span&gt;22&lt;span style="color: #666666"&gt;]&lt;/span&gt;
&amp;gt; What is your username on that server? &lt;span style="color: #666666"&gt;[&lt;/span&gt;root&lt;span style="color: #666666"&gt;]&lt;/span&gt; ubuntu
&amp;gt; Where &lt;span style="color: #AA22FF; font-weight: bold"&gt;do&lt;/span&gt; you want to put your web site on that server? &lt;span style="color: #666666"&gt;[&lt;/span&gt;/var/www&lt;span style="color: #666666"&gt;]&lt;/span&gt; /home/ubuntu/blogs
&amp;gt; Do you want to upload your website using Dropbox? &lt;span style="color: #666666"&gt;(&lt;/span&gt;y/N&lt;span style="color: #666666"&gt;)&lt;/span&gt; N
&amp;gt; Do you want to upload your website using S3? &lt;span style="color: #666666"&gt;(&lt;/span&gt;y/N&lt;span style="color: #666666"&gt;)&lt;/span&gt; N
&amp;gt; Do you want to upload your website using Rackspace Cloud Files? &lt;span style="color: #666666"&gt;(&lt;/span&gt;y/N&lt;span style="color: #666666"&gt;)&lt;/span&gt; N
&amp;gt; Do you want to upload your website using GitHub Pages? &lt;span style="color: #666666"&gt;(&lt;/span&gt;y/N&lt;span style="color: #666666"&gt;)&lt;/span&gt; N
Done. Your new project is available at /home/kamidox/lab/blogs
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;其中第14行的&lt;code&gt;http://kamidox.com&lt;/code&gt;以及第21行的&lt;code&gt;kamidox.com&lt;/code&gt;是我的域名，如果你只是在本机试验，可以填localhost。创建完项目后，目录下看起来象这样。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;kamidox@kamidox-laptop:~/lab/blogs&lt;span style="color: #B8860B"&gt;$ &lt;/span&gt;tree
.
├── content     &lt;span style="color: #008800; font-style: italic"&gt;# 这个就是放博客内容目录，这个目录及子目录下的所有md和rst文件将会被转成html文件&lt;/span&gt;
├── develop_server.sh   &lt;span style="color: #008800; font-style: italic"&gt;#这个是用来在本地运行一个服务器来实时查看生成的html文档的脚本&lt;/span&gt;
├── fabfile.py  &lt;span style="color: #008800; font-style: italic"&gt;# 这个是使用Python的fabric来实现文件上传的工具，即Deploy工具&lt;/span&gt;
├── Makefile    &lt;span style="color: #008800; font-style: italic"&gt;# 这个是使用是用来生成网站内容并上传的工具。后文详细解释&lt;/span&gt;
├── output      &lt;span style="color: #008800; font-style: italic"&gt;# 这个是从content目录生成的html目标文件的存放目录&lt;/span&gt;
├── pelicanconf.py      &lt;span style="color: #008800; font-style: italic"&gt;# 这个是本地开发时的配置文件&lt;/span&gt;
└── publishconf.py      &lt;span style="color: #008800; font-style: italic"&gt;# 这个是发布时的配置文件&lt;/span&gt;

&lt;span style="color: #666666"&gt;2&lt;/span&gt; directories, &lt;span style="color: #666666"&gt;5&lt;/span&gt; files
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="pelicanconfpypublishconfpy"&gt;配置pelicanconf.py和publishconf.py&lt;/h3&gt;
&lt;p&gt;Pelican的配置文件是直接用Python写的，我本地开发配置文件&lt;code&gt;pelicanconf.py&lt;/code&gt;内容如下：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# -*- coding: utf-8 -*- #&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;__future__&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; unicode_literals

AUTHOR &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;u&amp;#39;Joey Huang&amp;#39;&lt;/span&gt;
SITENAME &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;u&amp;quot;kamidox.com&amp;quot;&lt;/span&gt;
SITEURL &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;http://localhost&amp;#39;&lt;/span&gt;
DISQUS_SITENAME &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;kamidox&amp;#39;&lt;/span&gt;

PATH &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;content&amp;#39;&lt;/span&gt;

TIMEZONE &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;Asia/Shanghai&amp;#39;&lt;/span&gt;

DEFAULT_LANG &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;u&amp;#39;zh_CN&amp;#39;&lt;/span&gt;
DEFAULT_DATE_FORMAT &lt;span style="color: #666666"&gt;=&lt;/span&gt; (&lt;span style="color: #BB4444"&gt;&amp;#39;%Y-%m-&lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%d&lt;/span&gt;&lt;span style="color: #BB4444"&gt;(%A) %H:%M&amp;#39;&lt;/span&gt;)

USE_FOLDER_AS_CATEGORY &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;
DEFAULT_CATEGORY &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;hide&amp;#39;&lt;/span&gt;

&lt;span style="color: #008800; font-style: italic"&gt;# Feed generation is usually not desired when developing&lt;/span&gt;
FEED_ATOM &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;feeds/atom.xml&amp;#39;&lt;/span&gt;
FEED_RSS &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;feeds/rss.xml&amp;#39;&lt;/span&gt;
FEED_ALL_ATOM &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;
FEED_ALL_RSS &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;
CATEGORY_FEED_ATOM &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;
TRANSLATION_FEED_ATOM &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;

&lt;span style="color: #008800; font-style: italic"&gt;# menu items&lt;/span&gt;
MENUITEMS &lt;span style="color: #666666"&gt;=&lt;/span&gt; [(&lt;span style="color: #BB4444"&gt;&amp;#39;Home&amp;#39;&lt;/span&gt;, SITEURL),
            (&lt;span style="color: #BB4444"&gt;&amp;#39;About&amp;#39;&lt;/span&gt;, &lt;span style="color: #BB4444"&gt;&amp;#39;about.html&amp;#39;&lt;/span&gt;),]

DEFAULT_PAGINATION &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #666666"&gt;10&lt;/span&gt;
MD_EXTENSIONS &lt;span style="color: #666666"&gt;=&lt;/span&gt; [
        &lt;span style="color: #BB4444"&gt;&amp;quot;extra&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #BB4444"&gt;&amp;quot;toc&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #BB4444"&gt;&amp;quot;headerid&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #BB4444"&gt;&amp;quot;meta&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #BB4444"&gt;&amp;quot;sane_lists&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #BB4444"&gt;&amp;quot;smarty&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #BB4444"&gt;&amp;quot;wikilinks&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #BB4444"&gt;&amp;quot;admonition&amp;quot;&lt;/span&gt;,
        &lt;span style="color: #BB4444"&gt;&amp;quot;codehilite(guess_lang=False,pygments_style=emacs,noclasses=True)&amp;quot;&lt;/span&gt;]

CNZZ_ANALYTICS &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;
MONTH_ARCHIVE_SAVE_AS &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;posts/{date:%Y}/{date:%m}/index.html&amp;#39;&lt;/span&gt;
THEME &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;themes/foundation-default-colours&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
&lt;li&gt;第6行的SITENAME是博客网站的名称，可以是任何字符；第7行是博客网站的网址，这个字段在本地开发和发布版本是不一样的，本地直接填localhost即可，发布版本里需要填博客网址。&lt;/li&gt;
&lt;li&gt;第8行：我使用了Disqus作为我的评论系统，Disqus也是&lt;a href="https://www.ycombinator.com/"&gt;YC&lt;/a&gt;毕业生。启用Disqus评论系统非常简单，在官网上注册一个Disqus帐户，然后把帐户名填在&lt;code&gt;DISQUS_SITENAME&lt;/code&gt;值里即可启用。我的Disqus帐号刚好也是&lt;code&gt;kamidox&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第33－42行：这里是配置Markdown扩展，用来支持代码高亮。并且使用Emacs风格的代码高亮。&lt;/li&gt;
&lt;li&gt;第44行：由于GFW的存在，我把Google Analize换成了国内的CNZZ统计。&lt;/li&gt;
&lt;li&gt;第46行：我的博客使用了&lt;code&gt;foundation-default-colours&lt;/code&gt;这套主题。关于主题，后文详解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开发环境和发布环境的配置差不多，除SITEURL不一样外，还多了两个配置：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;SITEURL &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;http://kamidox.com&amp;#39;&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# usful setting for publish&lt;/span&gt;
RELATIVE_URLS &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;False&lt;/span&gt;   &lt;span style="color: #008800; font-style: italic"&gt;# 禁用相对路径引用&lt;/span&gt;
DELETE_OUTPUT_DIRECTORY &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;True&lt;/span&gt;      &lt;span style="color: #008800; font-style: italic"&gt;# 编译之前删除output目录，这样保证output下生成的内容是干净的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其它的配置项，可以参阅&lt;a href="http://docs.getpelican.com/en/3.4.0/settings.html"&gt;Pelican设置文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="makefile"&gt;配置Makefile&lt;/h3&gt;
&lt;p&gt;撰写完博客，并在本地预览后，需要发布到服务器上。我使用Makefile的形式来生成文档并发布。我的Makefile核心代码如下：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;#!/makefile&lt;/span&gt;
&lt;span style="color: #B8860B"&gt;SSH_HOST&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;kamidox.com
&lt;span style="color: #B8860B"&gt;SSH_PORT&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;22
&lt;span style="color: #B8860B"&gt;SSH_USER&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;ubuntu
&lt;span style="color: #B8860B"&gt;SSH_TARGET_DIR&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;/home/ubuntu/blogs/
&lt;span style="color: #B8860B"&gt;SSH_KEY&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;/home/kamidox/work/aws/kamidox-key-tokyo.pem

&lt;span style="color: #00A000"&gt;rsync_upload&lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt; publish
    rsync -e &lt;span style="color: #BB4444"&gt;&amp;quot;ssh -p &lt;/span&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;SSH_PORT&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;&lt;span style="color: #BB4444"&gt; -i &lt;/span&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;SSH_KEY&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;&lt;/span&gt; -P -rvzc --delete &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;OUTPUTDIR&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;/ &lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;SSH_USER&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;@&lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;SSH_HOST&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt;:&lt;span style="color: #AA22FF; font-weight: bold"&gt;$(&lt;/span&gt;SSH_TARGET_DIR&lt;span style="color: #AA22FF; font-weight: bold"&gt;)&lt;/span&gt; --cvs-exclude
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
&lt;li&gt;第2－4行：指定了要上传内容的目的服务器的地址，端口以及用户名&lt;/li&gt;
&lt;li&gt;第5行：指定了远程服务器上保存博客内容的目录&lt;/li&gt;
&lt;li&gt;第6行：我添加的SSH Identity文件路径。这是因为Amazon EC2登录时我是用SSH Identity文件登录的，而不是使用用户名和密码&lt;/li&gt;
&lt;li&gt;第8-9行：我使用rsync来进行上传操作。rsync可以在本地和远程服务器之间同步文件。同步过程中只同步那些改变了的文件，且传输过程中会压缩数据，它比scp要所需要的带宽要小。这里要注意的是，我在默认生成的Makefile上增加了&lt;code&gt;-i $(SSH_KEY)&lt;/code&gt;，这个就是指定SSH Identity文件登录远程SSH的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="_2"&gt;配置主题&lt;/h3&gt;
&lt;p&gt;Pelican支持大量的开源主题，GitHub上的&lt;a href="https://github.com/getpelican/pelican-themes"&gt;pelican-themes&lt;/a&gt;项目有几十套主题，大部分都带了效果预览图。可以从里面挑一个你喜欢的主题样式来使用。还有一个更方便的挑选主题的方式，直接打开&lt;a href="http://www.pelicanthemes.com/"&gt;www.pelicanthemes.com&lt;/a&gt;挑选吧。一个网页里就列出了几乎所有的主题。我的博客是使用&lt;code&gt;foundation-default-colours&lt;/code&gt;主题，并在这套主题的基础上进行了一些定制。选定好喜欢的主题后，从GitHub上下载下来所有的主题：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;mkdir ~/pelican
&lt;span style="color: #AA22FF"&gt;cd&lt;/span&gt; ~/pelican
git clone https://github.com/getpelican/pelican-themes.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从里面拷贝一份你选中的主题到项目根目录的&lt;code&gt;themes&lt;/code&gt;目录下，在本文的例子中是&lt;code&gt;~/lab/blogs/themes&lt;/code&gt;。然后在&lt;code&gt;pelicanconf.py&lt;/code&gt;和&lt;code&gt;publishconf.py&lt;/code&gt;里通过下面代码指定博客主题：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;THEME &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;themes/foundation-default-colours&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通常的做法是，选中一个自己喜欢的主题后，会进行一些定制。Pelican使用&lt;a href="http://jinja.pocoo.org/"&gt;Jinja2&lt;/a&gt;来配置主题。一个主题的典型结构如下：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;├── static
│   ├── css
│   └── images
└── templates
    ├── analytics_cnzz.html // 这个是我添加的使用cnzz的统计服务的代码
    ├── analytics.html      // 这是Google Analytics的代码
    ├── archives.html       // 这个是博客归档页面的模板
    ├── article.html        // 这个是博客正文的显示模板
    ├── base.html           //　这个是所有页面的父类模板，即所有页面都引用这个页面。比如网页导航栏啊之类的，都定义在这里
    ├── categories.html     //　所有博客文章的分类列表
    ├── category.html       // 某个博客分类的文章列表模板
    ├── index.html          // 主页
    ├── page.html           // 分页显示的模板
    ├── tag.html            // 某类标签下的文章列表
    └── tags.html           // 所有的标签列表页面模板
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;稍微有点Jinja的知识加上一些HTML和CSS的知识，就可以自己定义主题了。&lt;/p&gt;
&lt;h3 id="_3"&gt;异常&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为什么博客主页打开半天都不显示出来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为GFW封锁了几乎所有和Google相关的网站，这些主题里又用了Google的字体，所以下载这些字体时会导致无法下载成功而半天不显示网页。解决方案很简单，直接修改css文件，不去下载Google字体即可。比如针对&lt;code&gt;foundation-default-colours&lt;/code&gt;主题，打开主题根目录下的&lt;code&gt;static/css/foundation.css&lt;/code&gt;和&lt;code&gt;static/css/foundation.min.css&lt;/code&gt;文件，删除掉&lt;code&gt;@import url("//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,700");&lt;/code&gt;内容即可。当然，如果你和你的读者都是翻墙高手，那就不会遇到这个问题了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;No module named html_parser&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行 pelican 命令可能出现下面的错误：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    Traceback (most recent call last):
  File &lt;span style="color: #BB4444"&gt;&amp;quot;/usr/local/bin/pelican&amp;quot;&lt;/span&gt;, line &lt;span style="color: #666666"&gt;7&lt;/span&gt;, &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;module&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;pelican&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; main
  File &lt;span style="color: #BB4444"&gt;&amp;quot;/Library/Python/2.7/site-packages/pelican/__init__.py&amp;quot;&lt;/span&gt;, line &lt;span style="color: #666666"&gt;20&lt;/span&gt;, &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;module&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;pelican.generators&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; (ArticlesGenerator, PagesGenerator,
  File &lt;span style="color: #BB4444"&gt;&amp;quot;/Library/Python/2.7/site-packages/pelican/generators.py&amp;quot;&lt;/span&gt;, line &lt;span style="color: #666666"&gt;22&lt;/span&gt;, &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;module&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;pelican.readers&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; Readers
  File &lt;span style="color: #BB4444"&gt;&amp;quot;/Library/Python/2.7/site-packages/pelican/readers.py&amp;quot;&lt;/span&gt;, line &lt;span style="color: #666666"&gt;24&lt;/span&gt;, &lt;span style="color: #AA22FF; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #666666"&gt;&amp;lt;&lt;/span&gt;module&lt;span style="color: #666666"&gt;&amp;gt;&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;six.moves.html_parser&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; HTMLParser
&lt;span style="color: #D2413A; font-weight: bold"&gt;ImportError&lt;/span&gt;: No module named html_parser
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种情况是由于 &lt;code&gt;six&lt;/code&gt; 模块的 bug 引起的。可以修改 pelican 安装目录下的 &lt;code&gt;/Library/Python/2.7/site-packages/pelican/readers.py&lt;/code&gt; 文件。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;# from six.moves.html_parser import HTMLParser&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;HTMLParser&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; HTMLParser       &lt;span style="color: #008800; font-style: italic"&gt;# 如果你在 Python 2.7 版本下运行，可直接按照这个方式修改&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_4"&gt;撰写博客&lt;/h2&gt;
&lt;h3 id="_5"&gt;撰写博客&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;content&lt;/code&gt;目录下新建一个xxx.md，使用Makedown语法直接撰写文档即可。我在ubuntu下使用的是gedit，代码高亮效果很好。撰写博客的时候需要注意，Pelican支持一些元数据。比如，本文的元数据如下：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Title: 使用Pelican搭建博客系统
Date: 2014-10-07 22:20
Modified: 2014-10-07 23:04
Tags: python, pelican
Slug: build-blog-system-by-pelican
Authors: Joey Huang
Summary: 本文介绍了Pelican的特性；选择Pelican的理由以及从头安装配置，搭建出一个可运行的独立博客系统。
Status: draft
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
&lt;li&gt;第5行：Slug是文档的唯一标识，生成html时，会直接使用这个值当html的文件名。所以，不同博客文章这个值需要保证唯一性，否则生成html时会报错。&lt;/li&gt;
&lt;li&gt;第8行：这个表示本文是草稿。比如我们一篇博客经常不是一次性写完的，写了一半暂不想让读者看到，或者写完想让别人帮忙审查一下，就可以加这一行标识。这样Pelican在处理时，这篇文章也会生成html，但不会放在博客的主页及分类索引里，这样普通的读者一般看不到这个文章。有这个标识的文章生成时放在&lt;code&gt;output/drafts&lt;/code&gt;目录下，你就可以通过分享url的方式让你的co-worker帮你review你的文章。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以在&lt;code&gt;content&lt;/code&gt;目录下任意建子目录来组织管理博客文章。由于我们在设置文件里指定这个值&lt;code&gt;USE_FOLDER_AS_CATEGORY = True&lt;/code&gt;，这样这些目录名称就自动变成博文分类的目录了。&lt;/p&gt;
&lt;h3 id="_6"&gt;预览博客文章&lt;/h3&gt;
&lt;p&gt;撰写文章的过程中，可以随时在浏览器里预览博客文章。方法是先在博客项目的根目录下执行下面命令来启动预览服务器：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;make devserver
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这条命令会自动使用&lt;code&gt;pelicanconf.py&lt;/code&gt;的配置文件来生成html网页，同时在本地的8000端口上启动一个http服务器，供你预览文章。这样，直接打开浏览器，输入&lt;code&gt;localhost:8000&lt;/code&gt;即可打开本地服务器上的你的博客主页。比如，撰写本文时，我就直接在gedit里码字，然后在浏览器里输入&lt;code&gt;http://localhost:8000/drafts/build-blog-system-by-pelican.html&lt;/code&gt;来实时预览效果。需要注意的是，上述命令会在后台持续监听&lt;code&gt;content&lt;/code&gt;目录下的内容，如果这个目录下的内容发生变化，会自动重新生成html页面。所以，在gedit里写完一段内容，切换到浏览器，直接刷新一下就可以看到最新的结果了。&lt;/p&gt;
&lt;p&gt;当文章写完后，需要在博客项目根目录上运行&lt;code&gt;make stopserver&lt;/code&gt;来停止这个预览服务以及数据监控功能。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;文章在主页上没看到？&lt;/p&gt;
&lt;p&gt;撰写完文章，需要发布时，需要把&lt;code&gt;Status: draft&lt;/code&gt;这行元数据去掉。否则文章不会出现在博客主页。只会在drafts下看得到。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="_7"&gt;发布博客&lt;/h2&gt;
&lt;p&gt;写完博客，我们想发布到网上。这个时候我们就需要一个主机和一个域名，我的独立博客系统用到的下面资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Amazon EC2主机。一个帐户可以免费使用一年。可以点击&lt;a href="https://aws.amazon.com"&gt;这里&lt;/a&gt;注册。&lt;/li&gt;
&lt;li&gt;申请独立域名。我是通过&lt;a href="http://www.aliyun.com/"&gt;阿里云&lt;/a&gt;直接在&lt;a href="http://www.net.cn/"&gt;万网&lt;/a&gt;上注册的。一年45元。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我的博客运行的软件环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ubuntu 14.04 Server版，运行在Anazon EC2主机上&lt;/li&gt;
&lt;li&gt;Nginx&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="nginx"&gt;配置Nginx&lt;/h3&gt;
&lt;p&gt;Ubuntu下安装Nginx：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;sudo apt-get install nginx-full
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装完成后，编辑配置文件：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;sudo vim /etc/nginx/sites-enabled/default
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将配置文件替换成如下的内容：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;server {
  listen 80 default_server;
  server_name localhost;
  root /home/kamidox/lab/blogs/output;

  location / {
    index index.html;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
&lt;li&gt;第3行：这个是服务器地址。这里使用本机作为测试服务器就填localhost，如果是配置服务器，就要填服务器的域名。比如我的服务器上，这行是配置成kamidox.com。&lt;/li&gt;
&lt;li&gt;第4行：这个设置成博客文章的根目录。这个使用本机作为测试服务器，所以直接填博客项目的&lt;code&gt;output&lt;/code&gt;目录。如果是在服务器上，我是直接配置成&lt;code&gt;/home/ubuntu/blogs&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置完成后，重启一下Nginx服务：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;sudo service nginx resart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后在浏览器里输入&lt;code&gt;localhost&lt;/code&gt;就可以看到博客首页。在本机验证成功Nginx配置后，就可以用SSH登录服务器去配置服务器了。&lt;/p&gt;
&lt;h3 id="_8"&gt;上传博客到服务器&lt;/h3&gt;
&lt;p&gt;直接在项目根目录下运行下面的命令即可把文章上传到博客服务器:&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;make rsync_upload
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为我们在前文已经配置了Makefile文件。所以运行这个命令之后，就会使用 &lt;code&gt;publishconf.py&lt;/code&gt; 来生成html，并且通过rsync上传到服务器Amazon EC2服务器的 &lt;code&gt;/home/ubuntu/blogs/&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;div class="admonition hint"&gt;
&lt;p class="admonition-title"&gt;配置Amazon EC2主机&lt;/p&gt;
&lt;p&gt;发布博客到服务器上，需要先完成Amazon EC2主机的配置。具体可参阅&lt;a href="https://aws.amazon.com"&gt;Amazon官网上的文档&lt;/a&gt;。如果还没有主机，也可以把自己的电脑配置成服务器来作试验，所要做的，就是修改Makefile里的SSH_HOST的值为localhost即可。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="_9"&gt;最佳实践&lt;/h2&gt;
&lt;p&gt;我的博客内容托管在 GitHub 上。当我需要写一篇文章时，直接打开gedit/sublime开始用Markdown语法码字。想预览时，直接运行 &lt;code&gt;make devserver&lt;/code&gt;，然后在浏览器里输入文章的URL就可以直接查看了。如果文章写了一半，还不想发布，直接加一条元数据 &lt;code&gt;Status: draft&lt;/code&gt; 。然后 git commit + git push 提交到服务器。等到文章写完，想发布了，删除掉草稿标识；然后 git commit + git push 先提交到 GitHub 上；接着运行 &lt;code&gt;make rsync_upload&lt;/code&gt; 即可把博客内容上传到 Amazon EC2 主机上。打开 &lt;a href="http://blog.kamidox.com"&gt;blog.kamidox.com&lt;/a&gt; 确认一下即完成了一篇博文的发布。&lt;/p&gt;</summary><category term="python"></category><category term="pelican"></category></entry><entry><title>Python SocketServer</title><link href="http://blog.kamidox.com/python-stdlib-socketserver.html" rel="alternate"></link><updated>2014-10-05T20:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-10-05:python-stdlib-socketserver.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;摘要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#socketserver"&gt;SocketServer概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;网络服务种类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;网络服务处理请求的方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;创建网络服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;多线程并发的注意事项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;类和接口介绍&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#baseserver"&gt;BaseServer介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#requesthandler"&gt;RequestHandler介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;参考文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文介绍Python标准库SocketServer。SocketServer标准库简化了编写一个网络服务器的工作。阅读本文需要基本的网络编程知识以及线程和进程的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;code&gt;SocketServer&lt;/code&gt;在Python 3之后被重命名为&lt;code&gt;socketserver&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="socketserver"&gt;SocketServer概述&lt;/h2&gt;
&lt;h3 id="_2"&gt;网络服务种类&lt;/h3&gt;
&lt;p&gt;SocketServer包里最常用的两个基础服务类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TCPServer&lt;/code&gt;：提供TCP服务的网络服务可以从这个类继承&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UDPServer&lt;/code&gt;：提供UDP服务的网络服务可以从这个类继承&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外两个不常用，且只在类UNIX系统里可以使用的是&lt;code&gt;UnixStreamServer&lt;/code&gt;和&lt;code&gt;UnixDatagramServer&lt;/code&gt;，他们分别提供TCP和UDP的本地服务，一般用来实现进程间通信。&lt;/p&gt;
&lt;h3 id="_3"&gt;网络服务处理请求的方式&lt;/h3&gt;
&lt;p&gt;这四个类都只能串行地处理请求。即一个请求处理完成之前，新来的请求只能在排队，而无法得到及时处理。这在网络服务器中是不可接受的。解决方案是创建一个单独的进程或线程来处理每个请求。所幸SocketServer包里提供了另外两个工具类来实现请求的并行处理，他们是&lt;code&gt;ForkingMixIn&lt;/code&gt;和&lt;code&gt;ThreadingMixIn&lt;/code&gt;，分别实现&lt;strong&gt;进程&lt;/strong&gt;和&lt;strong&gt;线程&lt;/strong&gt;的并行方案。&lt;/p&gt;
&lt;h3 id="_4"&gt;创建网络服务&lt;/h3&gt;
&lt;p&gt;创建一个服务需要以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承&lt;code&gt;BaseRequestHandler&lt;/code&gt;类，并重载其&lt;code&gt;handle()&lt;/code&gt;方法来实现一个请求处理器。&lt;/li&gt;
&lt;li&gt;创建一个服务器实例(&lt;code&gt;TCPServer&lt;/code&gt; or &lt;code&gt;UDBPServer&lt;/code&gt; etc.)，指定其提供服务的地址和端口，指定请求处理器。&lt;/li&gt;
&lt;li&gt;调用服务器实例的&lt;code&gt;serve_forever()&lt;/code&gt;启动服务。当请求到来时，就会把请求派发给请求处理器处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="_5"&gt;多线程并发的注意事项&lt;/h3&gt;
&lt;p&gt;当使用&lt;code&gt;ThreadingMixIn&lt;/code&gt;来实现多线程并发处理请求时，需要特别注意，当处理请求的线程意外终止时，网络服务进程需要作何反应。这个类提供了一个属性&lt;code&gt;daemon_threads&lt;/code&gt;来定义网络服务进程的行为。当&lt;code&gt;daemon_threads&lt;/code&gt;设置为False（默认）时，表示当处理请求的线程意外终止时，网络服务进程不会退出。而当&lt;code&gt;daemon_threads&lt;/code&gt;设置为True的时候，如果处理请求的线程意外终止，网络服务进程会退出。&lt;/p&gt;
&lt;p&gt;一个并发的UDP网络服务可以简单地通过下面的代码实现：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;ThreadingUDPServer&lt;/span&gt;(ThreadingMixIn, UDPServer): &lt;span style="color: #AA22FF; font-weight: bold"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里需要注意的是，&lt;code&gt;ThreadingMixIn&lt;/code&gt;需要写在&lt;code&gt;UDPServer&lt;/code&gt;之前，因为&lt;code&gt;ThreadingMixIn&lt;/code&gt;重写了&lt;code&gt;UDPServer&lt;/code&gt;类里的一些方法。具体原因可阅读Python多继承机制相关资料。&lt;/p&gt;
&lt;p&gt;请求处理类&lt;code&gt;BaseRequestHandler&lt;/code&gt;有两个子类，他们是&lt;code&gt;StreamRequestHandler&lt;/code&gt;和&lt;code&gt;DatagramRequestHandler&lt;/code&gt;，分别用来处理TCP请求和UDP请求。在使用时可以直接使用子类以便提供更大的方便性。&lt;/p&gt;
&lt;p&gt;如何决定使用&lt;strong&gt;多线程&lt;/strong&gt;还是&lt;strong&gt;多进程&lt;/strong&gt;来实现并发请求处理？这个没有优劣之分。但需要注意&lt;strong&gt;线程&lt;/strong&gt;和&lt;strong&gt;进程&lt;/strong&gt;的本质区别，线程间是共享内存的，而进程是运行在独立的地址空间的。假如一个网络服务把状态信息保存在内存里，并且根据内存里的状态信息对请求做出不同的处理，这个时候就需要使用多线程。因为只有多线程才能及时地读到内存中最新的服务状态。如果实现的是HTTP服务器，它的状态信息都保存在文件里，那么多线程或多进程都可以满足要求。&lt;/p&gt;
&lt;p&gt;有些时候，实现网络服务并发时，一个更灵活的方式是分部处理，即计算速度快的直接并行处理，而需要的计算量比较大的通过子进程来处理。这个方式就不能通过继承&lt;code&gt;ThreadingMixIn&lt;/code&gt;来实现，而应该在请求处理器的&lt;code&gt;handle()&lt;/code&gt;函数里，显式地通过&lt;code&gt;fork()&lt;/code&gt;来创建一个子进程来实现。&lt;/p&gt;
&lt;p&gt;线程和进程毕竟是比较昂贵的系统资源，在系统中线程和进程的数量往往都是有限制的。特别是针对那些TCP服务，一个连接可能持续保持很长时间，导致线程或进程长时间被占用。所以，另外一个方案是，维护一张数组，用来记录那些部分完成的请求，然后使用&lt;code&gt;select()&lt;/code&gt;函数选择那些已经准备就绪的请求进入下一步处理的流程。具体可参考Python标准库&lt;code&gt;asyncore&lt;/code&gt;，它提供用这种方式实现并发处理的一些基础设施。&lt;/p&gt;
&lt;h2 id="_6"&gt;类和接口介绍&lt;/h2&gt;
&lt;h3 id="baseserver"&gt;BaseServer介绍&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BaseServer&lt;/code&gt;是&lt;code&gt;TCPServer&lt;/code&gt;和&lt;code&gt;UDPServer&lt;/code&gt;等服务类的共同父类。它定义了下面的接口，但大部分没有实现。而是由其子类实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BaseServer.fileno()&lt;br /&gt;
  返回一个int型的文件描述符，这个文件代表当前服务正在监听的socket接口。当一个进程里有多个网络服务时，就可以使用这个返回值传给&lt;code&gt;select()&lt;/code&gt;函数用来监测哪个服务已经有请求进来。&lt;/li&gt;
&lt;li&gt;BaseServer.handle_request()&lt;br /&gt;
  处理一个请求。这是个阻塞的函数。当服务进入事件循环开始提供服务时，这个接口被调用。当没有请求到来时，这个函数会阻塞在这等待请求的到来或者超时了返回。这个函数依次调用下面函数：&lt;code&gt;get_request()&lt;/code&gt;，&lt;code&gt;verify_request()&lt;/code&gt;，&lt;code&gt;process_request()&lt;/code&gt;，如果用户提供的请求处理器的&lt;code&gt;handle()&lt;/code&gt;函数抛出异常，服务的&lt;code&gt;handle_error()&lt;/code&gt;函数将被调用。如果在&lt;code&gt;self.timeout&lt;/code&gt;秒内没有收到请求，则调用&lt;code&gt;handle_timeout()&lt;/code&gt;之后，这个函数就返回。&lt;/li&gt;
&lt;li&gt;BaseServer.serve_forever(poll_interval=0.5)&lt;br /&gt;
  进入事件循环，开始提供服务，直到&lt;code&gt;shutdown()&lt;/code&gt;被调用为止。检查&lt;code&gt;shutdown()&lt;/code&gt;是否被调用的时间间隔默认是0.5秒。&lt;/li&gt;
&lt;li&gt;BaseServer.shutdown()&lt;br /&gt;
  停止提供服务。此函数是阻塞函数，会一直等到服务停止后才返回。这个函数必须在&lt;code&gt;serve_forever()&lt;/code&gt;函数运行的不同线程调用，否则会引起死锁。这个函数是Python 2.6版本新加的。&lt;/li&gt;
&lt;li&gt;BaseServer.RequestHandlerClass&lt;br /&gt;
  用户提供的请求处理器类。在处理新的请求时，会创建一个新的类实例给这个请求使用。&lt;/li&gt;
&lt;li&gt;BaseServer.server_address&lt;br /&gt;
  服务监听的地址。地址的格式和所使用的协议(TCP/IP or UNIX domain socket)有极大的相关性，具体参阅&lt;code&gt;socket&lt;/code&gt;模块。如果是IPV4的地址，则其格式是一个包含地址和端口的元组，如&lt;code&gt;("127.0.0.1", "80")&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;BaseServer.socket&lt;br /&gt;
  服务监听请求的socket实例。&lt;/li&gt;
&lt;li&gt;BaseServer.request_queue_size&lt;br /&gt;
  请求队列长度。当服务在处理一个请求时，新来的请求将在这里排除。如果队列长度己满时收到新的请求，则直接会返回一个错误给客户端。默认值是5，子类可以改写这个值。&lt;/li&gt;
&lt;li&gt;BaseServer.timeout&lt;br /&gt;
  当服务进入事件循环，开始等待请求到来时，如果超出&lt;code&gt;timeout&lt;/code&gt;秒还没有请求到来，则会调用&lt;code&gt;handle_timeout()&lt;/code&gt;。如果这个值是&lt;code&gt;None&lt;/code&gt;则表示没有超时限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="requesthandler"&gt;RequestHandler介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RequestHandler.setup()&lt;br /&gt;
  在&lt;code&gt;handle()&lt;/code&gt;调用之前被调用。可以用来做一些初始化工作。默认是空实现。&lt;/li&gt;
&lt;li&gt;RequestHandler.finish()&lt;br /&gt;
  在&lt;code&gt;handle()&lt;/code&gt;返回后被调用。可以用来做一些清理工作。默认是空实现。需要注意的是，如果&lt;code&gt;setup()&lt;/code&gt;抛出异常，这个函数不会被调用。&lt;/li&gt;
&lt;li&gt;RequestHandler.handle()&lt;br /&gt;
  这个函数用来处理请求。默认空实现。一些上下文信息在这个函数里可以使用，&lt;code&gt;self.request&lt;/code&gt;是请求信息；&lt;code&gt;self.client_address&lt;/code&gt;是请求的客户端地址；&lt;code&gt;self.server&lt;/code&gt;是服务实例。&lt;code&gt;self.request&lt;/code&gt;的类型对TCP和UDP服务是不一样的，对TCP它是socket对象，对UDP是一对字符串和socket对象。可以使用&lt;code&gt;StreamRequestHandler&lt;/code&gt;和&lt;code&gt;DatagramRequestHandler&lt;/code&gt;来隐藏这个差异。这两个子类重载了&lt;code&gt;setup()&lt;/code&gt;和&lt;code&gt;finish()&lt;/code&gt;方法，然后提供&lt;code&gt;request.rfile&lt;/code&gt;和&lt;code&gt;request.wfile&lt;/code&gt;的类文件对象，用来读写数据。读即获取请求数据；写即返回应答数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_7"&gt;例子&lt;/h2&gt;
&lt;p&gt;一个简单的回显服务。&lt;/p&gt;
&lt;p&gt;下面是服务端代码。保存为EchoTCPServer.py。&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;SocketServer&lt;/span&gt;

&lt;span style="color: #AA22FF; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;EchoRequestHandler&lt;/span&gt;(SocketServer&lt;span style="color: #666666"&gt;.&lt;/span&gt;StreamRequestHandler):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot; demo request handler &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;handle&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;):
        &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;data &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;rfile&lt;span style="color: #666666"&gt;.&lt;/span&gt;readline()&lt;span style="color: #666666"&gt;.&lt;/span&gt;strip()
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%s&lt;/span&gt;&lt;span style="color: #BB4444"&gt; write: &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%s&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;%&lt;/span&gt; (&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;client_address, &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;data))
        &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;wfile&lt;span style="color: #666666"&gt;.&lt;/span&gt;write(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;data&lt;span style="color: #666666"&gt;.&lt;/span&gt;upper())

&lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; __name__ &lt;span style="color: #666666"&gt;==&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;:
    HOST, PORT &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;, &lt;span style="color: #666666"&gt;5639&lt;/span&gt;

    server &lt;span style="color: #666666"&gt;=&lt;/span&gt; SocketServer&lt;span style="color: #666666"&gt;.&lt;/span&gt;TCPServer((HOST, PORT), EchoRequestHandler)
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;ECHO TCP server is running ...&amp;quot;&lt;/span&gt;)
    server&lt;span style="color: #666666"&gt;.&lt;/span&gt;serve_forever()
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;客户端代码。保存为EchoTCPClient.py&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #008800; font-style: italic"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span style="color: #008800; font-style: italic"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;socket&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #0000FF; font-weight: bold"&gt;sys&lt;/span&gt;

HOST, PORT &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;, &lt;span style="color: #666666"&gt;5639&lt;/span&gt;
data &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;join(sys&lt;span style="color: #666666"&gt;.&lt;/span&gt;argv[&lt;span style="color: #666666"&gt;1&lt;/span&gt;:])

sock &lt;span style="color: #666666"&gt;=&lt;/span&gt; socket&lt;span style="color: #666666"&gt;.&lt;/span&gt;socket(socket&lt;span style="color: #666666"&gt;.&lt;/span&gt;AF_INET, socket&lt;span style="color: #666666"&gt;.&lt;/span&gt;SOCK_STREAM)

&lt;span style="color: #AA22FF; font-weight: bold"&gt;try&lt;/span&gt;:
    sock&lt;span style="color: #666666"&gt;.&lt;/span&gt;connect((HOST, PORT))
    sock&lt;span style="color: #666666"&gt;.&lt;/span&gt;sendall(data &lt;span style="color: #666666"&gt;+&lt;/span&gt; &lt;span style="color: #BB4444"&gt;&amp;#39;&lt;/span&gt;&lt;span style="color: #BB6622; font-weight: bold"&gt;\n&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;&lt;/span&gt;)

    received &lt;span style="color: #666666"&gt;=&lt;/span&gt; sock&lt;span style="color: #666666"&gt;.&lt;/span&gt;recv(&lt;span style="color: #666666"&gt;1024&lt;/span&gt;)
&lt;span style="color: #AA22FF; font-weight: bold"&gt;finally&lt;/span&gt;:
    sock&lt;span style="color: #666666"&gt;.&lt;/span&gt;close()

&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;Send:     &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%s&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;%&lt;/span&gt; (data))
&lt;span style="color: #AA22FF; font-weight: bold"&gt;print&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;quot;received: &lt;/span&gt;&lt;span style="color: #BB6688; font-weight: bold"&gt;%s&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;quot;&lt;/span&gt; &lt;span style="color: #666666"&gt;%&lt;/span&gt; (received))
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;先执行服务端&lt;code&gt;python EchoTCPServer.py&lt;/code&gt;，再执行客户端&lt;code&gt;python EchoTCPClient.py hello SocketServer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;服务端输出如下：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;D:\lab\python&amp;gt;python DemoTCPServer.py
Echo TCP server is running ...
(&amp;#39;127.0.0.1&amp;#39;, 51245) write: hello SocketServer
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;客户端输出如下：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;D:\lab\python&amp;gt;python EchoTCPClient.py hello SocketServer
Send:     hello SocketServer
received: HELLO SOCKETSERVER
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_8"&gt;参考文档&lt;/h2&gt;
&lt;p&gt;Python官方标准库关于&lt;a href="https://docs.python.org/2/library/socketserver.html"&gt;SocketServer&lt;/a&gt;的文档。&lt;/p&gt;</summary><category term="python"></category><category term="SocketServer"></category></entry><entry><title>Python特性汇总</title><link href="http://blog.kamidox.com/python-features.html" rel="alternate"></link><updated>2014-10-04T20:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-10-04:python-features.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;摘要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python-decorator"&gt;Python Decorator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#with"&gt;with语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python-descriptor"&gt;Python Descriptor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文汇总了Python一些重要的特性，并收集了网络上介绍这些特性的优秀的文章。本文将持续更新。&lt;/p&gt;
&lt;h2 id="python-decorator"&gt;Python Decorator&lt;/h2&gt;
&lt;p&gt;如果你对代码中出现的&lt;code&gt;@classmethod&lt;/code&gt;感到很困惑，则需要了解一下Python装饰器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入门文章&lt;br /&gt;
&lt;a href="http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html"&gt;这篇文章&lt;/a&gt;是不可多得的装饰器的入门文章，它对内置装饰器和functools包做详细的介绍。&lt;br /&gt;
&lt;a href="http://www.cnblogs.com/rhcad/archive/2011/12/21/2295507.html"&gt;这篇文章&lt;/a&gt;里对装饰器支持参数传递有一些简单的示例。&lt;/li&gt;
&lt;li&gt;深入阅读&lt;br /&gt;
  如果你对Python Decorator以及开源语言的演进感兴趣，可以深入阅读一些英文的资料。&lt;br /&gt;
&lt;a href="http://legacy.python.org/dev/peps/pep-0318/"&gt;PEP318&lt;/a&gt;对Python Decorator进行了官方定义。&lt;br /&gt;
&lt;a href="https://wiki.python.org/moin/PythonDecorators"&gt;Python Decorator Wiki&lt;/a&gt;更详细地描述了Python Decorator演进的历史。看完这篇文章，对开源语言的演进进程会有个相当直观的了解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="with"&gt;with语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;with&lt;/code&gt;语句是从 Python 2.5 开始引入的一种与异常处理相关的功能。它让我们能更加优雅地编写异常处理代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入门文章&lt;br /&gt;
&lt;a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/"&gt;这篇文章&lt;/a&gt;深入浅出地介绍了with语句产生的背景以及用法。来自IBM developerWorks。&lt;/li&gt;
&lt;li&gt;深入阅读&lt;br /&gt;
&lt;a href="http://legacy.python.org/dev/peps/pep-0343/"&gt;PEP343&lt;/a&gt;对&lt;code&gt;with&lt;/code&gt;语句进行了官方描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="python-descriptor"&gt;Python Descriptor&lt;/h2&gt;
&lt;p&gt;如果你对&lt;code&gt;__get__&lt;/code&gt;，&lt;code&gt;__set__&lt;/code&gt;，&lt;code&gt;__del__&lt;/code&gt;等函数的工作机制不了解。那么需要学习一下Python Descriptor协议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入门文章&lt;br /&gt;
&lt;a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html"&gt;这篇文章&lt;/a&gt;对新式类和经典类以及类对象模式进行了较深入全面的介绍。&lt;br /&gt;
&lt;a href="http://www.cnblogs.com/btchenguang/archive/2012/09/18/2690802.html"&gt;这篇文章&lt;/a&gt;是上一篇文章的续集，正式介绍Python Descriptor。&lt;/li&gt;
&lt;li&gt;深入阅读&lt;br /&gt;
  Python官网关于&lt;a href="https://docs.python.org/2/howto/descriptor.html"&gt;Descriptor的教程&lt;/a&gt;也是一篇非常不错的文章。不过是英文的。&lt;br /&gt;
&lt;a href="http://www.ibm.com/developerworks/library/os-pythondescriptors/"&gt;另外一篇&lt;/a&gt;非常不错的英文文章来自向来质量很高的IBM developerWorks。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="python"></category></entry><entry><title>Python装饰器实例</title><link href="http://blog.kamidox.com/python-decorator-example.html" rel="alternate"></link><updated>2014-10-03T20:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-10-03:python-decorator-example.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#python"&gt;Python装饰器入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#flask"&gt;Flask里使用装饰器的几个例子&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#setupmethod"&gt;setupmethod&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;需求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;源码分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#locked_cached_property"&gt;locked_cached_property&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_4"&gt;需求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;源码分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="python"&gt;Python装饰器入门&lt;/h2&gt;
&lt;p&gt;如果还不知道Python装饰器是什么东西，可以阅读&lt;a href="http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html"&gt;这篇文章&lt;/a&gt;。它深入浅出地用实例介绍了装饰器，并且还介绍内置装饰器和functools包。另外，&lt;a href="http://www.cnblogs.com/rhcad/archive/2011/12/21/2295507.html"&gt;这篇文章&lt;/a&gt;对装饰器支持参数传递有一些简单的示例。也可以作为一个入门的参考。&lt;/p&gt;
&lt;h2 id="flask"&gt;Flask里使用装饰器的几个例子&lt;/h2&gt;
&lt;h3 id="setupmethod"&gt;setupmethod&lt;/h3&gt;
&lt;h4 id="_1"&gt;需求&lt;/h4&gt;
&lt;p&gt;如果web应用程序从运行起处理过一个HTTP请求，这个时候再向Flask添加route规则，则Flask在调试模式下，可以检查出一个APP的错误。为什么这是个错误呢？想像一下，如果一个web应用程序已经上线提供服务了，这个时候由于某些条件触发，向Flask又添加了一个route规则，则说明在添加这个route规则之前，向这个route发送的请求是没有接口可以处理的。&lt;/p&gt;
&lt;h4 id="_2"&gt;解决方案&lt;/h4&gt;
&lt;p&gt;Flask定义了&lt;code&gt;setupmethod&lt;/code&gt;装饰器来确保所有的初始化函数必须在web应用程序开始提供服务之前被调用。如果在已经提供服务之后被调用，则报错。&lt;/p&gt;
&lt;h4 id="_3"&gt;源码分析&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;setupmethod&lt;/code&gt;装饰器源码定义在&lt;a href="https://github.com/mitsuhiko/flask/blob/0.10-maintenance/flask/app.py"&gt;app.py&lt;/a&gt;里：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;setupmethod&lt;/span&gt;(f):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;Wraps a method so that it performs a check in debug mode if the&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    first request was already handled.&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;wrapper_func&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, &lt;span style="color: #666666"&gt;*&lt;/span&gt;args, &lt;span style="color: #666666"&gt;**&lt;/span&gt;kwargs):
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;debug &lt;span style="color: #AA22FF; font-weight: bold"&gt;and&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;_got_first_request:
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;raise&lt;/span&gt; &lt;span style="color: #D2413A; font-weight: bold"&gt;AssertionError&lt;/span&gt;(&lt;span style="color: #BB4444"&gt;&amp;#39;A setup function was called after the &amp;#39;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;&amp;#39;first request was handled.  This usually indicates a bug &amp;#39;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;&amp;#39;in the application where a module was not imported &amp;#39;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;&amp;#39;and decorators or other functionality was called too late.&lt;/span&gt;&lt;span style="color: #BB6622; font-weight: bold"&gt;\n&lt;/span&gt;&lt;span style="color: #BB4444"&gt;&amp;#39;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;&amp;#39;To fix this make sure to import all your view modules, &amp;#39;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;&amp;#39;database models and everything related at a central place &amp;#39;&lt;/span&gt;
                &lt;span style="color: #BB4444"&gt;&amp;#39;before the application starts serving requests.&amp;#39;&lt;/span&gt;)
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; f(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, &lt;span style="color: #666666"&gt;*&lt;/span&gt;args, &lt;span style="color: #666666"&gt;**&lt;/span&gt;kwargs)
    &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; update_wrapper(wrapper_func, f)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;Line 6：这里确保用&lt;code&gt;setupmethod&lt;/code&gt;装饰的函数在被实际调用之前，都会去检查&lt;code&gt;self._got_first_request&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Line 14：这里的&lt;code&gt;f(self, *args, **kwargs)&lt;/code&gt;确保&lt;code&gt;setupmethod&lt;/code&gt;装饰器可以装饰任何参数形式的函数&lt;/li&gt;
&lt;li&gt;Line 15: update_wrapper是functools包提供的一个函数。用来确保被装饰的函数依然可以支持Python的反射机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="locked_cached_property"&gt;locked_cached_property&lt;/h3&gt;
&lt;h4 id="_4"&gt;需求&lt;/h4&gt;
&lt;p&gt;有些属性的计算比较昂贵，如果这个属性又是非常经常被调用。那么把这个属性计算一次后，缓存起来，以确保下次访问时直接访问计算过的值。这个对性能的优化是比较有帮助的。&lt;/p&gt;
&lt;h4 id="_5"&gt;解决方案&lt;/h4&gt;
&lt;p&gt;Flask定义了&lt;code&gt;locked_cached_property&lt;/code&gt;装饰器来实现上述的需求。同时还提供了锁以保存并发线程访问的安全性。&lt;/p&gt;
&lt;h4 id="_6"&gt;源码分析&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;locked_cached_property&lt;/code&gt;装饰器源码定义在&lt;a href="https://github.com/mitsuhiko/flask/blob/0.10-maintenance/flask/helpers.py"&gt;helpers.py&lt;/a&gt;里：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #0000FF"&gt;locked_cached_property&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;object&lt;/span&gt;):
    &lt;span style="color: #BB4444; font-style: italic"&gt;&amp;quot;&amp;quot;&amp;quot;A decorator that converts a function into a lazy property.  The&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    function wrapped is called the first time to retrieve the result&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    and then that calculated result is used the next time you access&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    the value.  Works like the one in Werkzeug but has a lock for&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    thread safety.&lt;/span&gt;
&lt;span style="color: #BB4444; font-style: italic"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;__init__&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, func, name&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;, doc&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;):
        &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;__name__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; name &lt;span style="color: #AA22FF; font-weight: bold"&gt;or&lt;/span&gt; func&lt;span style="color: #666666"&gt;.&lt;/span&gt;__name__
        &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;__module__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; func&lt;span style="color: #666666"&gt;.&lt;/span&gt;__module__
        &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;__doc__ &lt;span style="color: #666666"&gt;=&lt;/span&gt; doc &lt;span style="color: #AA22FF; font-weight: bold"&gt;or&lt;/span&gt; func&lt;span style="color: #666666"&gt;.&lt;/span&gt;__doc__
        &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;func &lt;span style="color: #666666"&gt;=&lt;/span&gt; func
        &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;lock &lt;span style="color: #666666"&gt;=&lt;/span&gt; RLock()

    &lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;__get__&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;, obj, &lt;span style="color: #AA22FF"&gt;type&lt;/span&gt;&lt;span style="color: #666666"&gt;=&lt;/span&gt;&lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;):
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; obj &lt;span style="color: #AA22FF; font-weight: bold"&gt;is&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;None&lt;/span&gt;:
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;
        &lt;span style="color: #AA22FF; font-weight: bold"&gt;with&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;lock:
            value &lt;span style="color: #666666"&gt;=&lt;/span&gt; obj&lt;span style="color: #666666"&gt;.&lt;/span&gt;__dict__&lt;span style="color: #666666"&gt;.&lt;/span&gt;get(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;__name__, _missing)
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;if&lt;/span&gt; value &lt;span style="color: #AA22FF; font-weight: bold"&gt;is&lt;/span&gt; _missing:
                value &lt;span style="color: #666666"&gt;=&lt;/span&gt; &lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;func(obj)
                obj&lt;span style="color: #666666"&gt;.&lt;/span&gt;__dict__[&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;&lt;span style="color: #666666"&gt;.&lt;/span&gt;__name__] &lt;span style="color: #666666"&gt;=&lt;/span&gt; value
            &lt;span style="color: #AA22FF; font-weight: bold"&gt;return&lt;/span&gt; value
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Line 1: 注意这里使用类来实现装饰器，而不是我们常见的函数。&lt;br /&gt;
Line 14: 这里用RLock来实现并发线程访问安全性。&lt;br /&gt;
Line 16: 这里实现了&lt;code&gt;__get__&lt;/code&gt;，即&lt;code&gt;locked_cached_property&lt;/code&gt;是一个non-data descriptor类。&lt;/p&gt;
&lt;p&gt;我们看一下&lt;a href="https://github.com/mitsuhiko/flask/blob/0.10-maintenance/flask/app.py"&gt;app.py&lt;/a&gt;里的&lt;code&gt;name&lt;/code&gt;方法对这个装饰器是怎么使用的：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF"&gt;@locked_cached_property&lt;/span&gt;
&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;name&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;):
    &lt;span style="color: #666666"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据python decorator原理，上述代码实际上相当于下面的python代码：&lt;/p&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td&gt;&lt;div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"&gt;&lt;pre style="line-height: 125%"&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&lt;span style="color: #AA22FF; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #00A000"&gt;name&lt;/span&gt;(&lt;span style="color: #AA22FF"&gt;self&lt;/span&gt;):
    &lt;span style="color: #666666"&gt;...&lt;/span&gt;
name &lt;span style="color: #666666"&gt;=&lt;/span&gt; locked_cached_property(name)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;根据python descriptor协议，Line 3的代码实际上就是定义了一个类的只读属性。即访问&lt;code&gt;app.name&lt;/code&gt;时，实际上执行的是&lt;code&gt;locked_cached_property.__get__&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;这样就实现了&lt;code&gt;app.name&lt;/code&gt;属性只计算一次，且并发访问安全的需求。当然，实现这一需求的方案有很多种，Flask里使用的这种实现方法优雅且pythonic。更重要的是，它使用了AOP(Aspect-Orient Program)编程思想，提高了代码的可复用性。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;专业术语&lt;/p&gt;
&lt;p&gt;如果你对本文使用的很多专业术语感到困惑，可阅读另外一篇&lt;a href="http://blog.kamidox.com/python-features.html"&gt;介绍Python特性&lt;/a&gt;的文章。它是一个网络上一些优秀文章的资源集合。&lt;/p&gt;
&lt;/div&gt;</summary><category term="python"></category><category term="decorator"></category></entry><entry><title>Werkzeug简介</title><link href="http://blog.kamidox.com/werkzeug-overview.html" rel="alternate"></link><updated>2014-10-02T20:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-10-02:werkzeug-overview.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#werkzeug"&gt;什么是Werkzeug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#werkzeug_1"&gt;Werkzeug包含哪些内容的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#werkzeug_2"&gt;关于Werkzeug作者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#whats-next"&gt;What&amp;rsquo;s next?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="werkzeug"&gt;什么是Werkzeug&lt;/h2&gt;
&lt;p&gt;官网的描述是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Werkzeug is a WSGI utility library for Python. It&amp;rsquo;s widely used and BSD licensed. &amp;ndash; &lt;a href="http://werkzeug.pocoo.org/"&gt;Zerkzeug&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么又是WSGI呢？WSGI的全称是Web Server Gateway Interface，它是用来定义web服务器接口的一个规范。简单地讲，就是定义http服务器应该长什么样子，能处理哪些事情。&lt;a href="http://legacy.python.org/dev/peps/pep-3333/"&gt;PEP333&lt;/a&gt;就是对这个规范的详细描述。&lt;/p&gt;
&lt;p&gt;Werkzeug就是用python对WSGI的实现一个通用库。它是&lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;所使用的底层WSGI库。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/mitsuhiko/werkzeug"&gt;Werkzeug的源码&lt;/a&gt;在托管在GitHub，目前的开发还是很活跃的状态。&lt;/p&gt;
&lt;h2 id="werkzeug_1"&gt;Werkzeug包含哪些内容的实现&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP头的解析&lt;/li&gt;
&lt;li&gt;易用使用的request和response对象&lt;/li&gt;
&lt;li&gt;基于交互风格的JavaScript脚本语言的浏览器调试器&lt;/li&gt;
&lt;li&gt;与 WSGI 1.0 规范100%兼容&lt;/li&gt;
&lt;li&gt;支持Python 2.6, 2.7和3.3&lt;/li&gt;
&lt;li&gt;Unicode支持&lt;/li&gt;
&lt;li&gt;HTTP Session和签名Cookie支持&lt;/li&gt;
&lt;li&gt;URI和IRI处理函数，包含对Unicode的支持&lt;/li&gt;
&lt;li&gt;内置兼容一些非标准的WSGI服务器和浏览器&lt;/li&gt;
&lt;li&gt;集成了URLs路由功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="werkzeug_2"&gt;关于Werkzeug作者&lt;/h2&gt;
&lt;p&gt;Werkzeug的作者是&lt;a href="https://github.com/mitsuhiko"&gt;Armin Ronacher&lt;/a&gt;，它是个高产的程序员。从Werkzeug，到Flask，再到Jinja2几乎一个人包圆了。它的&lt;a href="http://lucumr.pocoo.org/"&gt;博客&lt;/a&gt;上也经常分享一些很有价值文章，对Python编程感兴趣的朋友可以读一读。&lt;/p&gt;
&lt;p&gt;看到过一个对Werkzeug和Flask源码的评价：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Most pythonic code and write for human being&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="whats-next"&gt;What&amp;rsquo;s next?&lt;/h2&gt;
&lt;p&gt;挖个大坑：阅读Werkzeug源码，总结一些有价值的信息，写成博文。&lt;/p&gt;</summary><category term="python"></category><category term="wekzeug"></category></entry><entry><title>用sublime来撰写markdown文档</title><link href="http://blog.kamidox.com/write-markdown-using-sublime.html" rel="alternate"></link><updated>2014-09-22T20:20:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-09-22:write-markdown-using-sublime.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;摘要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#markdown"&gt;什么是markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#markdown-preview"&gt;安装Markdown Preview插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#markdown-preview_1"&gt;配置Markdown Preview插件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;配置快捷键&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;代码高亮&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#css"&gt;配置css文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#markdown_1"&gt;几个常用的markdown语法示例&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_4"&gt;标题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;弹出式注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;定义列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;代码片段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_9"&gt;角注&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_10"&gt;表格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_11"&gt;警告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_12"&gt;强调&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_13"&gt;超链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_14"&gt;引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_15"&gt;图片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_16"&gt;目录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_17"&gt;练习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_18"&gt;最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文包含两部分内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在sublime里安装Markdown Preview插件来实现markdown文件的预览&lt;/li&gt;
&lt;li&gt;介绍markdown常用的语法，让初次接触markdown的人可以在短时间内掌握常用的语法和句法&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="markdown"&gt;什么是markdown&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种轻量级标记语言，它允许人们使用&lt;strong&gt;易读易写&lt;/strong&gt;的&lt;strong&gt;纯文本格式&lt;/strong&gt;编写文档，然后转换成&lt;strong&gt;格式丰富的HTML页面&lt;/strong&gt;。    —— &lt;a href="https://zh.wikipedia.org/wiki/Markdown"&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="markdown-preview"&gt;安装Markdown Preview插件&lt;/h2&gt;
&lt;p&gt;推荐的安装方法是通过&lt;a href="https://sublime.wbond.net/"&gt;Package Control&lt;/a&gt;来安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你的sublime还没有安装&lt;a href="https://sublime.wbond.net/"&gt;Package Control&lt;/a&gt;，需要先点击&lt;a href="https://sublime.wbond.net/"&gt;这里&lt;/a&gt;查看安装方法&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;ctrl + shift + P&lt;/code&gt; 来打开命令窗口，输入并选择 &lt;code&gt;Package Control: Install Package&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在弹出的窗口里，输入 &lt;code&gt;Markdown Preview&lt;/code&gt;并按回车来完成安装&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="markdown-preview_1"&gt;配置Markdown Preview插件&lt;/h2&gt;
&lt;h3 id="_2"&gt;配置快捷键&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;Preferences -&amp;gt; Key Bindings - User&lt;/code&gt;打开sublime的快捷键配置文件，把下面内容复制到这个设置文件里保存。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;{ &lt;span style="color: #008000; font-weight: bold"&gt;&amp;quot;keys&amp;quot;&lt;/span&gt;: [&lt;span style="color: #BB4444"&gt;&amp;quot;alt+m&amp;quot;&lt;/span&gt;], &lt;span style="color: #008000; font-weight: bold"&gt;&amp;quot;command&amp;quot;&lt;/span&gt;: &lt;span style="color: #BB4444"&gt;&amp;quot;markdown_preview&amp;quot;&lt;/span&gt;, &lt;span style="color: #008000; font-weight: bold"&gt;&amp;quot;args&amp;quot;&lt;/span&gt;: {&lt;span style="color: #008000; font-weight: bold"&gt;&amp;quot;target&amp;quot;&lt;/span&gt;: &lt;span style="color: #BB4444"&gt;&amp;quot;browser&amp;quot;&lt;/span&gt;, &lt;span style="color: #008000; font-weight: bold"&gt;&amp;quot;parser&amp;quot;&lt;/span&gt;:&lt;span style="color: #BB4444"&gt;&amp;quot;markdown&amp;quot;&lt;/span&gt;} }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置完成后，按下&lt;code&gt;alt + m&lt;/code&gt;即可直接在浏览器里预览markdown的写作效果。&lt;/p&gt;
&lt;h3 id="_3"&gt;代码高亮&lt;/h3&gt;
&lt;p&gt;markdown里嵌入的代码在生成html文档时，支持根据语言高亮显示。通过 &lt;code&gt;Preferences -&amp;gt; Package Settings -&amp;gt; Markdown Preview -&amp;gt; Settings-User&lt;/code&gt; 来打开用户设置文件，加入如下内容即可打开代码高亮功能。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;{
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;quot;enable_highlight&amp;quot;&lt;/span&gt;: &lt;span style="color: #AA22FF; font-weight: bold"&gt;true&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果需要更高级的高亮显示，比如指定代码高亮的风格(emacs, vim etc.)，则可以自定义 &lt;code&gt;codehilite&lt;/code&gt; 扩展来实现。在Markdown Preview用户设置文件里加入如下内容即可。本文就是使用 &lt;code&gt;emacs&lt;/code&gt; 高亮风格来显示代码的。&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;{
    &lt;span style="color: #008000; font-weight: bold"&gt;&amp;quot;enabled_extensions&amp;quot;&lt;/span&gt;: [
            &lt;span style="color: #BB4444"&gt;&amp;quot;extra&amp;quot;&lt;/span&gt;,
            &lt;span style="color: #BB4444"&gt;&amp;quot;github&amp;quot;&lt;/span&gt;,
            &lt;span style="color: #BB4444"&gt;&amp;quot;toc&amp;quot;&lt;/span&gt;,
            &lt;span style="color: #BB4444"&gt;&amp;quot;headerid&amp;quot;&lt;/span&gt;,
            &lt;span style="color: #BB4444"&gt;&amp;quot;meta&amp;quot;&lt;/span&gt;,
            &lt;span style="color: #BB4444"&gt;&amp;quot;sane_lists&amp;quot;&lt;/span&gt;,
            &lt;span style="color: #BB4444"&gt;&amp;quot;smarty&amp;quot;&lt;/span&gt;,
            &lt;span style="color: #BB4444"&gt;&amp;quot;wikilinks&amp;quot;&lt;/span&gt;,
            &lt;span style="color: #BB4444"&gt;&amp;quot;admonition&amp;quot;&lt;/span&gt;,
            &lt;span style="color: #BB4444"&gt;&amp;quot;codehilite(guess_lang=False,pygments_style=emacs)&amp;quot;&lt;/span&gt;
        ]
}
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;关于pygments&lt;/p&gt;
&lt;p&gt;pygments_style可以用来指定代码高亮的风格。Markdown Preview使用pygments来完成代码高亮。关于pygments以及更多可用的内置代码高亮风格，可访问&lt;a href="http://pygments.org/docs/styles/"&gt;pygments官网&lt;/a&gt;查阅相关文档。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="css"&gt;配置css文件&lt;/h3&gt;
&lt;p&gt;Markdown Preview生成的HTML文件，在浏览器里查看时其默认的宽度为45em，如果你觉得生成的网页太窄，可以修改一下css文件。&lt;br /&gt;
打开Markdown Preview的安装目录，找到markdown.css和github.css文件，查找下面的内容：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    &lt;span style="color: #008000; font-weight: bold"&gt;body&lt;/span&gt; {
      &lt;span style="color: #AA22FF; font-weight: bold"&gt;width&lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #666666"&gt;45em&lt;/span&gt;;
      &lt;span style="color: #AA22FF; font-weight: bold"&gt;border&lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #666666"&gt;1px&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;solid&lt;/span&gt; &lt;span style="color: #666666"&gt;#ddd&lt;/span&gt;;
      &lt;span style="color: #AA22FF; font-weight: bold"&gt;outline&lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #666666"&gt;1300px&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;solid&lt;/span&gt; &lt;span style="color: #666666"&gt;#fff&lt;/span&gt;;
      &lt;span style="color: #AA22FF; font-weight: bold"&gt;margin&lt;/span&gt;&lt;span style="color: #666666"&gt;:&lt;/span&gt; &lt;span style="color: #666666"&gt;16px&lt;/span&gt; &lt;span style="color: #AA22FF; font-weight: bold"&gt;auto&lt;/span&gt;;
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把里面的&lt;strong&gt;45em&lt;/strong&gt;修改为&lt;strong&gt;80%&lt;/strong&gt;或者你认为合适的尺寸即可。&lt;/p&gt;
&lt;div class="admonition hint"&gt;
&lt;p class="admonition-title"&gt;sublime安装包目录与格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linux环境&lt;/strong&gt;&lt;br /&gt;
通过 &lt;code&gt;Package Control: List Packages&lt;/code&gt; ，在己安装的Packages里选择 &lt;code&gt;Markdown Preview&lt;/code&gt; 会直接打开Markdown Preview的安装目录，在打开的目录中直接可以找到markdown.css和github.css。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windows环境&lt;/strong&gt;&lt;br /&gt;
在sublime安装目录下，找到 &lt;code&gt;Data\Installed Packages&lt;/code&gt; 目录，这个目录就是安装包的目录。如果已经安装好Markdown Preview，可以看到文件 &lt;code&gt;Markdown Preview.sublime-package&lt;/code&gt; 。这个其实是一个zip包。直接用系统里的压缩工具打开，然后在压缩包的根目录下查找markdown.css和github.css，按照上述方法修改即可。&lt;strong&gt;修改完成需要保存回压缩包&lt;/strong&gt;。在打开压缩包修改的时候，必须关闭sublime，否则无法修改成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="markdown_1"&gt;几个常用的markdown语法示例&lt;/h2&gt;
&lt;h3 id="_4"&gt;标题&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;标题1
=====

#标题1

##标题2

###标题3
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_5"&gt;列表&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;###无序列表1

* 列表1
* 列表2
* 列表3

###无序列表2

- 列表1
- **列表2**
- 列表3

###有序列表

1. 列表1
2. 列表2
3. 列表3
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_6"&gt;弹出式注释&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;把鼠标停留在**HTML**和**W3C**上看会发生什么。

*[HTML]: Hyper Text Markup Language
*[W3C]: World Wide Web Consortium
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_7"&gt;定义列表&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Apple
:   Pomaceous fruit of plants of the genus Malus in
    the family Rosaceae.

Orange
:   The fruit of an evergreen tree of the genus Citrus.
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_8"&gt;代码片段&lt;/h3&gt;
&lt;p&gt;GitHub格式的代码片段：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;```python
#!python
# -*- coding: utf-8 -*-
from flask import Flask, render_template

app = Flask(__name__)
app.debug = APP_DEBUG

#homepage just for fun
@app.route(&amp;#39;/&amp;#39;)
def home():
    return render_template(&amp;#39;index.html&amp;#39;)
```
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Markdown官方推荐的代码片段格式是直接缩进4个空格：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    #!python
    # -*- coding: utf-8 -*-

    if __name__ == &amp;#39;__main__&amp;#39;:
        print(&amp;#39;Hello World&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果不显示代码行号，则可使用下面的格式：&lt;/p&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;    :::python
    # -*- coding: utf-8 -*-

    if __name__ == &amp;#39;__main__&amp;#39;:
        print(&amp;#39;Hello World&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于代码片段及高亮以及行号显示，可参阅&lt;a href="https://pythonhosted.org/Markdown/extensions/code_hilite.html"&gt;codehilite&lt;/a&gt;扩展的官方文档。&lt;/p&gt;
&lt;h3 id="_9"&gt;角注&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;Footnotes[^1] have a label[^@#$%] and the footnote&amp;#39;s content.

[^1]: This is a footnote content.
[^@#$%]: A footnote on the label: &amp;quot;@#$%&amp;quot;.
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_10"&gt;表格&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;First Header  | Second Header
--------------|--------------
Content Cell  | Content Cell
Content Cell  | Content Cell
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_11"&gt;警告&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;####hint类型的警告
!!! hint &amp;quot;subject of hint&amp;quot;
    Any number of other indented markdown elements.

####note类型的警告
!!! note &amp;quot;subject of note&amp;quot;
    Any number of other indented markdown elements.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;警告有多种类型，类型不同生成的html文档样式也不一样，可用的样式有 &lt;code&gt;hint, attention, caution, danger, question, note&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="_12"&gt;强调&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;这是**黑体**写法
这是*斜体*的写法
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_13"&gt;超链接&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;这是一个[链接](https://github.com/kamidox/blogs)
这是另外一种[链接][1]的形式

[1]: https://pythonhosted.org/Markdown/extensions/index.html
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_14"&gt;引用&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;&amp;gt; 引用的文字内容
&amp;gt; 这是另外的引用内容
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_15"&gt;图片&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;![图片描述](https://raw.githubusercontent.com/kamidox/blogs/master/kamidox_icon.png)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_16"&gt;目录&lt;/h3&gt;
&lt;div class="codehilite" style="background: #f8f8f8"&gt;&lt;pre style="line-height: 125%"&gt;[TOC]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_17"&gt;练习&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;直接在配置好的sublime里新建一个readme.md，把上面的markdown语法拷贝进去练习一下。&lt;/li&gt;
&lt;li&gt;推荐一个做得相当不错的markdown在线编辑器&lt;a href="http://maxiang.info/"&gt;马克飞象&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;本文就是用markdown编写的。右键点击&lt;a href="https://raw.githubusercontent.com/kamidox/blogs/master/tools/write_markdown_using_sublime.md"&gt;这里&lt;/a&gt;，另存到本地即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_18"&gt;最佳实践&lt;/h2&gt;
&lt;p&gt;Windows下可以使用sublime对markdown进行编辑预览。但Linux下要让sublime支持中文输入还需要折腾一番。个人认为最佳实践是这样的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows下，使用sublime对markdown进行编辑，预览。&lt;/li&gt;
&lt;li&gt;Linux下，直接使用gedit对markdown进行编辑。gedit的markdown语法高亮看起来非常舒服。编辑完成后，用sublime打开预览效果。&lt;/li&gt;
&lt;/ol&gt;</summary><category term="sublime"></category><category term="markdown"></category></entry><entry><title>About</title><link href="http://blog.kamidox.com/about.html" rel="alternate"></link><updated>2014-07-01T00:00:00+08:00</updated><author><name>Joey Huang</name></author><id>tag:blog.kamidox.com,2014-07-01:about.html</id><summary type="html">&lt;p&gt;&lt;img alt="ABOUT ME" src="https://raw.githubusercontent.com/kamidox/blogs/master/kamidox_icon_mini.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;兰生幽谷，不以无人而不芳&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A programmer mainly on C|Android|Python&lt;/p&gt;
&lt;p&gt;这是我的后花园。得闲来此浇浇花锄锄草。忙时草长茑飞也别有洞天。&lt;/p&gt;
&lt;h2 id="_1"&gt;联系我&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Email: kamidox[AT]qq.com&lt;/li&gt;
&lt;li&gt;GitHub: &lt;a href="https://github.com/kamidox/"&gt;kamidox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;新浪微博: &lt;a href="http://weibo.com/kamidox"&gt;@kamidox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;微信公众帐号: 搜索&lt;code&gt;producthunt&lt;/code&gt;或扫描下面二维码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="producthunt" src="https://raw.githubusercontent.com/kamidox/weixin_producthunt/master/weixin/static/img/qrcode_for_producthunt_weixin.jpg" /&gt;&lt;/p&gt;</summary></entry></feed>